<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#CC0000">
<TITLE>Commands in A </TITLE>
<H2> <A HREF="commands.html">Back to Alphabetical List</A> </H2>

<A NAME="ABS">
<HR> <H3> ABS </H3> 
<BLOCKQUOTE>
<pre>
Computes absolute value of data-sets, Works only on real data-sets 
(itype=0)

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITYPE_1D $ITYPE_2D $ITYPE_3D


 see also : <A HREF="Mcommands.html#MODULUS">MODULUS</A> <A HREF="Rcommands.html#REAL">REAL</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ABSMAX">
<HR> <H3> ABSMAX </H3> 
<BLOCKQUOTE>
<pre>
	Absolute factor to which scale refers to for displaying and 
plotting. Usually ABSMAX holds the largest point of the data-set, 
but you can set it by hand in order to do absolute plots. ABSMAX is 
recomputed whenever the data is changed.
	You can force the ABSMAX to be recomputed by setting it to zero. 
You can also hampers the recomputation of absmax (which can be VERY 
long (on 3D for instance)) by setting it to a standard value at the 
end of the command line

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ABSMAX


 see also : <A HREF="Dcommands.html#DISP1D">DISP1D</A> <A HREF="Dcommands.html#DISP2D">DISP2D</A> <A HREF="Dcommands.html#DISP3D">DISP3D</A> <A HREF="Mcommands.html#MAX">MAX</A> <A HREF="Scommands.html#SCALE">SCALE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ADD">
<HR> <H3> ADD </H3> 
<BLOCKQUOTE>
<pre>
   ADD  name_of_file   -or- ADDC name_of_file
	permits to add to the current data-set the content of the file 
name_of_file, which is in standard format. Works for both 1D, 2D and 
3D data-sets.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NAME


 see also : <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Acommands.html#ADDH">ADDH</A> <A HREF="Mcommands.html#MULT">MULT</A> <A HREF="Rcommands.html#READ">READ</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ADDBASE">
<HR> <H3> ADDBASE </H3> 
<BLOCKQUOTE>
<pre>
   ADDBASE constant
	Removes a constant to the data. The default value is the value of 
SHIFT (computed by EVALN).

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $SHIFT


 see also : <A HREF="Ecommands.html#EVALN">EVALN</A> <A HREF="Scommands.html#SHIFT">SHIFT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ADDC">
<HR> <H3> ADDC </H3> 
<BLOCKQUOTE>
<pre>
Equivalent to ADD


 see also : <A HREF="Acommands.html#ADD">ADD</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ADDDATA">
<HR> <H3> ADDDATA </H3> 
<BLOCKQUOTE>
<pre>
	Add the contents of the DATA buffer to the current data-set. 
Equivalent to ADD but in-memory.


 see also : <A HREF="Acommands.html#ADD">ADD</A> <A HREF="Acommands.html#ADDH">ADDH</A> <A HREF="Ecommands.html#EXCHDATA">EXCHDATA</A> <A HREF="Mcommands.html#MAXDATA">MAXDATA</A> <A HREF="Mcommands.html#MINDATA">MINDATA</A> <A HREF="Mcommands.html#MULT">MULT</A> <A HREF="Mcommands.html#MULTDATA">MULTDATA</A> <A HREF="Pcommands.html#PUT">PUT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="addf">
<HR> <H3> addf </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro/gm    <A HREF="/usr/local/gifa/macro/gm/addf">Show macro</A>
<pre>
 GUI to Add
</pre>
</BLOCKQUOTE>
<A NAME="ADDH">
<HR> <H3> ADDH </H3> 
<BLOCKQUOTE>
<pre>
   ADDH  name_of_file

Same as ADD, with H format files.


 see also : <A HREF="Acommands.html#ADD">ADD</A> <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Ccommands.html#CONCAT">CONCAT</A> <A HREF="Mcommands.html#MULT">MULT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ADDNOISE">
<HR> <H3> ADDNOISE </H3> 
<BLOCKQUOTE>
<pre>
addnoise noise seed

add to the current data-set (1D, 2D, 3D) a white-gaussian, 
characterized
by its level noise, and the random generator seed.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NOISE $RANDOM $RANDOMG $RANDOMZ


 see also : <A HREF="Ecommands.html#EVALN">EVALN</A> <A HREF="Scommands.html#SIMU">SIMU</A> <A HREF="Scommands.html#SIMUN">SIMUN</A> 
</pre>
</BLOCKQUOTE>
<A NAME="add_att">
<HR> <H3> add_att </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_att">Show macro</A>
<pre>
 add_att { f1 f2}

 permits to add a peak in the current data_base
 if called without arguments, wait for a click of the user

</pre>
</BLOCKQUOTE>
<A NAME="add_cnst_db">
<HR> <H3> add_cnst_db </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_cnst_db">Show macro</A>
<pre>
 add_cnst_db #spin1 #spin2 lowl upl upcorr active note 

 permits to add a constraint in the current data_base

</pre>
</BLOCKQUOTE>
<A NAME="add_list.g">
<HR> <H3> add_list.g </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att/dyna    <A HREF="/usr/local/gifa/macro/att/dyna/add_list.g">Show macro</A>
<pre>
 add_list

 This formbox permits to manage a data-set list 

 This dataset list is a file which contains the name of all the spectra to
 be handled by the relaxation module.
 It should be located in the 'processing' subdirectory of the project

 the syntax of the file is the following
 one line per relaxation delay, first the delay value, then the experiment name.
 more than one experiment for a relaxation delay is possible
 # comments are possible

 e.g. :
 #dummy T1 list
 0.1  T1_1
 0.2  T1_2
 0.3  T1_3_1 T1_3_2 T1_3_2
 0.5  T1_5

 this one describes 6 experiments, for 4 delays.

 having several experiments for one delay pemits to estimate
 experiemnt to experiment noise.

 NOE lists have no delays of course, 
  they are supposed to have only 2 lines,
  one with the i'with' keyword, 
  another one with the 'without' keyword signifying with or without presaturation
</pre>
</BLOCKQUOTE>
<A NAME="add_pdb">
<HR> <H3> add_pdb </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_pdb">Show macro</A>
<pre>
add_pdb

 add a PDB file to the current project.
 this is done by creating a soft link to the actual file.
</pre>
</BLOCKQUOTE>
<A NAME="add_spec">
<HR> <H3> add_spec </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_spec">Show macro</A>
<pre>
add_spec

All the spectra handled by the Assignment module have to be located
in the special directory spectra/ of the current project.
The list of the spectra is then handled internally,
the 'file selector' (located in the project menu) permitting to
load them or look at them rapidely.

This tool permit to add to the project spectra already located
elsewhere on your computer.
This is usually done by creating a soft link to the actual file,
rather than copying the file.


 see also : <A HREF="Fcommands.html#file_selector">file_selector</A> 
</pre>
</BLOCKQUOTE>
<A NAME="add_spin">
<HR> <H3> add_spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_spin">Show macro</A>
<pre>
 add_spin {ff}

 permits to add a spin in the current data_base
 if called without arguments, wait for a click of the user

</pre>
</BLOCKQUOTE>
<A NAME="add_spin_sys">
<HR> <H3> add_spin_sys </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/add_spin_sys">Show macro</A>
<pre>
 add_spin_sys $sys_id

 adds a spin to the spin-system $sys_id

</pre>
</BLOCKQUOTE>
<A NAME="alert">
<HR> <H3> alert </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/alert">Show macro</A>
<pre>
 alert "text to display"
Creates a graphic alert box displaying the text. User must click in 
the alert box to continue.


 see also : <A HREF="Dcommands.html#DIALOGBOX">DIALOGBOX</A> <A HREF="Ecommands.html#ERROR">ERROR</A> <A HREF="Pcommands.html#PRINT">PRINT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ALGO">
<HR> <H3> ALGO </H3> 
<BLOCKQUOTE>
<pre>
Context used to describe the current algorithm

Algo is a number of the form       abc
where a, b and, c are the decimal digits.
	c: 0 Gull and Daniel equation for Entropy 
		1 GIFA equation for Entropy 
		2 steepest descent equation is used
		3 conjugate gradient is used
	b: 0 single step iteration
		1 line-maximization using parabolic fit.
		2 : line-maximization using bracketing before parabolic 
fit.
	a: 0 no Wu correction
		1 Wu correction is applied.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ALGO


 see also : <A HREF="Ccommands.html#conjg">conjg</A> <A HREF="Gcommands.html#gad">gad</A> <A HREF="Gcommands.html#gifa">gifa</A> <A HREF="Mcommands.html#MAXENT">MAXENT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="align_peaks">
<HR> <H3> align_peaks </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/align_peaks">Show macro</A>
<pre>
 align_peaks
</pre>
</BLOCKQUOTE>
<A NAME="align_pk_all_spin">
<HR> <H3> align_pk_all_spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/align_pk_all_spin">Show macro</A>
<pre>
 align_pk_all_spin 
 for all spin align the peaks pointing to this spin
 with the chemical shifts of the spin itself.
</pre>
</BLOCKQUOTE>
<A NAME="align_pk_spin">
<HR> <H3> align_pk_spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/align_pk_spin">Show macro</A>
<pre>
 align_pk_spin $spin_id
 for a given spin align the peaks pointing to this spin
 with the chemical shifts of the spin itself.
</pre>
</BLOCKQUOTE>
<A NAME="align_spins">
<HR> <H3> align_spins </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/align_spins">Show macro</A>
<pre>
 align all spins to their associated peaks
</pre>
</BLOCKQUOTE>
<A NAME="align_spin_pk">
<HR> <H3> align_spin_pk </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/align_spin_pk">Show macro</A>
<pre>
 align_spin_pk $pk_id
 for a given peak, align the spins pointed to by the peak, with 
 the chemical shifts of the peak itself.
</pre>
</BLOCKQUOTE>
<A NAME="ALPHA">
<HR> <H3> ALPHA </H3> 
<BLOCKQUOTE>
<pre>
alpha a
This context is the angle along the OZ axis by which the cube is 
rotated during a 3D display with the DISP3D/REF3D set of commands


 see also : <A HREF="Bcommands.html#BETA">BETA</A> <A HREF="Dcommands.html#DISP3D">DISP3D</A> <A HREF="Gcommands.html#GAMA">GAMA</A> 
</pre>
</BLOCKQUOTE>
<A NAME="al_yesno">
<HR> <H3> al_yesno </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro/gm    <A HREF="/usr/local/gifa/macro/gm/al_yesno">Show macro</A>
<pre>
 al_yesno text

 ask to the user and returns yes or no
</pre>
</BLOCKQUOTE>
<A NAME="APPLY">
<HR> <H3> APPLY </H3> 
<BLOCKQUOTE>
<pre>
APPLY what_to_apply 
	Apply a windowing function to the data-set.
You can apply :
FILTER : applies the filter used during MaxEnt iterations, depends 
on LB, GB, JCONS, FILTER
WINDOW : applies the window used during MaxEnt iterations.


 see also : <A HREF="Fcommands.html#FILTER">FILTER</A> <A HREF="Gcommands.html#GB">GB</A> <A HREF="Gcommands.html#GET">GET</A> <A HREF="Jcommands.html#JCONS">JCONS</A> <A HREF="Lcommands.html#LB">LB</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Scommands.html#SHOW">SHOW</A> <A HREF="Wcommands.html#WINDOW">WINDOW</A> 
</pre>
</BLOCKQUOTE>
<A NAME="APPROX">
<HR> <H3> APPROX </H3> 
<BLOCKQUOTE>
<pre>
Used in the BCORR 3 module, to choose the way the baseline is 
estimated.
0 : with ITERMA2 times a moving average filtering on a window of
 size WINMA2.
1 : with a Legendre polynomial approximation of degree DEGRE.
+10 : with a linear interpolation of signal before approximation.
+100 : with an 'elastic effect' that is a rude way to prevent
 from burying the weak lines.


 see also : <A HREF="Bcommands.html#BCORR">BCORR</A> <A HREF="Bcommands.html#BCORRP?">BCORRP?</A> 
</pre>
</BLOCKQUOTE>
<A NAME="apropos">
<HR> <H3> apropos </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/apropos">Show macro</A>
<pre>
 apropos topic
 for GIFA on_line help

 Search the string "topic" in all the help files available

 
 see also : <A HREF="Hcommands.html#help">help</A> 
</pre>
</BLOCKQUOTE>
<A NAME="apsl">
<HR> <H3> apsl </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/apsl">Show macro</A>
<pre>
 automatic 1D phase correction
 APSL method
    A.Heuer J.Magn.Reson. 91 p241 (1991)

 uses the data buffer

 you may want to adapt :
   s_wdth : ration of line width to spectral width used for computing phases
   p_wdth : ration of line width to spectral width used for broadening for peak picking
   npk :  minimum number of peaks needed for phasing
   nfrst : the number of peaks used for first approx

 
 see also : <A HREF="Acommands.html#apsl_cp">apsl_cp</A> <A HREF="Pcommands.html#PH">PH</A> <A HREF="Pcommands.html#PHASE">PHASE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="apsl_cp">
<HR> <H3> apsl_cp </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/apsl_cp">Show macro</A>
<pre>
 apsl_cp i sz

 computes the phase of the peak centered on i, using +/-sz points
 the phase of the peak is returned 
 between -180 and 180
 i  has to be odd !
 used as a routine by the macro apsl

 
 see also : <A HREF="Acommands.html#apsl">apsl</A> 
</pre>
</BLOCKQUOTE>
<A NAME="AR-&gt;DT">
<HR> <H3> AR-&gt;DT </H3> 
<BLOCKQUOTE>
<pre>
AR-&gt;DT size n
Extend the data-set up to size points long by predicting the missing 
data points, using linear prediction.
n = 1 : following points predicted -&gt; forward prediction 
n = 2 : previous points predicted -&gt; backward prediction

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NAR $SI1_1D


 see also : <A HREF="Bcommands.html#BURG">BURG</A> <A HREF="Dcommands.html#DT-&gt;AR">DT-&gt;AR</A> <A HREF="Ocommands.html#ORDER">ORDER</A> <A HREF="Scommands.html#SVD-&gt;AR">SVD-&gt;AR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="AR-&gt;RT">
<HR> <H3> AR-&gt;RT </H3> 
<BLOCKQUOTE>
<pre>
AR-&gt;RT n
Solve the prediction-error polynomial, calculated from the 
autoregressive coefficients. This is the third step of the LP-SVD 
method.
n = 1 : forward coefficients are used to extracted forward roots
n = 2 : backward coefficients are used to extracted backward roots
n = 3 : both set of roots are computed

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NRT $SI1_1D


 see also : <A HREF="Acommands.html#AR-&gt;RT2">AR-&gt;RT2</A> <A HREF="Acommands.html#ARLIST">ARLIST</A> <A HREF="Ocommands.html#ORDER">ORDER</A> <A HREF="Rcommands.html#RT-&gt;AR">RT-&gt;AR</A> <A HREF="Scommands.html#SVD-&gt;AR">SVD-&gt;AR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="AR-&gt;RT2">
<HR> <H3> AR-&gt;RT2 </H3> 
<BLOCKQUOTE>
<pre>
AR-&gt;RT2 n
Equivalent to AR-&gt;RT, but seems to be more stable for very large 
polynomial.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NRT $SI1_1D


 see also : <A HREF="Acommands.html#ARLIST">ARLIST</A> <A HREF="Ocommands.html#ORDER">ORDER</A> <A HREF="Rcommands.html#RT-&gt;AR">RT-&gt;AR</A> <A HREF="Scommands.html#SVD-&gt;AR">SVD-&gt;AR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="AR-&gt;SP">
<HR> <H3> AR-&gt;SP </H3> 
<BLOCKQUOTE>
<pre>
Calculate the modulus of spectrum from the autoregressive Burg 
coefficients. This is the so-called Burg spectrum, (sometimes 
unfortunately called mem spectrum). The spectrum is computed to the 
size of the current 1D buffer size.


 see also : <A HREF="Dcommands.html#DT-&gt;AR">DT-&gt;AR</A> <A HREF="Ocommands.html#ORDER">ORDER</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ARLIST">
<HR> <H3> ARLIST </H3> 
<BLOCKQUOTE>
<pre>
ARLIST n i j
list the autoregressive coefficients from entry i to entry j.
n = 1 : forward coefficients
n = 2 : backward coefficients

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NAR


 see also : <A HREF="Acommands.html#AR-&gt;DT">AR-&gt;DT</A> <A HREF="Acommands.html#AR-&gt;RT">AR-&gt;RT</A> <A HREF="Rcommands.html#RT-&gt;AR">RT-&gt;AR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ascii2spin">
<HR> <H3> ascii2spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/ascii2spin">Show macro</A>
<pre>
 ascii2spin

 This macro extract the chemical shifts of spins 
 from a generic ascii assignment file
 one line per residue

</pre>
</BLOCKQUOTE>
<A NAME="ASSIGN">
<HR> <H3> ASSIGN </H3> 
<BLOCKQUOTE>
<pre>
   The assignment module implements a set of very simple assignment
tools.  It is completely written in the Gifa macro language, and as
such can be fully adapted to your needs.  Right now, it is principally
aimed toward protein and peptide assignment.

   You enter the module by choosing 'Assignment' in Mode menu.

   Here is a simple 'recipe' on how to use this module:

1) get a set of nice processed homonuclear 2D experiments somewhere on
the computer system.

2) create a new project, enter the primary sequence, and link all your
nice 2D into the spectra directory; then read-in the TOCSY.

3) peak-pick the TOCSY spectrum, at least on the finger print region
and copy it over into the assignment data-base, eventually redo so for
NH-side chain regions.

4) use the marker tool to note peak alignments, eventually confirm by
"showing" also the NOESY, or a TOCSY from other experimental
conditions.

5) once a spin system is found, and noted with one or several markers,
eventually create the corresponding additional peaks with marker tool,
create spins, and put them in the special "build-list";

6) promote the spin-list to a spin-system

7) go back to 4) as long as there are spin-systems to assign.

8) load the NOESY in place of the TOCSY

9) use the NH-NH region and the NH-Ha region to do the sequential
assignment, use the marker tool again to create new NOESY peaks in the
data-base. Check peaks and spins with the find peak and find spin
tools, use edit peak to add peaks in the NOESY data base.

10) once a sequential is found, modify the spin systems accordingly

11) go back to 9 as long as the sequential is not finished

12) assign all remaining NOESY peaks.

13) output the NOESY peaks in the form of a XPLOR constraint list
(this will become automatic soon !)  Thirteen steps, not such a big
deal after all !
</pre>
</BLOCKQUOTE>
<A NAME="ASSIGNMENT">
<HR> <H3> ASSIGNMENT </H3> 
<BLOCKQUOTE>
<pre>
A complete assignment module is available witin Gifa. It is almost 
completely written in the Gifa macro language (a some Perl script), and as 
such can be fully adapted to your needs.

Right now, it is principally aimed toward protein and peptide assignment.  
Extending it to oligonucleotides and sugars is probably a simple matter of 
extending the basic residues data-bases.  However, I have no idea whether 
it can be used to help in the assignment process of other kind of organic 
molecules or not.

You will not find here any fancy tools nor automatic assignment, the only 
help provided here consists in a set of tools permitting to visualise 
several spectra at the same time, to add notes to peaks, to draw lines to 
help for visual align search, and to store the information in several 
data-bases, one for assigned peaks, one for spins and one for spin systems 
(consisting simply in a set of spins).  For the moment, this module works 
mostly for 2D data-sets and has little support for heteronuclear 3D.

Try Assignment in the Mode menu</pre>
</BLOCKQUOTE>
<A NAME="att->fil">
<HR> <H3> att->fil </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/att->fil">Show macro</A>
<pre>
 pk-&gt;att filename

 copy the current assignment data-base to a peak file
 that can be read with pkread.
 create a database filename.hash giving the relation between 
 the peak index in the assignment data-base and in the peak file. 
</pre>
</BLOCKQUOTE>
<A NAME="att2txt"></a>
<HR> <H3> att2txt </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/att2txt">Show macro</A>
<pre>
att2txt

 dump on ascii files all the database (att and cnst (all spectra))
</pre>
</BLOCKQUOTE>
<A NAME="autocalib"></a>
<HR> <H3> autocalib </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/autocalib">Show macro</A>
<pre>
 autocalib

 this is based on the work by Wishart et al, J.Biomol NMR, (1995) 6 p135-140

 computes the correct offset in F1 from F2
</pre>
</BLOCKQUOTE>
<A NAME="AXIS"></a>
<HR> <H3> AXIS </H3> 
<BLOCKQUOTE>
<pre>
AXIS axis_to_draw
with axis_to_draw : [ NONE | F1 | F2 | F12 ]

Determines how coordinates will be drawn on screen
Axes are drawn on the 1D, the 2D density and the 2D contour windows.
The unit is determined by the command UNIT

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $AXIS $UNIT


 see also : <A HREF="Ccommands.html#CDISP2D">CDISP2D</A> <A HREF="Dcommands.html#DISP1D">DISP1D</A> <A HREF="Dcommands.html#DISP2D">DISP2D</A> <A HREF="Pcommands.html#PLOTAXIS">PLOTAXIS</A> <A HREF="Pcommands.html#PLOTAXIS?">PLOTAXIS?</A> <A HREF="Ucommands.html#UNIT">UNIT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="AXIS3D"></a>
<HR> <H3> AXIS3D </H3> 
<BLOCKQUOTE>
<pre>
axis3d fx   where x is 1, 2, 3, 12, 13, or 123
This context holds the focal length that will be used for computing 
a 3D display with the DISP3D/REF3D set of commands


 see also : <A HREF="Ccommands.html#CHECK3D">CHECK3D</A> <A HREF="Dcommands.html#DISP3D">DISP3D</A> <A HREF="Rcommands.html#REF3D">REF3D</A> 
</pre>
</BLOCKQUOTE>

  
 </body>