<html>
<head>
<!-- This document created by dodoc_html V2.1>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#CC0000">
<TITLE>Commands in I </TITLE>
<H2> <A HREF="commands.html">Back to Alphabetical List</A> </H2>

<A NAME="IF">
<HR> <H3> IF </H3> 
<BLOCKQUOTE>
<pre>
Used for tests in command.
2 syntaxes are available :

IF test THEN
..commands on several lines
{ ELSIF test2 THEN
..commands }   (eventually many exclusive tests )
{ ELSE	  (default case)
..commands }
ENDIF
The different commands will executed conditionnally on the value of 
the tests. A non-zero value is considered as true.
Permits to construct complex tests in command files.

IF test remaining_of_the_line
execute the remaining_of_the_line conditionally on the value of 
test. It will be executed only if test is true (non zero). The 
remaining of the line can span several lines by using the line 
continuation sign : \
This form can be used at the prompt level, as well as in call-backs, 
for instance in graphic buttons. It is called the one-line IF.

Tests available are :
for numeral : == != &lt; &gt; &lt;= &gt;= 
for strings : s= s!
for combinations: &amp; | !
as well as several tests functions and variables :  exist() eof() 
$arg $c_joined, etc...

IF(in the first syntaxe) ELSIF ELSE and ENDIF should appear alone on 
one line, eventually followed by a comment. There is no limitation 
for the one-line IF.


 see also : <A HREF="Ccommands.html#CONTROLS">CONTROLS</A> <A HREF="Fcommands.html#FOR">FOR</A> <A HREF="Fcommands.html#FOREACH">FOREACH</A> <A HREF="Fcommands.html#FUNCTIONS">FUNCTIONS</A> <A HREF="Gcommands.html#GOTO">GOTO</A> <A HREF="Wcommands.html#WHILE">WHILE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="IFT">
<HR> <H3> IFT </H3> 
<BLOCKQUOTE>
<pre>
Perform  complex inverse Fourier Transform on data


 see also : <A HREF="Fcommands.html#FT">FT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="IFTBIS">
<HR> <H3> IFTBIS </H3> 
<BLOCKQUOTE>
<pre>
IFTBIS { axis }

Perform  inverse of complex-to-real Fourier Transform on data.
This command is the basic step for Hilbert transform. The Hilbert 
transform is the mathematical operation which transform the real 
part of a causal spectrum (for instance an NMR spectrum) to its 
imaginary part.
The command sequence :
IFTBIS PHASE 90 0 FTBIS
realises this operation, thus permitting to regenerate the imaginary 
part of the signal, when it is lost for some reasons.
A more usefull operation consists in transforming a real 
(unphasable) spectrum to a complex (phasable) spectrum.
either on place (twice as less points in the real part) (1D syntax):
IFTBIS FT
or with a constant resolution (zerofilling once)
IFTBIS CHSIZE (%*2) FT

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITYPE_1D $ITYPE_2D $ITYPE_3D


 see also : <A HREF="Fcommands.html#FT">FT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INCREM">
<HR> <H3> INCREM </H3> 
<BLOCKQUOTE>
<pre>
Constant used to increment lambda during MaxEnt iteration(0.1 .. 1) 


 see also : <A HREF="Lcommands.html#LAMBCONT">LAMBCONT</A> <A HREF="Lcommands.html#LAMBDA">LAMBDA</A> <A HREF="Mcommands.html#MAXENT">MAXENT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INITINPROGRESS">
<HR> <H3> INITINPROGRESS </H3> 
<BLOCKQUOTE>
<pre>
INITINPROGRESS n
Presets for n iterations, the progress bar, of the form :
In Progress : 0%....25%....50%....75%....100%
The progress bar is then updated with the INPROGRESS command.


 see also : <A HREF="Icommands.html#INPROGRESS">INPROGRESS</A> <A HREF="Pcommands.html#PRINT">PRINT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INPROGRESS">
<HR> <H3> INPROGRESS </H3> 
<BLOCKQUOTE>
<pre>
INPROGRESS i
Displays the progress of the operation in the progress bar, inited 
with the INITINPROGRESS command.


 see also : <A HREF="Icommands.html#INITINPROGRESS">INITINPROGRESS</A> <A HREF="Pcommands.html#PRINT">PRINT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INT1D">
<HR> <H3> INT1D </H3> 
<BLOCKQUOTE>
<pre>
A very crude 1D graphic integrator. The data is replaced by the 
running sum of the previous data. Better integrals will be obtain 
with base-line corrected spectra. The curve can then be optimized 
with BCORR, ADDBASE, etc...
 

 see also : <A HREF="Icommands.html#INTEG">INTEG</A> 
</pre>
</BLOCKQUOTE>
<A NAME="int1di">
<HR> <H3> int1di </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro/misc    <A HREF="/usr/local/gifa/macro/misc/int1di">Show macro</A>
<pre>
 performs 1D integration between 2 points
 interactively determined
</pre>
</BLOCKQUOTE>
<A NAME="INTANA">
<HR> <H3> INTANA </H3> 
<BLOCKQUOTE>
<pre>
   The intensity analysis module implements a set of simple tools 
dedicated to the analysis of peak intensity according to the 
assignment database. It is completely written in the Gifa macro 
language, and can be fully adapted to your needs.

   The module is now contained in the button "Intens-ana" of 
the assignment menu.

   Here is a simple 'recipe' on how to use this module:

   If you want to produce a constraint file used for structure 
generation:

1) Determine accurate intensities of database peaks using 
the 'integ', 'sumrec', 'amoeba' or 'line-fitter procedure. 
The command is ?

2) Determine a set of calibration peaks, which will be used 
to define distance estimates on the current peak of the database 
(Choose the calibration intensities).
This set of peaks contains the calibration distances chosen for 
a series of peaks, for which the corresponding intensities are 
contained in the database.

3) Write the output constraint file, according to the set of 
calibration peaks. The file cab be written in XPLOR or DIANA format, 
and the distance estimates can be generated in the 'build_up' or 
'qualitative' ways. 'Build-up' way means that a precise distance 
estimate is quantitatively determined from the information 
contained in the peak calibration set. Then, a general uncertainty 
can be supposed for all the distances.

   If you want to generate files containing intensity variation on 
a series of data-sets (in the case you want to perform quantitative 
T1, T2 or nOe analysis).

1) Copy the database to an ascii peak file (same format than those 
used in pkread/pkwrite commands), and save the lookup table giving 
the peak index in function of the database index (command: Copy db 
to a pk file).

2) Then read this peak file (PkRead) and integrate it using the 
amoeba procedure. Save the amoeba file using the same basename than 
the peak file.

3) Finally, perform a multiple integration of the series of data-sets 
according to the saved amoeba file, using the 'Multiple Integration Tool'. 
For each peak in the database, an intensity file is generated and 
you can check it by using the 'Show Inegration Curve' command.

</pre>
</BLOCKQUOTE>
<A NAME="INTEG">
<HR> <H3> INTEG </H3> 
<BLOCKQUOTE>
<pre>
INTEG factor slope thres { radius }

INTEG computes the volume of the peak detected by PEAK. You need to
use the peak-picker PEAK before to use INTEG. INTEG uses the 
methods described for the PARIS method. It first evaluate the extension of
the current peak, using 3 criteria :

- factor : the extension stop whenever the level goes below
  inten/factor (where inten is the intensity of the peak)
- slope : the extension stop whenever the the slope get larger than
  slope/point (0 means whenever it goes up)
- thres the extension stop whenever the level goes below thres.

In 2D, an additional parameter is the maximum extension radius for 
each peak, and the extensions are stored in an amoeba file.
  
INTEG uses the baseline and noise information held in SHIFT 
and NOISE, which are computed automatically by EVALN

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NOISE $SHIFT $NPK1D $NPK2D $NPK3D
                   $PK1D_A[i] $PK2D_A[i] $PK3D_A[i]


 see also : <A HREF="Icommands.html#INT1D">INT1D</A> <A HREF="Icommands.html#integrate">integrate</A> <A HREF="Mcommands.html#mdfamb">mdfamb</A> <A HREF="Mcommands.html#MSKCONC">MSKCONC</A> <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#MSKMODIF">MSKMODIF</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> <A HREF="Ncommands.html#NOISE">NOISE</A> <A HREF="Pcommands.html#PEAK">PEAK</A> <A HREF="Pcommands.html#pksumrec">pksumrec</A> <A HREF="Scommands.html#saveamb">saveamb</A> <A HREF="Scommands.html#setamb">setamb</A> <A HREF="Scommands.html#SHIFT">SHIFT</A> <A HREF="Scommands.html#SIGN_PEAK">SIGN_PEAK</A> <A HREF="Scommands.html#SUMREC">SUMREC</A> <A HREF="Zcommands.html#ZERO_QU">ZERO_QU</A> 
</pre>
</BLOCKQUOTE>
<A NAME="integrate">
<HR> <H3> integrate </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/integrate">Show macro</A>
<pre>
 integrate

 This tool is intented to realize the 'old' 1D integration, so loved
 by the chemists. With it, you can define integration zones,
 name draw and calibrate them.

 When you first enter the tool, no integration zone is defined, so you
   are presented with an empty box.

           'New Zone'
 To create a new integration zone, click on the the 'New zone' button.
   A small dialog will tell you to select the region, do so with the mouse
   (left + medium buttons or shift-left button).
   Then (only then) click on Ok in the small dialog. The interaction box
   will redraw itself with an additionnal line for the new zone.
   You can define as many zones as you wish, and zones can superpose!
 The line for the defined zone present the name of the zone (its index
   by default), the starting and ending points, and the integral value.
   By default the first zone is calibrated to 1.0
 You can change the name and the calibration constant on using the specific
   buttons on the right of the entry.
 You can change the starting and ending points, simply by modifying them
  in the box (click on calibrate to recompute the calibration).
 You can even delete a given integration zone with the corresponding
  button on the line.

            'Draw'
 If you change the display (e.g. by zooming in or changing scale),
   you can redraw the integration curves on the spectrum with the
   'Draw' button on the botton of the box, (same action thant 'Apply')
 The cursor just above the buttons permit to scale on the display
   the size of the integration versus the size of the spectrum.

            'List'
 The 'List' button simply produces a listing of the zone and the integration
   values on the terminal.

            'Reset'
 If you goofed completely with the zone definitions (or if you inadvertedly
   use a previously defined zone set (see below)), you can throw every thing
   and restart form an empty box.

            'Close and forget'
 The definitions used by the tool are statically stored in the program. So if
   you simply close the integration box, the definitions will remain in memory.
   When entering again the integration tool, these old definitions will show again.
   This can be very convenient in certain cases, but can also be very cumbersome.
   If you close the box with the 'Close and forget' button, all the static definitions
   will go away.
   These static definitions imply also that you can have only one integrate box
   on screen at a single time (most boxes (such as easy1d, easy2d) storing variables
   locally, can have independent instances on screen at the same time)
 

 Calling from macros
 The 'integrate' macro checks wether there are arguments on its calling line,
 so if you want to use it in another macro, put it alone on one line, so
 that the formbox will build.

 
 see also : <A HREF="Ecommands.html#easy1d">easy1d</A> <A HREF="Icommands.html#INTEG">INTEG</A> 
</pre>
</BLOCKQUOTE>
<A NAME="integ_att">
<HR> <H3> integ_att </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/integ_att">Show macro</A>
<pre>
 integ_att (interactive)

 Performs integration of all the peaks of the opened dbm assignment 
 table (it is not possible to perform this integration only on the 
 current zoom window, because of a bug in dbm described in CAVEAT). 
 The calulated volumes are put into the peak amplitude

 Different integration methods can be used:
 - 'Max Intensity' simply gives the value at the peak location
 - 'Max in box' gives the highest value in the peak box
 - 'Sumrec' computes the sum of the points in the peak box
 - 'Amoeba' computes the sum over an automatically determine integration area

 'sumrec' and 'amoeba' make use of the 
 commands  SUMREC and INTEG respectively.

 
 see also : <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#mult_integ">mult_integ</A> <A HREF="Scommands.html#SHOWPEAKS">SHOWPEAKS</A> <A HREF="Scommands.html#SUMREC">SUMREC</A> 
</pre>
</BLOCKQUOTE>
<A NAME="integ_att.g">
<HR> <H3> integ_att.g </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att/dyna    <A HREF="/usr/local/gifa/macro/att/dyna/integ_att.g">Show macro</A>
<pre>
 integ_att

 calls quant1pk which
 builds a dialog box permitting to integrate a peak along a dataset list
 in the data base.
</pre>
</BLOCKQUOTE>
<A NAME="INVF">
<HR> <H3> INVF </H3> 
<BLOCKQUOTE>
<pre>
INVF {Fx}

Process data-sets by multiplying by -1 1 point every 2 points. 
Equivalent to taking the conjugated on complex data-sets, or 
hyperconjugated on hypercomplex data-sets. If applied on a complex 
FID, inverses the final spectrum obtained after Fourier transform.
 

 see also : <A HREF="Fcommands.html#FT">FT</A> <A HREF="Icommands.html#ITYPE">ITYPE</A> <A HREF="Rcommands.html#REVERSE">REVERSE</A> <A HREF="Rcommands.html#REVF">REVF</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INVLAP">
<HR> <H3> INVLAP </H3> 
<BLOCKQUOTE>
<pre>
INVLAP size

Realizes the inverse Laplace transform of the current data-set, considered as 
regularly sampling the time domain with a sampling rate SPECW.  The 
transform is computed for 'size' data-points spanning the range DMIN-DMAX 
in a logarithmic manner. The inversion is performed by MaxEnt iteration.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITERDONE $CHI2 $DMIN $DMAX $ALGO


 see also : <A HREF="Dcommands.html#DMAX">DMAX</A> <A HREF="Dcommands.html#DMIN">DMIN</A> <A HREF="Dcommands.html#dosy2d">dosy2d</A> <A HREF="Dcommands.html#dosy3d">dosy3d</A> <A HREF="Icommands.html#INVTLAP">INVTLAP</A> <A HREF="Icommands.html#INVTLAPCONT">INVTLAPCONT</A> <A HREF="Lcommands.html#LAPLACE">LAPLACE</A> <A HREF="Mcommands.html#MAXENT">MAXENT</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Tcommands.html#TRANSLAP">TRANSLAP</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INVLAPCONT">
<HR> <H3> INVLAPCONT </H3> 
<BLOCKQUOTE>
<pre>
Continue INVLAP iteration. All the parameters may be 
modified before CONTinuing, but the current spectrum as hold in the 
working buffer should not be modified.
 
related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITERDONE $CHI2


 see also : <A HREF="Icommands.html#INVLAP">INVLAP</A> <A HREF="Icommands.html#INVTLAPCONT">INVTLAPCONT</A> <A HREF="Icommands.html#ITER">ITER</A> <A HREF="Mcommands.html#MAXENTCONT">MAXENTCONT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INVTLAP">
<HR> <H3> INVTLAP </H3> 
<BLOCKQUOTE>
<pre>
INVTLAP 
Computes the inverse Laplace transform of the current data-set, considered as 
sampled at the location tabulated in the TAB buffer.  Current data-set 
should have the same number of points than the TAB buffer.  The transform 
is computed for 'size' data-points spanning the range DMIN-DMAX in a 
logarithmic manner.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $DMIN $DMAX $SI_TAB $TAB[]  $ALGO


 see also : <A HREF="Dcommands.html#DMAX">DMAX</A> <A HREF="Dcommands.html#DMIN">DMIN</A> <A HREF="Dcommands.html#dosy2d">dosy2d</A> <A HREF="Dcommands.html#dosy3d">dosy3d</A> <A HREF="Icommands.html#INVTLAP">INVTLAP</A> <A HREF="Lcommands.html#LAPLACE">LAPLACE</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Tcommands.html#TRANSTLAP">TRANSTLAP</A> 
</pre>
</BLOCKQUOTE>
<A NAME="INVTLAPCONT">
<HR> <H3> INVTLAPCONT </H3> 
<BLOCKQUOTE>
<pre>
Continue INVTLAP iteration. All the parameters may be 
modified before CONTinuing, but the current spectrum as hold in the 
working buffer should not be modified.
 
related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITERDONE $CHI2


 see also : <A HREF="Icommands.html#INVLAPCONT">INVLAPCONT</A> <A HREF="Icommands.html#INVTLAP">INVTLAP</A> <A HREF="Icommands.html#ITER">ITER</A> <A HREF="Mcommands.html#MAXENTCONT">MAXENTCONT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="IRFT">
<HR> <H3> IRFT </H3> 
<BLOCKQUOTE>
<pre>
Perform  inverse real-to-complex Fourier Transform on data

 see also : <A HREF="Fcommands.html#FT">FT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ITER">
<HR> <H3> ITER </H3> 
<BLOCKQUOTE>
<pre>
Number of iterations used by all the iterative modules of GIFA : 
MaxEnt with MAXENT or MAXENTCONT . But also LINEFIT and AUTOPHASE

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITER $ITERDONE


 see also : <A HREF="Mcommands.html#MINITER">MINITER</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ITERMA2">
<HR> <H3> ITERMA2 </H3> 
<BLOCKQUOTE>
<pre>
ITERMA2 value
internal value for BCORR 3 algorithm


 see also : <A HREF="Bcommands.html#BCORR">BCORR</A> <A HREF="Bcommands.html#BCORRP?">BCORRP?</A> 
</pre>
</BLOCKQUOTE>
<A NAME="ITYPE">
<HR> <H3> ITYPE </H3> 
<BLOCKQUOTE>
<pre>
ITYPE 0..7

ITYPE is a context which describes the type of data in the image buffer.

For 1D if Itype is 1 then the data-set is considered as complex 
(with real and imaginary parts interleaved), if Itype is 0, the 
data-set is considered as real. 

For 2D data-sets, itype takes values 0 (real) 1 (complex in dim 
2, real in dim 1), 2 (complex in dim1, real in dim 2) and 3 (complex 
in both dimensions).

For 3D data-sets, itype takes values 0 (real) 1 (complex in dim 
3, real in dim 1 and 2), 2 (complex in dim 2, real in dim 1 and 3), 
4 (complex in dim 1 real in dim 2 and 3) and the sums for the 
combinations.

Itype is normally handled automatically by the program. Changing the 
value of Itype DOES NOT CHANGE the data, only what the program 
believes they are. When the itype is wrong, use another command 
(example FT instead of RFT) or make them real (command REAL).

Results of FT, IFT, RFT, IFTBIS PK-&gt;DT, SIMU, SIMUN etc... are 
complex. Results from IRFT, FTBIS, MODULUS, REAL (!) etc... are 
real. Image from Maximum Entropy Iteration are real.

Linear Prediction package works only on real FIDS. To make real 
FID complex,use the sequence RFT IFT.

When displaying complex data sets, only the real part is shown on 
the screen.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> :$ITYPE_1D $ITYPE_2D $ITYPE_3D


 see also : <A HREF="Fcommands.html#FLIP">FLIP</A> <A HREF="Fcommands.html#FLOP">FLOP</A> <A HREF="Fcommands.html#FT">FT</A> <A HREF="Mcommands.html#MODULUS">MODULUS</A> <A HREF="Rcommands.html#REAL">REAL</A> 
</pre>
</BLOCKQUOTE>
<A NAME="IVALUE">
<HR> <H3> IVALUE </H3> 
<BLOCKQUOTE>
<pre>
Constant used to set the initial value of the image (1e-3 .. 1e3) 
Default value is 1.0


 see also : <A HREF="Mcommands.html#MAXENT">MAXENT</A> 
</pre>
</BLOCKQUOTE>

 </body> 
 