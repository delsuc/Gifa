<html>
<head>
<!-- This document created by dodoc_html V2.1 -->
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#CC0000">
<TITLE>Commands in M </TITLE>
<H2> <A HREF="commands.html">Back to Alphabetical List</A> </H2>

<A NAME="MACRO">
<HR> <H3> MACRO </H3> 
<BLOCKQUOTE>
<pre>
One of the strength of the Gifa program is its macro language.  Many 
features of the standard program are actually developed as macros.

For the lay user, this insures that the program will react exactly the same 
on all the computer platforms for which Gifa is designed; and warrants a 
fast development of high level features.

For advanced users, the benefit is much larger of course, as you can adapt 
the distributed macros to more finely fit your needs, or you can write your 
own macros to realises specific features.

The macro language is rich enough to permit to create easily sophisticate 
mathematical processing or high level control structures with a full 
graphical user interface.  The purpose of this chapter is to help you in 
writing such macros.

Macros are simply files that contains commands as they could have been 
typed at the Gifa prompt.  Any command that can be used in-line can be used 
in a macro, and nearly every command and syntax that is used in a macro can 
be used in-line.  Of course there is more than that, you can define 
variables, use control structures, access contexts, use functions, build 
graphic interfaces, macros can be called from within macros.

All internal states of Gifa can be accessed through environment variables 
called 'contexts'.  Many functions are available : string, mathematics, 
spectral coordinates, etc...
</pre>
</BLOCKQUOTE>
<A NAME="make_backup">
<HR> <H3> make_backup </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/make_backup">Show macro</A>
<pre>
make backup for the assignment project directory

</pre>
</BLOCKQUOTE>
<A NAME="marker">
<HR> <H3> marker </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/marker">Show macro</A>
<pre>
 marker

 creates an interactive marker on the screen.
 click as many time as wished on the screen with left mouse button,
 exit with right button,
 when exiting, will create a small box that will redraw the lines selected with the click.
 lines can Symmetric (homonuclear) or asymmetric

 in the marker box, the following actions can be applied :
 - Redraw the marked lines
 - Extend the marker with new locations
 - Show peaks detected at the intersection of the marked lines
 - Add missing peaks at the intersections of the marked lines
 - Add the detected peaks to the Build-List

 The following parameters can be selected
 - Lines can be either diagonal symmetric (COSY-type) or Asymmetric (HSQC-type)
 - The color of the line can be selected

</pre>
</BLOCKQUOTE>
<A NAME="MAX">
<HR> <H3> MAX </H3> 
<BLOCKQUOTE>
<pre>
Finds the maximum and minimum points of the current data-set. Load 
the values used by MINIMAX.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $MAX[1] $MAX[2]


 see also : <A HREF="Acommands.html#ABSMAX">ABSMAX</A> <A HREF="Mcommands.html#MAX">MAX</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MAXDATA">
<HR> <H3> MAXDATA </H3> 
<BLOCKQUOTE>
<pre>
Compare the content of the current buffer with the content of the 
DATA buffer, and leave in memory the largest of the 2 values.
Usefull for projections or symetrisation macros.


 see also : <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Ecommands.html#EXCHDATA">EXCHDATA</A> <A HREF="Mcommands.html#MINDATA">MINDATA</A> <A HREF="Mcommands.html#MULTDATA">MULTDATA</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Scommands.html#SYM">SYM</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MAXENT">
<HR> <H3> MAXENT </H3> 
<BLOCKQUOTE>
<pre>
MAXENT  SI1 { SI2 }

Start Maximum Entropy iteration. The user is prompted for the size 
of the reconstructed image.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITERDONE $CHI2  $ALGO


 see also : <A HREF="Acommands.html#ALGO">ALGO</A> <A HREF="Ccommands.html#conjg">conjg</A> <A HREF="Gcommands.html#gad">gad</A> <A HREF="Gcommands.html#gifa">gifa</A> <A HREF="Icommands.html#INVLAP">INVLAP</A> <A HREF="Icommands.html#INVTLAP">INVTLAP</A> <A HREF="Icommands.html#ITER">ITER</A> <A HREF="Mcommands.html#MAXENTCONT">MAXENTCONT</A> <A HREF="Ncommands.html#NDISP">NDISP</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MAXENTCONT">
<HR> <H3> MAXENTCONT </H3> 
<BLOCKQUOTE>
<pre>
Continue Maximum Entropy iteration. All the parameters may be 
modified before CONTinuing, but the current spectrum as hold in the 
working buffer should not be modified.
 
related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITERDONE $CHI2


 see also : <A HREF="Icommands.html#INVLAPCONT">INVLAPCONT</A> <A HREF="Icommands.html#INVTLAPCONT">INVTLAPCONT</A> <A HREF="Icommands.html#ITER">ITER</A> <A HREF="Mcommands.html#MAXENT">MAXENT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="maxent_dosy">
<HR> <H3> maxent_dosy </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/maxent_dosy">Show macro</A>
<pre>
 utility used by dosy2d when processing in MaxEnt

 stores temporary results in a file, and get back to it if
 something went wrong

 
 see also : <A HREF="Dcommands.html#dosy2d">dosy2d</A> <A HREF="Icommands.html#INVTLAP">INVTLAP</A> <A HREF="Icommands.html#INVTLAPCONT">INVTLAPCONT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MAXINBOX">
<HR> <H3> MAXINBOX </H3> 
<BLOCKQUOTE>
<pre>
MAXINBOX f1_low f2_low f1_up f1_up
Seqarch for the larger point in the given area.
Value is stored in the context $MAXINBOX

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $MAXINBOX


 see also : <A HREF="Ecommands.html#EVALN">EVALN</A> <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#maxinbox">maxinbox</A> <A HREF="Pcommands.html#pksumrec">pksumrec</A> <A HREF="Scommands.html#sumrec_1d">sumrec_1d</A> 
</pre>
</BLOCKQUOTE>
<A NAME="maxinbox">
<HR> <H3> maxinbox </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att/dyna    <A HREF="/usr/local/gifa/macro/att/dyna/maxinbox">Show macro</A>
<pre>
 maxinbox lf1 lf2 ur 1 ur2

 computes the value of the maximum data point in the defined
 box. value is returned in $returned global variable

 
 see also : <A HREF="Scommands.html#SUMREC">SUMREC</A> 
</pre>
</BLOCKQUOTE>
<A NAME="maxinbox.g">
<HR> <H3> maxinbox.g </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att/dyna    <A HREF="/usr/local/gifa/macro/att/dyna/maxinbox.g">Show macro</A>
<pre>
 maxinbox lf1 lf2 ur 1 ur2

 computes the value of the maximum data point in the defined
 box. value is returned in $returned 

 
 see also : <A HREF="Scommands.html#SUMREC">SUMREC</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mdfamb">
<HR> <H3> mdfamb </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/mdfamb">Show macro</A>
<pre>
mdfamb  interactive

 this macro permits to interactively and graphically
 modify a peak amoeba by selecting one-by-one pixels.
 two possibilities are available.  
 "add": add the selected pixel to the pic amoeba. 
 "erase": remove the selected pixel from the pic amoeba. 
 If the pixel is in another peak amoeba, the program ask 
 information to user.

 
 see also : <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Scommands.html#saveamb">saveamb</A> <A HREF="Scommands.html#setamb">setamb</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MEDIAN">
<HR> <H3> MEDIAN </H3> 
<BLOCKQUOTE>
<pre>
MEDIAN { y } x index

Executes a median filter on the data-set (1D or 2D).a window of x 
points (or y by x in 2D) is moved along the data set, the point are 
ordered, and the indexth point is taken as the new point for the 
data set.


 see also : <A HREF="Scommands.html#SMOOTH">SMOOTH</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MEMORY">
<HR> <H3> MEMORY </H3> 
<BLOCKQUOTE>
<pre>
The GIFA program holds all the data in one single large memory 
buffer. This buffer is used for several purposes, and may be divided 
into smaller pieces. The size of this buffer is displayed when 
entering the program, or with the CONFIG command. There is no way to 
use a larger data-set than this memory size but recompiling. This 
buffer is used for 1D as well as 2D and 3D operations. In all cases 
the whole buffer is available.  However, when moving back and forth 
between 1D, 2D or 3D mode, or when using memory intensive commands, 
only partial regions of the buffers are protected. The size of these 
protected regions are given with CONFIG command. The idea is that 
you can eat-up all the available memory for a single data-set if you 
which, but that certain operations will be forbidden on it.

For instance, you can handle a full memory 2D data-set if you do 
not wish to do 3D. However, when working in 3D, if you zero-fill a 
2D plane extracted from the 3D, over the protected area size for 2D, 
you will destroy a part of the 3D buffer. You will sometime get the 
question : 'This will overflow the xx buffer, Ok?' when there is any 
risk of  destroying one of the buffer. This question is not asked in 
macro execution, where you are supposed to know what you are doing.

See documentation for a more detailed description of the memory  set-up.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $MEM_MAX $MEM_PRO_1D $MEM_PRO_2D $MEM_PRO_3D $VAR_MAX


 see also : <A HREF="Ccommands.html#CONFIG">CONFIG</A> <A HREF="Gcommands.html#GET">GET</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Vcommands.html#VARIABLES">VARIABLES</A> 
</pre>
</BLOCKQUOTE>
<A NAME="merge_pkatt">
<HR> <H3> merge_pkatt </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/merge_pkatt">Show macro</A>
<pre>
 merge_pkatt

 merge the peak table into a database for each peak of the peak table, 
 look at the closest element of the database within the tolerance
 and change the spectral coordinates and the intensity of this element to 
 the peak coordinates and intensity.
 If no database element in found within the peak tolerance, add the peak to the 
 database as an unassigned element.

</pre>
</BLOCKQUOTE>
<A NAME="MESSAGE">
<HR> <H3> MESSAGE </H3> 
<BLOCKQUOTE>
<pre>
message text

This command ermits to build interactive macros. If no argument 
is present on the calling line when MESSAGE is executed, the text 
will be issued to the user when the next data entry will be needed; 
if an argument is present, nothing will happend.

If the macro is called from a menu button, then the text will 
appear in the data entry dialog box.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ARG


 see also : <A HREF="Pcommands.html#PRINT">PRINT</A> <A HREF="Scommands.html#SETPROMPT">SETPROMPT</A> <A HREF="Vcommands.html#VARIABLES">VARIABLES</A> 
</pre>
</BLOCKQUOTE>
<A NAME="METH">
<HR> <H3> METH </H3> 
<BLOCKQUOTE>
<pre>
METH 0/1/2

When set to 0, indicates that the current build-up curve is taken 
from 2 simple hydrogens, when set to 1, indicates that there is 1 
methyle group, when set to 2, 2 methyle groups. Used by DIST


 see also : <A HREF="Ccommands.html#CALIBDI">CALIBDI</A> <A HREF="Dcommands.html#DIST">DIST</A> <A HREF="Rcommands.html#RELAXRATE">RELAXRATE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MINDATA">
<HR> <H3> MINDATA </H3> 
<BLOCKQUOTE>
<pre>
Compare the content of the current buffer with the content of the 
DATA buffer, and leave in memory the smallest of the 2 values.
Usefull for projections or symetrisation macros.


 see also : <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Ecommands.html#EXCHDATA">EXCHDATA</A> <A HREF="Mcommands.html#MAXDATA">MAXDATA</A> <A HREF="Mcommands.html#MULTDATA">MULTDATA</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Scommands.html#SYM">SYM</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MINIMAX">
<HR> <H3> MINIMAX </H3> 
<BLOCKQUOTE>
<pre>
MINIMAX mini maxi

Load the value of the minimum and the maximum points that will be 
used for peak-picking. These value are loaded by the MAX command.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $max[1] $max[2]


 see also : <A HREF="Mcommands.html#MAX">MAX</A> <A HREF="Pcommands.html#PEAK">PEAK</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MINIMIZE">
<HR> <H3> MINIMIZE </H3> 
<BLOCKQUOTE>
<pre>
MINIMIZE 'expression to minimize' num_of_param

This command calls the generic minimizer and permits to compute the
value and the location of the minimimum of a given function.

'expression to minimize' is the function, given in Gifa language
    that will be minimized. The free (adaptable) parameters will
    be called $Pi with i ranging from 1 to num_of_par.

num_of_par is the number of parameters to adapt in the previous
    expression

The adapted parameter are stored in the global user variables
$P1..$Pn, if the variables do not exist before the call they
will created with initial value of 1.0, if they exists, their value
will be taken as initial value for the minimization

The algorithm used is the Powell method, which does not
require any derivative.  The number of iterations is controled by ITER
and MINITER.

eg :
	MINIMIZE 'sin($p1)*sin($p2)' 2

will find the minimum to be  -1.0
      and the optimum to be : 1.57064 and -1.57122
		stored in $p1 and $p2




related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $CHI2


 see also : <A HREF="Fcommands.html#FITEXP">FITEXP</A> <A HREF="Fcommands.html#FITGENE">FITGENE</A> <A HREF="Icommands.html#ITER">ITER</A> <A HREF="Lcommands.html#LINEFIT">LINEFIT</A> <A HREF="Lcommands.html#LINEFITD">LINEFITD</A> <A HREF="Mcommands.html#MINITER">MINITER</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MINITER">
<HR> <H3> MINITER </H3> 
<BLOCKQUOTE>
<pre>
Secondary iteration number for two steps minimisation in GIFA.
Number of iterations used for the line-minimization during one step 
of the MaxEnt iteration.
In a MaxEnt run, the number of FT's per iteration is MINITER + 2
Also used by other iterative process LINEFIT AUTOPHASE

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $MINITER


 see also : <A HREF="Icommands.html#ITER">ITER</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MINUS">
<HR> <H3> MINUS </H3> 
<BLOCKQUOTE>
<pre>
Sets to zero the positive parts of the signal


 see also : <A HREF="Acommands.html#ABS">ABS</A> <A HREF="Ocommands.html#ONE">ONE</A> <A HREF="Pcommands.html#PLUS">PLUS</A> <A HREF="Zcommands.html#ZERO">ZERO</A> <A HREF="Zcommands.html#ZEROING">ZEROING</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MIRROR">
<HR> <H3> MIRROR </H3> 
<BLOCKQUOTE>
<pre>
mirror X

implements mirror image reflection, as proposed by Zhu and Bax J.Magn.Reson. 90, p405 (1990)

X determines the position of the t=0 point
X =  0  no shift : in-phase data set
    -1  acquisition started exactly half a dwell after t=0 (will need phase 0 180)
    n&gt;0 acquisition started exactly n dwell before t=0
        Warning, this is not coherent notation


 see also : <A HREF="Bcommands.html#BURG">BURG</A> <A HREF="Bcommands.html#burg_mirror">burg_mirror</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mkdbppm">
<HR> <H3> mkdbppm </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/mkdbppm">Show macro</A>
<pre>
 Macro to generate a ppm DBM file from a ppm ascii file

 mkdbppm dbm_ppm_filename ascii_ppm_filename 

 the ascii ppm file has the following free-format:

 PPM residu_name residu_number atom_name ppm_value linewidth_value

 
 see also : <A HREF="Dcommands.html#DBOPEN">DBOPEN</A> <A HREF="Scommands.html#SimSpect2D">SimSpect2D</A> <A HREF="Scommands.html#SIMUN">SIMUN</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MODIFYSIZE">
<HR> <H3> MODIFYSIZE </H3> 
<BLOCKQUOTE>
<pre>
MODIFYSIZE si1 si2 {si3}

Used mostly for hacking
Permits to modify the leading sizes of a 2D or a 3D data-set, 
provided the product of the sizes : si1*si2{*si3} is equal to the 
product of the old ones.

Does not actually modify the data.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $SI1_1D $SI1_2D $SI1_3D $SI2_2D $SI2_3D $SI3_3D


 see also : <A HREF="Ccommands.html#CHSIZE">CHSIZE</A> <A HREF="Scommands.html#size">size</A> 
</pre>
</BLOCKQUOTE>
<A NAME="module">
<HR> <H3> module </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/module">Show macro</A>
<pre>
 obsolote, use MODULUS instead
</pre>
</BLOCKQUOTE>
<A NAME="MODULUS">
<HR> <H3> MODULUS </H3> 
<BLOCKQUOTE>
<pre>
MODULUS is used to calculates the modulus of the spectrum. 
In 2D, will only works for fully Hypercomplex data-sets  (itype == 
3) or for data-sets complex in F2 (itype == 1) not for data-set 
complex in F2 (itype == 2). In this last case, you should use FLOP 
before doing MODULUS.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ITYPE_1D $ITYPE_2D $ITYPE_3D


 see also : <A HREF="Acommands.html#ABS">ABS</A> <A HREF="Fcommands.html#FLIP">FLIP</A> <A HREF="Fcommands.html#FLOP">FLOP</A> <A HREF="Rcommands.html#REAL">REAL</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mod_att">
<HR> <H3> mod_att </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mod_att">Show macro</A>
<pre>
 mod_att $pic

 builds a dialog box permitting to modify a peak in the data base.
 (called with the 'edit peak' in the menu )

</pre>
</BLOCKQUOTE>
<A NAME="mod_calib">
<HR> <H3> mod_calib </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mod_calib">Show macro</A>
<pre>
 mod_calib $pic

 builds a dialog box permitting to modify the calibration distance of a
 calibration peak.

</pre>
</BLOCKQUOTE>
<A NAME="mod_spin">
<HR> <H3> mod_spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mod_spin">Show macro</A>
<pre>
 mod_spin spin_id

 permits to interactively modify a spin

</pre>
</BLOCKQUOTE>
<A NAME="mod_sys">
<HR> <H3> mod_sys </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mod_sys">Show macro</A>
<pre>
 mod_sys sys_id

 permits to interactively modify a spin system
 and the associated spins

 if called as : mod_sys sys_id name index    will do the modification
</pre>
</BLOCKQUOTE>
<A NAME="MONOPOINT">
<HR> <H3> MONOPOINT </H3> 
<BLOCKQUOTE>
<pre>
Permits to click once on the data-set. The top value on the point 
stak : context variables, $POINTX[1], $POINTY[1] and $BUTTON are set 
accordingly. If $NPOINT is zero (after a POINT_CLEAR) it is set to 
1, unchanged otherwise.
Useful for macros.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NPOINT $POINTX[1] $POINTY[1] $BUTTON


 see also : <A HREF="Pcommands.html#point">point</A> <A HREF="Pcommands.html#POINT_PUSH">POINT_PUSH</A> <A HREF="Zcommands.html#ZM">ZM</A> 
</pre>
</BLOCKQUOTE>
<A NAME="more">
<HR> <H3> more </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/more">Show macro</A>
<pre>
as in unix

 
 see also : <A HREF="Ccommands.html#CD">CD</A> <A HREF="Lcommands.html#ls">ls</A> <A HREF="Pcommands.html#pwd">pwd</A> <A HREF="Rcommands.html#rm">rm</A> <A HREF="Scommands.html#SH">SH</A> <A HREF="Vcommands.html#vi">vi</A> <A HREF="Vcommands.html#vim">vim</A> <A HREF="Vcommands.html#vip">vip</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MORPHOB">
<HR> <H3> MORPHOB </H3> 
<BLOCKQUOTE>
<pre>
internal value for BCORR 3 algorithm


 see also : <A HREF="Bcommands.html#BCORR">BCORR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MORPHOS">
<HR> <H3> MORPHOS </H3> 
<BLOCKQUOTE>
<pre>
internal value for BCORR 3 algorithm


 see also : <A HREF="Bcommands.html#BCORR">BCORR</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mosaic">
<HR> <H3> mosaic </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mosaic">Show macro</A>
<pre>
 mosaic "list of spins"

</pre>
</BLOCKQUOTE>
<A NAME="mov_att">
<HR> <H3> mov_att </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mov_att">Show macro</A>
<pre>
 mov_att $pic
</pre>
</BLOCKQUOTE>
<A NAME="mov_att_top">
<HR> <H3> mov_att_top </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mov_att_top">Show macro</A>
<pre>
 mov_att_top  $att

 moves the current peak to the local top


</pre>
</BLOCKQUOTE>
<A NAME="mov_spin">
<HR> <H3> mov_spin </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mov_spin">Show macro</A>
<pre>
 mov_spin $spin_id
</pre>
</BLOCKQUOTE>
<A NAME="MSKCONC">
<HR> <H3> MSKCONC </H3> 
<BLOCKQUOTE>
<pre>
MSKCONC previous_peak new_peak

Reasigns all the points of the amoeba associated to previous_peak 
with the amoeba of the peak new_peak. After this operation, 
previous_peak does not have any amoeba left.


 see also : <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#MSKMODIF">MSKMODIF</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Mcommands.html#MSKSEARCH">MSKSEARCH</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MSKINTEG">
<HR> <H3> MSKINTEG </H3> 
<BLOCKQUOTE>
<pre>
integrates the current 2D data buffer using the last defined amoeba mask.

The results are put into the peak list.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $PK1D_A[i] $PK2D_A[i] $PK2D_ERR[i] $PK3D_A[i]


 see also : <A HREF="Gcommands.html#GET">GET</A> <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#mdfamb">mdfamb</A> <A HREF="Mcommands.html#MSKCONC">MSKCONC</A> <A HREF="Mcommands.html#MSKMODIF">MSKMODIF</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Mcommands.html#MSKSEARCH">MSKSEARCH</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> <A HREF="Pcommands.html#PUT">PUT</A> <A HREF="Scommands.html#saveamb">saveamb</A> <A HREF="Scommands.html#setamb">setamb</A> <A HREF="Scommands.html#SIGN_PEAK">SIGN_PEAK</A> <A HREF="Zcommands.html#ZERO_QU">ZERO_QU</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MSKMODIF">
<HR> <H3> MSKMODIF </H3> 
<BLOCKQUOTE>
<pre>
MSKMODIF crdf1 crdf2 nopeak

Assign the pixel at coordinates crdf1 crdf2 to the amoeba of the 
peak nopeak. The pixel coordinates crdf1 and crdf2 are given in  index.
Setting a nopeak of zero removes that pixel from the amoeba 
definition.


 see also : <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#MSKCONC">MSKCONC</A> <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Mcommands.html#MSKSEARCH">MSKSEARCH</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> <A HREF="Scommands.html#SETVAL">SETVAL</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mskread">
<HR> <H3> mskread </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/mskread">Show macro</A>
<pre>
 mskread file_name
 read the peak table and the amoeba written with mskwrite
 for integration with mskinteg
 appends extensions .pek and .amb to file_name

 
 see also : <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> <A HREF="Pcommands.html#PKREAD">PKREAD</A> <A HREF="Pcommands.html#PKWRITE">PKWRITE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MSKSEARCH">
<HR> <H3> MSKSEARCH </H3> 
<BLOCKQUOTE>
<pre>
MSKSEARCH peak_number

Gives the (F2,F1) coordinates of all the pixels located in 
the integration mask of a peak.
The coordinates are given in index.


 see also : <A HREF="Icommands.html#INTEG">INTEG</A> <A HREF="Mcommands.html#MSKCONC">MSKCONC</A> <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#MSKMODIF">MSKMODIF</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Mcommands.html#mskwrite">mskwrite</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mskwrite">
<HR> <H3> mskwrite </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/mskwrite">Show macro</A>
<pre>
 mskwrite file_name
 write the peak table and the amoeba for latter integration
 with mskread and mskinteg
 appends extensions .pek and .amb to file_name

 
 see also : <A HREF="Mcommands.html#MSKINTEG">MSKINTEG</A> <A HREF="Mcommands.html#mskread">mskread</A> <A HREF="Pcommands.html#PKREAD">PKREAD</A> <A HREF="Pcommands.html#PKWRITE">PKWRITE</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MSKZERO">
<HR> <H3> MSKZERO </H3> 
<BLOCKQUOTE>
<pre>
MSKZERO 

Put the value zero (0.0) in the current amoeba buffer. Quite a destructive 
command !
 

 see also : <A HREF="Mcommands.html#MSKCONC">MSKCONC</A> <A HREF="Mcommands.html#MSKMODIF">MSKMODIF</A> <A HREF="Zcommands.html#ZERO">ZERO</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MULT">
<HR> <H3> MULT </H3> 
<BLOCKQUOTE>
<pre>
MULT x
Multiply data-set by a scalar.


 see also : <A HREF="Acommands.html#ADD">ADD</A> <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Mcommands.html#MULTDATA">MULTDATA</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MULTDATA">
<HR> <H3> MULTDATA </H3> 
<BLOCKQUOTE>
<pre>
Multiplies point by point, the content of the current working buffer 
with the content of the DATA buffer. Permits to realize convolution 
product. Works in 1D, 2D, in real, complex and hypercomplex modes.


 see also : <A HREF="Acommands.html#ADDDATA">ADDDATA</A> <A HREF="Ecommands.html#EXCHDATA">EXCHDATA</A> <A HREF="Mcommands.html#MAXDATA">MAXDATA</A> <A HREF="Mcommands.html#MINDATA">MINDATA</A> <A HREF="Mcommands.html#MULT">MULT</A> <A HREF="Pcommands.html#PUT">PUT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="MULTIPOINT">
<HR> <H3> MULTIPOINT </H3> 
<BLOCKQUOTE>
<pre>
Permits to click several time on the data-set. Similar to POINT, but 
no output is generated. The values of the pseudo-variables $NPOINT, 
$POINTX[1], $POINTY[1] and $BUTTON are set accordingly. Useful for 
macros.

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $NPOINT $POINTX[1] $POINTY[1] $BUTTON


 see also : <A HREF="Mcommands.html#MONOPOINT">MONOPOINT</A> 
</pre>
</BLOCKQUOTE>
<A NAME="multi_zoom">
<HR> <H3> multi_zoom </H3> 
<BLOCKQUOTE>
 located in /usr/local/gifa/macro    <A HREF="/usr/local/gifa/macro/multi_zoom">Show macro</A>
<pre>
 multi_zoom

 creates a tool which permits to handle several zoom box on a data-set.

 you can define zoom regions
         jump to a given window
         store and load a set of zoom definitions (stored as macro commands)
         draw the zoom definitions on screen

 when loaded, the zoom definition are stored in an associative array called
 zmem[]

related <A HREF="Ccommands.html#CONTEXTS">contexts</A> : $ZOOM $ZOOM_1D[1..2] $ZOOM_2D[1..4] $ZOOM_3D[1..6]

related variable : $ZMEM[]


 see also : <A HREF="Ccommands.html#center">center</A> <A HREF="Pcommands.html#point">point</A> <A HREF="Rcommands.html#rzoom">rzoom</A> <A HREF="Zcommands.html#ZM">ZM</A> <A HREF="Zcommands.html#zoom3di">zoom3di</A> 
</pre>
</BLOCKQUOTE>
<A NAME="mult_integ">
<HR> <H3> mult_integ </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mult_integ">Show macro</A>
<pre>
 mult_integ (interactive)

 permits the integration of peaks along a series of 
 experiments according to an assignment database, an amoeba file
 and a data-sets list. 
 For each peak, the integral values are written in Tela source file format 
 in an independent file, located in processing directory
 The amoeba file basename is also the name of the hash data-base between 
 the indexes of peaks in assignment data-base and peak file.

 mult_integ calls compute_label

</pre>
</BLOCKQUOTE>
<A NAME="mult_integ.new">
<HR> <H3> mult_integ.new </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mult_integ.new">Show macro</A>
<pre>
 mult_integ (interactive)

 permits the integration of peaks along a series of 
 experiments according to an assignment database, an amoeba file
 and a data-sets list. 
 For each peak, the integral values are written in Tela source file format 
 in an independent file, located in processing directory
 The amoeba file basename is also the name of the hash data-base between 
 the indexes of peaks in assignment data-base and peak file.

 mult_integ calls compute_label

</pre>
</BLOCKQUOTE>
<A NAME="mult_integ.old">
<HR> <H3> mult_integ.old </H3> 
<BLOCKQUOTE>
 <B>part of the Assignment Module</B> <P> 
 located in /usr/local/gifa/macro/att    <A HREF="/usr/local/gifa/macro/att/mult_integ.old">Show macro</A>
<pre>
 mult_integ (interactive)

 permits the integration of peaks along a series of 
 experiments according to an assignment database, an amoeba file
 and a data-sets list. 
 For each peak, the integral values are written in Tela source file format 
 in an independent file, located in processing directory
 The amoeba file basename is also the name of the hash data-base between 
 the indexes of peaks in assignment data-base and peak file.

 mult_integ calls compute_label

</pre>
</BLOCKQUOTE>
<A NAME="MUNSET">
<HR> <H3> MUNSET </H3> 
<BLOCKQUOTE>
<pre>
munset list_of_variable_name *

Removes all the variables which names are found in 
list_of_variable_name from the variable table. The list is 
terminated by a * sign. Note that no $ sign are needed.


 see also : <A HREF="Scommands.html#SET">SET</A> <A HREF="Tcommands.html#tunset">tunset</A> <A HREF="Ucommands.html#UNSET">UNSET</A> <A HREF="Vcommands.html#VARIABLES">VARIABLES</A> 
</pre>
</BLOCKQUOTE>

 </body> 
 