<html>
<head><!-- This document created by dodoc_html v1.0 --></head><body>
<TITLE> List of entry points for GIFA</TITLE>
<H1> List of entry points for GIFA</H1>
<H3>  Click <A HREF="programer_dico.html"> HERE </A> if you want the List per Files </H3>
<A NAME="AFF_FORMULAIRE">
 <H3>AFF_FORMULAIRE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void AFF_FORMULAIRE(str_pt,error)
 int *str_pt;
 int *error;
 /*-------------------------------------------------------------
 *       void AFF_FORMULAIRE(str_form_data,error)
 *       IN : str_form_data
 *       INOUT: error
 *
 *       Affiche le formulaire apres son elaboration
 *       var:
 *               FORM_data *str_form_data;pt struct generale
 *               int *error; error si != 0;
 *                         ( si formulaire est bloquant
 *                           error = 1 si cancel )
 */
 </PRE>
<A NAME="ALIGN_FIELD_FORM">
 <H3>ALIGN_FIELD_FORM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void ALIGN_FIELD_FORM(str_pt,error)
 int *str_pt;
 int *error;
 /*-------------------------------------------------------------
 *       void ALIGN_FIELD_FORM(str_w_parent,error)
 *
 *       IN: str_w_parent
 *       INOUT: error;
 *
 *	permet d'aligner n objets dans un meme champs
 *
 */
 </PRE>
<A NAME="ARROW_CURSOR_IN_ALL_SHELL">
 <H3>ARROW_CURSOR_IN_ALL_SHELL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void ARROW_CURSOR_IN_ALL_SHELL()
 /*
         delete cursor montre (attente) dans
         tout les shell de commandes
         dans boite de zoom , window_mere,
         et formulaire....
 */
 </PRE>
<A NAME="BRUKERPHASE">
 <H3>BRUKERPHASE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/bruker_corr.c"> /usr/local/gifa/source/bruker_corr.c </A> 
 <PRE> float BRUKERPHASE(int *dspfirm, int *dspfvs,int *decim, float *sw)
 /*
 The brukerphase function computes the correction for the Bruker figital filter.
 the phase correction to apply is computed given the 3 parameters :
 DSPFIRM DSPFVS DECIM
 as found in the acqus parameter file in XwinNMR
 
 dspfvs is not used so far
 
 syntax compatible with F77 calling conventions
 
 version 1.0
 10 oct 2001 - M.A.D.
 */
 
 </PRE>
<A NAME="BUTT_COMM">
 <H3>BUTT_COMM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void BUTT_COMM(w_parent,name_f,lg_name,command_f,lg_comm,error)
 Widget *w_parent;
 int *lg_name,*lg_comm,*error;
 char name_f[];
 char command_f[];
 /*
 	ajoute un bouton dans les commandes
 */
 </PRE>
<A NAME="Butt_titre">
 <H3>Butt_titre</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> Widget Butt_titre(label_titre,context)
 XContext context;
 String label_titre;
 /*
 **      Butt_titre     :ajoute un bouton dans le titre
 */
 </PRE>
<A NAME="CDAXPY">
 <H3>CDAXPY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE CDAXPY(N,CA,CX,INCX,CY,INCY) 
  
      CONSTANT TIMES A VECTOR PLUS A VECTOR. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1),CY(1),CA 
 </PRE>
<A NAME="CDDOTC">
 <H3>CDDOTC</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       FUNCTION CDDOTC(N,CX,INCX,CY,INCY) 
  
      FORMS THE DOT PRODUCT OF TWO VECTORS, CONJUGATING THE FIRST 
      VECTOR. 
      JACK DONGARRA, LINPACK,  3/11/78. 
  
       COMPLEX*16 CX(1),CY(1),CTEMP,CDDOTC 
 </PRE>
<A NAME="CDGECO">
 <H3>CDGECO</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cdgeco.for"> /usr/local/gifa/source/cdgeco.for </A> 
 <PRE>       SUBROUTINE CDGECO(A,LDA,N,IPVT,RCOND,Z) 
 </PRE>
<A NAME="CDGEDI">
 <H3>CDGEDI</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cdgedi.for"> /usr/local/gifa/source/cdgedi.for </A> 
 <PRE>       SUBROUTINE CDGEDI(A,LDA,N,IPVT,DET,WORK,JOB)                     
 </PRE>
<A NAME="CDGEFA">
 <H3>CDGEFA</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cdgefa.for"> /usr/local/gifa/source/cdgefa.for </A> 
 <PRE>       SUBROUTINE CDGEFA(A,LDA,N,IPVT,INFO) 
 </PRE>
<A NAME="CDGESL">
 <H3>CDGESL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cdgesl.for"> /usr/local/gifa/source/cdgesl.for </A> 
 <PRE>       SUBROUTINE CDGESL(A,LDA,N,IPVT,B,JOB) 
 </PRE>
<A NAME="CDNRM2">
 <H3>CDNRM2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       FUNCTION CDNRM2( N, CX, INCX) 
 </PRE>
<A NAME="CDROT">
 <H3>CDROT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  CDROT (N,CX,INCX,CY,INCY,C,S) 
  
      APPLIES A PLANE ROTATION, WHERE THE COS AND SIN (C AND S) ARE REAL
      AND THE VECTORS CX AND CY ARE COMPLEX*16. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1),CY(1),CTEMP 
 </PRE>
<A NAME="CDSCAL">
 <H3>CDSCAL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  CDSCAL(N,CA,CX,INCX) 
  
      SCALES A VECTOR BY A CONSTANT. 
      JACK DONGARRA, LINPACK,  3/11/78. 
  
       COMPLEX*16 CA,CX(1) 
 </PRE>
<A NAME="CDSSCAL">
 <H3>CDSSCAL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  CDSSCAL(N,SA,CX,INCX) 
  
      SCALES A COMPLEX VECTOR BY A REAL CONSTANT. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1) 
 </PRE>
<A NAME="CDSVDC">
 <H3>CDSVDC</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cdsvdc.for"> /usr/local/gifa/source/cdsvdc.for </A> 
 <PRE>       SUBROUTINE CDSVDC(X,LDX,N,P,S,E,U,LDU,V,LDV,WORK,JOB,INFO) 
 </PRE>
<A NAME="CDSWAP">
 <H3>CDSWAP</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  CDSWAP (N,CX,INCX,CY,INCY) 
  
      INTERCHANGES TWO VECTORS. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1),CY(1),CTEMP 
 </PRE>
<A NAME="CHECK_AMB">
 <H3>CHECK_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void CHECK_AMB(int *ipk_no, int *check)
 /*
 	cheak if the amoeba of a given peak is defined 
      number *ipk_no 
         *check = 0; not belongs
         *check = 1; belongs
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="CHECK_PIX_AMB">
 <H3>CHECK_PIX_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void CHECK_PIX_AMB(int *ipk_no,int *ipixx,int *ipixy,int *check)
 /*
 	cheak if the given pixel (*ipixx,*ipixy) belongs to a given peak 
      number *ipk_no 
         *check = 0; not belongs
         *check = 1; belongs
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="CH_AC1DAREA">
 <H3>CH_AC1DAREA</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_AC1DAREA(float	*parea, DATASET	**ppdata, int  *plow, int  *pup, int *mode, int  *perror)
 /*
 	access a portion of a 1D, a sector with coordinates
 	*plow,  *pup  "1 based" ;
 	*mode can be	CB_READ : copy from dataset to parea
 			CB_WRITE : copy from parea to dataset
 			CB_LOOK : copy a 8bit coded version of dataset to parea
 */
 </PRE>
<A NAME="CH_AC2DAREA">
 <H3>CH_AC2DAREA</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_AC2DAREA(float	*parea, DATASET	**ppdata, int  *plf1, int  *plf2, int  *pur1,  int  *pur2, int *mode, int  *perror)
 
 /*
 	access a portion of a 2D, a rectangle with coordinates
 	*plf1, *plf2, *pur1, *pur2 (lowerleft, upperright  "1 based" ;
 	 	1 is for "dim1, vertical" )
 	parea is supposed to point to a buffer of size exactly (ur1-lf1+1)*(ur2-lf2+1)
 	*mode can be	CB_READ : copy from dataset to parea
 		       	CB_WRITE : copy from parea to dataset
 			CB_LOOK : copy a 8bit coded version of dataset to parea
 */
 </PRE>
<A NAME="CH_AC3DAREA">
 <H3>CH_AC3DAREA</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_AC3DAREA(float	*parea, DATASET	**ppdata, int  *plf1, int  *plf2, int  *plf3, int  *pur1,  int  *pur2, int  *pur3, int *mode, int  *perror)
 
 /*
 	access a portion of a 3D, a subcube with coordinates
 	*plf1, *plf2, *plf2, *pur1, *pur2, *pur3 (lowerleft, upperright  "1 based" )
 
 	parea is supposed to point to a buffer of size exactly (ur1-lf1+1)*(ur2-lf2+1)*(ur3-lf3+1)
 	*mode can be	CB_READ : copy from dataset to parea
 			CB_WRITE : copy from parea to dataset
 			CB_LOOK : copy a 8bit coded version of dataset to parea
 */
 </PRE>
<A NAME="CH_CLOSE">
 <H3>CH_CLOSE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_CLOSE(DATASET **ppid, int  *perror)
 
 
 /*	closes an opened cache file
 	flushes and forgets all blocks that need to
 	double pointers because of FORTRAN
 */
 </PRE>
<A NAME="CH_CREATE">
 <H3>CH_CREATE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_CREATE(DATASET **ppid,char *path, int *plen,int *mode,int *perror)
 /*
 		DATASET **ppid,	 returned id 
 		char *path,		 the name of the file to open 
 		int  *plen,		 length of path 
 		int  *mode, 	 CF_WRITE only
 		int  *perror)	 returned status
 
 	creates a new file and put it into the cache,
 	creates the header
 	returns error status
 
 jan 2002 MAD - correction to close opened file if error during set-up
 
 */
 </PRE>
<A NAME="CH_DUMP">
 <H3>CH_DUMP</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_DUMP()
 /*
 	dumps the contents of the cache, used for debugging
 */
 </PRE>
<A NAME="CH_FLUSH">
 <H3>CH_FLUSH</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_FLUSH(DATASET **ppdata, int	*perror)
 /*
 	flushes all the blocks from a given dataset
 */
 </PRE>
<A NAME="CH_FLUSHALL">
 <H3>CH_FLUSHALL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_FLUSHALL(int *perror)
 /*
 	flushes all the blocks in the cache
 */
 </PRE>
<A NAME="CH_GTPARAM">
 <H3>CH_GTPARAM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_GTPARAM(DATASET **pdt,char *val, int *vlen,  char *param, int *plen, int *status)
 /*	find the value (string) of "param" into "dt->phead"
 	entries are of the form :
 	param       = value \n
 	can be called from fortran
 */
 </PRE>
<A NAME="CH_GTPARAM_TYPE">
 <H3>CH_GTPARAM_TYPE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_GTPARAM_TYPE(DATASET **pdt,void *val, char *param, int *len, int  *h_type, int  *status)
 
 /*	find the value of "param" into "dt->header"
 	with type "h_type"
 	Types can be : H_INT H_FLOAT H_DOUBLE
 	can be called from fortran
 */
 </PRE>
<A NAME="CH_INITIALISE">
 <H3>CH_INITIALISE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_INITIALISE()
 
 /*
   initialises all the data structures associated to the cache
   should be called once before using the library
 */
 
 </PRE>
<A NAME="CH_JOIN">
 <H3>CH_JOIN</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_JOIN(	DATASET **ppid,char *path,int  *plen,int  *mode,int  *perror)
 
 /* 
 	given a file name (char *path,int  *plen)
         returns the internal descriptor (DATASET **ppid) for this file,
 	if the file has already been opened with CH_OPEN (or CH_CREATE)
 	
 	error if not already opened, or if wrong mode
 
 	mode is :
 	CF_READ         access to file in read_only in the file system
 	CF_WRITE        for creating a new file - used only by CH_CREATE -
 	CF_READ_WRITE   for normal access (JOIN)
 
     error conditions if joining a file already opened with another mode
     in which case, one should close and reopen
 
 		acc :	R	W	RW
 	prev:	R	=	x	x		= Ok	x impossible
 		W	x	=	x
 		RW	=	=	=
 		
 */
 </PRE>
<A NAME="CH_OPEN">
 <H3>CH_OPEN</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_OPEN(DATASET **ppid,char *path,	int  *plen,int  *mode,int  *error)
 /*
 				DATASET **ppid,	 returned id 
 				char *path,		 the name of the file to open 
 				int  *plen,		 length of path 
 				int  *mode, 	 CF_READ, CF_WRITE, CF_READ_WRITE
 				int  *error)	 returned status
 
 	opens a file into the cache,
 	loads the header
 	returns error status
 
 jan 2002 MAD - correction to close opened file if error during set-up
 
 */
 </PRE>
<A NAME="CH_PRINTFILES">
 <H3>CH_PRINTFILES</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_PRINTFILES()
 /*
 print all the currently joined file
 */
 </PRE>
<A NAME="CH_PUTPARAM">
 <H3>CH_PUTPARAM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_PUTPARAM(DATASET **pdt, char *val, int *vlen, char *param, int *plen, int *status)
 /*
 	insert a parameter named "param" into dt->phead,
 	will be of the form : param      = val\n
 
 	can be called from fortran
 */
 </PRE>
<A NAME="CH_PUTPARAM_TYPE">
 <H3>CH_PUTPARAM_TYPE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_PUTPARAM_TYPE(DATASET **pdt,void *val,char *param, int *len, int *h_type, int *status)
 /* put the typed value of param into header of *pdt
 	can be called from fortran
 */
 </PRE>
<A NAME="CH_SETUP">
 <H3>CH_SETUP</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void CH_SETUP(DATASET **ppid, int *dim, int *si1, int *si2, int *si3,int  *perror)
 /*
 	used to set-up a file the very first time (dimension and sizes).
 	These parameters should not be changed with c_putparam
 	- typically called after CH_CREATE -
 */
 </PRE>
<A NAME="CLOSE_3DBOX">
 <H3>CLOSE_3DBOX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void CLOSE_3DBOX()
 </PRE>
<A NAME="CLOSE_BOX">
 <H3>CLOSE_BOX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void CLOSE_BOX(str_pt,str_lg,error)
 char str_pt[MAX_CHAR];
 int *str_lg;
 int *error;
 </PRE>
<A NAME="CLOSE_RAW">
 <H3>CLOSE_RAW</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/raw_access.c"> /usr/local/gifa/source/raw_access.c </A> 
 <PRE> void CLOSE_RAW(int *error)
 
 </PRE>
<A NAME="CREATEFREEZE">
 <H3>CREATEFREEZE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void CREATEFREEZE(flag)
 int *flag;
 </PRE>
<A NAME="CREATE_3DBOX">
 <H3>CREATE_3DBOX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void CREATE_3DBOX(vd_id)
 int *vd_id;
 /*
 	Creation de la boite 3D
 	et des differents boutons:
 		shift
 		scale...
 */
 </PRE>
<A NAME="CREATE_CHAMPS">
 <H3>CREATE_CHAMPS</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void CREATE_CHAMPS(str_pt,label_f,lg_label,var_f,lg_var,type_var,lg_type_var,list_var,lg_list_var,default_value_f,lg_default_value,max_var_f,lg_max_var,dec_pt_f,lg_dec_pt,error)
 int *lg_label,*lg_type_var,*lg_var,*lg_list_var,*error,*lg_default_value,*lg_max_var,*lg_dec_pt;
 char var_f[];
 char label_f[];
 char type_var[];
 char list_var[];
 char default_value_f[];
 char max_var_f[];
 char dec_pt_f[];
 int *str_pt;
 /*-------------------------------------------------------------
 *       void CREATE_CHAMPS(str_w_parent,label_f,lg_label,var_f,lg_var,
 *                       type_var,lg_type_var,list_var,lg_list_var,
 *                       default_value_f,lg_default_val,error)
 *
 *       IN: str_w_parent,label_f,lg_label,var_f,lg_var,type_var,lg_type_var,
 *               list_var,lg_list_var,default_value_f,lg_default_val,
 *		max_var,lg_max_var
 *       INOUT: error
 *
 *       Cette fonction est appelee pour chacun des champs crees dans
 *       le formulaire. Les champs crees dependent de type_var.
 *       var:
 *               int *lg_label,*lg_type_var,*lg_var,*lg_list_var,*lg_default_value;
 *                       longueur des chaine de char
 *                       ( non utilises si appel du C)
 *               int *error;     si pb error != 0
 *               char var_f[];   nom de la variable ou command (Type Action)
 *               char label_f[]; label du champ
 *               char default_value_f[]; valeur par defaut
 *               char type_var[];type de champ:
 *                               file:   TextField avec SelectionBox
 *                               string: TextField de saisie de string
 *                               int:    TextField de saisie de int
 *                               real:   TextField de saisie de real
 *                               enum:   PullDown menu
 *				multienum: PullDown menu multi select
 *				text:	text view
 *                               message:affichage de texte
 *
 *               char list_var[];liste des valeurs d'un PullDown menu
 *               Form_data *str_w_parent;pt sur struct du  cadre du formulaire
 *		max_var[],lg_max_var: max pour le cursor (le min est passe dans
 *							list_var)
 *
 *
 */
 </PRE>
<A NAME="CREATE_PHASEBOX">
 <H3>CREATE_PHASEBOX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void CREATE_PHASEBOX(spectrum,vd_id,ph0,ph1,size)
 /*
 c IN    : vd_id,size
 c INOUT : spectrum,
 c OUT   : ph0,ph1
 C    This subroutine allows an interactive phasage of a 1D spectrum.
 C   The informations returned are: zero and first order phase
 C   that have been applied, ph0 and ph1 respectively. These can then
 C   be applied directly with 'phase'.
 C   spectrum: 1D spectrum to phase
 C   vd_id: window in which the new phased spectra is drawn
 C   ph0: zero order phase that has been applied ;
 C        it can then be used in the 'phase' program
 C   ph1: first order phase that has been applied ;
 C        it can then be used in the 'phase' program
 */
 int *vd_id,size;
 float *spectrum,*ph0,*ph1;
 </PRE>
<A NAME="CREATE_ZOOMBOX">
 <H3>CREATE_ZOOMBOX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void CREATE_ZOOMBOX()
 /*
 	Creation de la boite de zoom
 	et des differents boutons:
 		zoom
 		shift
 		scale...
 */
 </PRE>
<A NAME="CREAT_AMB">
 <H3>CREAT_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void CREAT_AMB(int *error)
 
    create the beginning and the end of the chained list of amoeba
  
 </PRE>
<A NAME="CREAT_FORMULAIRE">
 <H3>CREAT_FORMULAIRE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void CREAT_FORMULAIRE(label_titre_f,lg,call_back_f,lg_CB,pt_struct,mask)
 int *lg,*lg_CB;
 int *pt_struct;
 char label_titre_f[];
 char call_back_f[];
 unsigned *mask;
 /*-------------------------------------------------------------
 *       IN: label_titre_f,call_back_f,lg_CB,mask
 *       OUT:pt_struct
 *
 *       Cette fonction cree le cadre global du formulaire
 *       var:
 *               int *lg,*lg_CB;         longueur des chaines de char
 *                                       label_titre_f et call_back_f.
 *                                       (non utilises si appel du C)
 *               Widget  *id;            id du widget formulaire
 *               pt_struct;              pt sur struct Form_data
 *               char label_titre_f[];   titre du formulaire
 *               char call_back_f[];     callback general associe au
 *                                       formulaire.
 *                                       (non utilise si le formulaire
 *                                        est bloquant)
 *               unsigned *mask;
 *                       APPLY_MASK 01   : bouton Apply
 *                       CANCEL_MASK 02  : bouton cancel
 *                       OK_MASK 04      : bouton ok
 *                       HELP_MASK 08    : bouton help (pas de callback associe)
 *                       BLOQ_MASK 16    : form bloquant
 *                       NORMVAR_MASK 32 : variables non gifa
 *                       ORIGC_MASK 64   : appel du C
 *
 *       remarque:
 *        Pour un formulaire bloquant et utilisant les variables gifa generales,
 *        le contexte est automatiquement le contexte courant
 *
 */
 </PRE>
<A NAME="CREAT_TITRE">
 <H3>CREAT_TITRE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void CREAT_TITRE(label_titre_f,lg,id)
 int *lg;
 Widget  *id;
 char label_titre_f[];
 /*      Creation et organisation des buttons    */
 </PRE>
<A NAME="CWAITASEC">
 <H3>CWAITASEC</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void CWAITASEC(sec)
 float *sec;
 
 /* cwaitasec(sec) will wait take the process to sleep for a time
 sec (in second) Called from fortran -waitasec-
 */
 
 </PRE>
<A NAME="Close_CB">
 <H3>Close_CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_biblidialog.c"> /usr/local/gifa/source/X_biblidialog.c </A> 
 <PRE> void Close_CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="Creat_shell_comm">
 <H3>Creat_shell_comm</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> Widget Creat_shell_comm(label_titre,b_titre)
 String label_titre;
 Widget b_titre;
 /*
 	 Creation du Row commandes shell
 */
 </PRE>
<A NAME="DBMCLOSE">
 <H3>DBMCLOSE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMCLOSE(ist)
 
 int *ist;
 /* to close a DBM file */
 
 </PRE>
<A NAME="DBMFETCH">
 <H3>DBMFETCH</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMFETCH(ist,key,value,len_key,len_val,error)
 
 int *ist,*len_key,*error,*len_val;
 char key[SIZE_BUFFER],value[SIZE_BUFFER];
 /* to fetch a element value from a DBM file  */
 
 </PRE>
<A NAME="DBMFRST">
 <H3>DBMFRST</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMFRST(ist,first_key,len_first_key,error)
 
 int *error,*ist,*len_first_key;
 char first_key[SIZE_BUFFER];
 /* to find the first key in a DBM file  */
 
 </PRE>
<A NAME="DBMNXT">
 <H3>DBMNXT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMNXT(ist,next_key,len_next_key,error,error_end)
 
 int *error,*ist,*len_next_key,*error_end;
 char next_key[SIZE_BUFFER];
 /* to find the next key in a DBM file  */
 
 </PRE>
<A NAME="DBMOPEN">
 <H3>DBMOPEN</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMOPEN(name,len_db,ist,error)
 
 int *error,*len_db,*ist;
 char name[SIZE_BUFFER];
 /* to open a DBM file  */
 
 </PRE>
<A NAME="DBMREM">
 <H3>DBMREM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMREM(ist,key,len_key,error)
 
 int *error,*ist,*len_key;
 char key[SIZE_BUFFER];
 /* to delete a element in a DBM file  */
 
 </PRE>
<A NAME="DBMSTORE">
 <H3>DBMSTORE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbtools.c"> /usr/local/gifa/source/dbtools.c </A> 
 <PRE> void DBMSTORE(ist,key,len_key,value,len_val,error)
 
 int *error,*ist,*len_key,*len_val;
 char key[SIZE_BUFFER],value[SIZE_BUFFER];
 /* to store a element (key,value) in a DBM file  */
 
 </PRE>
<A NAME="DCASUM">
 <H3>DCASUM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       FUNCTION DCASUM(N,CX,INCX) 
  
      TAKES THE SUM OF THE ABSOLUTE VALUES OF A COMPLEX VECTOR AND 
      RETURNS A REAL*8  RESULT. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1) 
 </PRE>
<A NAME="DEL_AMB">
 <H3>DEL_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void DEL_AMB(int *ipk_no)
 /*
 	delete the amoeba of peak *ipk_no
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="DPROOTB">
 <H3>DPROOTB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dprootb.for"> /usr/local/gifa/source/dprootb.for </A> 
 <PRE>       SUBROUTINE DPROOTB (MM,A,ZN,KERR,KPRINT)
  IN	: MM,A,KPRINT
  OUT	: KERR,ZN
      MM DEGREE OF POLYNOMIAL
      A=COEFFICIENT ARRAY, LOWEST TO HIGHEST DEGREE
      KPRINT=1 FOR FULL PRINTING
      KERR=0 IS NORMAL RETURN
 </PRE>
<A NAME="DROTG">
 <H3>DROTG</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE DROTG(DA,DB,C,S) 
  
      CONSTRUCT GIVENS PLANE ROTATION. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
 </PRE>
<A NAME="DialogAcceptCB">
 <H3>DialogAcceptCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void DialogAcceptCB(w,orig_tf,call_data)
 Widget w;
 Widget orig_tf;
 XtPointer call_data;
 /*-------------------------------------------------------------
 *     DialogAcceptCB
 *               copie le nom du fichier choisi dans le textfield
 *               appeleur et efface la widget de selection de fichier
 */
 </PRE>
<A NAME="DialogCancelCB">
 <H3>DialogCancelCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void DialogCancelCB(w,select_box,call_data)
 Widget w;
 Widget select_box;
 XtPointer call_data;
 /*-------------------------------------------------------------
 *     DialogCancelCB
 *               efface la widget de selection de fichier
 */
 </PRE>
<A NAME="FACTORF">
 <H3>FACTORF</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/factorf.for"> /usr/local/gifa/source/factorf.for </A> 
 <PRE>       SUBROUTINE FACTORF (B,K4,ZN,KPRINT,error)
  IN	: B,K4,KPRINT
  OUT	: ZN,error
      CALCULATE THE PE COEFFICIENTS FROM THE AR FORWARD COEFF.
      SETS UP PROBLEM, CALLS DPROOTB
      FACTORS COMPLEX POLYNOMIAL
      SIGMA COEFF(I)*Z**(I-1),I=1,K4)
      THE COEFFICIENTS ARE IN ASCENDING ORDER, ARE NOT NORMALIZED
      SIGNAL LENGTH <= 1024
      error : = 1 si toutes les racines n'ont pas ete localisees ; = 0 sinon
 
   EDIT HISTORY:
 
      WRITTEN BY STEIGLITZ, MODIFIED BY FENG NI, 9-30-84
      IMPLEMENTED ON PRIME 550, HASP BY FENG NI, 9-29-84
      ADAPTED TO VAX/8600, SU/NMR, BY FENG NI, 3-18-86
      adapted to GIFA  by T.Malliavin, March 1991
 
 </PRE>
<A NAME="F_MSG_OK">
 <H3>F_MSG_OK</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_biblidialog.c"> /usr/local/gifa/source/X_biblidialog.c </A> 
 <PRE> void F_MSG_OK(label,llabel,text,ltext,err)
 char *label,*text;
 int  *llabel,*ltext,*err;
 </PRE>
<A NAME="F_SAISIE">
 <H3>F_SAISIE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_biblidialog.c"> /usr/local/gifa/source/X_biblidialog.c </A> 
 <PRE> void F_SAISIE(label,llabel,text,ltext,st,lst,err)
 char *label,*text,*st;
 int  *llabel,*ltext,*lst,*err;
 </PRE>
<A NAME="GET_AMB">
 <H3>GET_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void GET_AMB(int *ipk_no, int *liste, int *nbpixel)
 /*
 	get the information corrresponding to the amoeba of peak *ipk_no
         *ipkx,*ipky: peak coordinates
         *total: number of pixels in amoeba
         *sum: integral
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="GET_LICENCE">
 <H3>GET_LICENCE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/get_licence.c"> /usr/local/gifa/source/get_licence.c </A> 
 <PRE> void GET_LICENCE(lic,ilic)
 char lic[MAX_CHAR];
 int  *ilic;
 
 </PRE>
<A NAME="GIFAFLUSH">
 <H3>GIFAFLUSH</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void GIFAFLUSH(unit)
 
 FILE    **unit;
 
 </PRE>
<A NAME="GIFAPRINT">
 <H3>GIFAPRINT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void GIFAPRINT(st,l)
 
 char *st;
 int  *l;
 
 </PRE>
<A NAME="GIFA_EXIT">
 <H3>GIFA_EXIT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void GIFA_EXIT(code)
 
 int *code;
 </PRE>
<A NAME="ICDAMAX">
 <H3>ICDAMAX</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       FUNCTION ICDAMAX(N,CX,INCX) 
  
      FINDS THE INDEX OF ELEMENT HAVING MAX. ABSOLUTE VALUE. 
      JACK DONGARRA, LINPACK, 3/11/78. 
  
       COMPLEX*16 CX(1) 
 </PRE>
<A NAME="INITINPROG">
 <H3>INITINPROG</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void INITINPROG(n)
 
 int *n;
 /*
   initialises for INPROG
 */
 
 </PRE>
<A NAME="INI_AMB">
 <H3>INI_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void INI_AMB(int *ipk_no, int *ipkx, int *ipky, int *error)
 /*
 	initialize the amoeba of peak *ipk_no
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *amoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="INPROG">
 <H3>INPROG</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void INPROG(i)
 int *i;
 
 /*
 set of command to show the progress of a long run.
 M.A.Delsuc
 
 
  will write :
 in progress 0%....25%....50%....75%....100%
  
  one dot each 1/20th of the run
 
 initialisation : initinprog(n)
 where   int *n   is the total numer of count to go
 
 run :            inprog(i)
 where   int *i   is the current index.
 
 inprog(i) can be called as you wish :
      very sparsely or very often, it does not matter.
 */
 </PRE>
<A NAME="LLEVY">
 <H3>LLEVY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/levy.c"> /usr/local/gifa/source/levy.c </A> 
 <PRE> void LLEVY(nin,lin,npar,lpar,data1d,data2d,si1,si2,itype,specw1,specw2,dim,error)
 
 char *nin,*npar;
 float *data1d, *data2d, *specw1, *specw2;
 int *lin, *lpar, *si1, *si2, *itype, *dim, *error;
 </PRE>
<A NAME="LVARIAN">
 <H3>LVARIAN</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lvarian.c"> /usr/local/gifa/source/lvarian.c </A> 
 <PRE> void LVARIAN(column,image,si1im,si2im,name,len,dim,itype,error)
 
 float *column,*image;
 int   *si1im,*si2im,*len,*dim,*itype,*error;
 char  *name;
 
 </PRE>
<A NAME="Load_file">
 <H3>Load_file</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> int Load_file(fname,txtf)
 char *fname;
 Widget txtf;
 /***************************************
 *	Load_file
 *	Load a file fname on a text field txtf
 *
 */
 </PRE>
<A NAME="MAKE_SEPARATEUR">
 <H3>MAKE_SEPARATEUR</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void MAKE_SEPARATEUR(w_parent,error)
 Widget *w_parent;
 int *error;
 /*      Creation d'un separateur     */
 </PRE>
<A NAME="MAKE_SEPARATEUR_FORM">
 <H3>MAKE_SEPARATEUR_FORM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void MAKE_SEPARATEUR_FORM(str_pt,error)
 /*
 Widget *w_parent;
 */
 int *str_pt;
 int *error;
 /*-------------------------------------------------------------
 *       void MAKE_SEPARATEUR_FORM(str_w_parent,error)
 *
 *       IN: str_w_parent
 *       INOUT: error;
 *
 *       Creation d'un separateur entre les champ du formulaire
 *       var:
 *               Widget *w_parent; pt sur id du cadre general du formulaire
 *               Form_data *str_w_parent; pt sur struct form_data general
 *               int *error; si pb -> error != 0
 *
 */
 </PRE>
<A NAME="MONOPOINT">
 <H3>MONOPOINT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void MONOPOINT()
 </PRE>
<A NAME="MOTIF_INIT">
 <H3>MOTIF_INIT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> int MOTIF_INIT() 
 /*
 	Initialisation de la partie Motif
 	test de display
 	callback sur stdin
 	Toplevel,dimension ecran........
 */
 	
 </PRE>
<A NAME="MOTIF_LOOP">
 <H3>MOTIF_LOOP</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void MOTIF_LOOP()
 /*
 	lance la XtAppMainLoop
 */
 </PRE>
<A NAME="MultiSelectCB">
 <H3>MultiSelectCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void  MultiSelectCB(w,str_var,call_data)
     Widget w;
     MultiEnumStruct *str_var;
     XmListCallbackStruct *call_data;
 </PRE>
<A NAME="OFF_cadre_zoom">
 <H3>OFF_cadre_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void OFF_cadre_zoom(vd_id)
 int       *vd_id;
 /*
 	efface le cadre du zoom de la fenetre
 */
 </PRE>
<A NAME="OPEN_RAW">
 <H3>OPEN_RAW</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/raw_access.c"> /usr/local/gifa/source/raw_access.c </A> 
 <PRE> void OPEN_RAW(char *name, int *len, int *error)
 
 </PRE>
<A NAME="PDvarCB">
 <H3>PDvarCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void PDvarCB(w,str_var,call_data)
 Widget w;
 PulldownStruct *str_var;
 XtPointer call_data;
 /*-------------------------------------------------------------
 *       PDvarCB
 *               mise a jour des variables a partir des valeurs
 *               choisies dans le Pulldown
 */
 </PRE>
<A NAME="PIPE_SYS">
 <H3>PIPE_SYS</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void PIPE_SYS(stout, lout, stin, lin, err)
 /*
    calls the system command held in stin(1..lin) through a pipe
    and returns the result in the stout(1..lout)  
 */
 
 char *stout,*stin;
 int *lout, *lin, *err;
 
 </PRE>
<A NAME="PUT_AMB">
 <H3>PUT_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void PUT_AMB(int *ipk_no, int *liste, int *nbpixel, int *error)
 /*
 	put a given list of pixels into the amoeba of peak *ipk_no
         *ipkx,*ipky: peak coordinates
         *total: number of pixels in amoeba
         *sum: integral
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
  */
 
 </PRE>
<A NAME="PUT_PIX_AMB">
 <H3>PUT_PIX_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void PUT_PIX_AMB(int *ipk_no,int *ipixx,int *ipixy,int *error)
 /*
 	put the given pixel (*ipixx,*ipixy) into the amoeba of the peak 
      ipk_no 
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="QuitCB_cdisp2">
 <H3>QuitCB_cdisp2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void QuitCB_cdisp2(w, vd_id, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       vd_id;    /*  data from application   */
 XtPointer       call_data ;
 
 </PRE>
<A NAME="QuitCB_disp1">
 <H3>QuitCB_disp1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void QuitCB_disp1(w, vd_id, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       vd_id;    /*  data from application   */
 XtPointer       call_data ;      
 
 </PRE>
<A NAME="QuitCB_disp2">
 <H3>QuitCB_disp2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void QuitCB_disp2(w, vd_id, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       vd_id;    /*  data from application   */
 XtPointer       call_data ;      
 
 </PRE>
<A NAME="QuitCB_disp3">
 <H3>QuitCB_disp3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void QuitCB_disp3(w, vd_id, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       vd_id;    /*  data from application   */
 XtPointer       call_data ;
 
 </PRE>
<A NAME="QuitCB_view">
 <H3>QuitCB_view</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void QuitCB_view(w, vd_id, call_data)
 Widget          w;              /*  widget id           */
 int             vd_id;    /*  data from application   */
 XtPointer       call_data ;
 
 </PRE>
<A NAME="RDLINE">
 <H3>RDLINE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void RDLINE(int *lp, char *inp)
 
 </PRE>
<A NAME="READ_RAW">
 <H3>READ_RAW</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/raw_access.c"> /usr/local/gifa/source/raw_access.c </A> 
 <PRE> void READ_RAW(float *column, int *size, int *offset, int *type, int *swab, int *error)
 </PRE>
<A NAME="REM_PIX_AMB">
 <H3>REM_PIX_AMB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/ambtools.c"> /usr/local/gifa/source/ambtools.c </A> 
 <PRE> void REM_PIX_AMB(int *ipk_no, int *ipixx, int *ipixy, int *error)
 /*
 	remove the pixel (*ipixx,*ipixy) from the amoeba of peak *ipk_no
 	*ipk_no,  peak number;
         tableau d'adresses des amibes *iamoeba (tableau statique Fortran)
         valeurs dx par rapport aux coord du pic des pixels de l'amibe 
      *pixelx (pointeur C)
         valeurs dy par rapport aux coord du pic des pixels de l'amibe
      *pixely (pointeur C)
 */
 
 </PRE>
<A NAME="REM_RL_HANDLER">
 <H3>REM_RL_HANDLER</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void REM_RL_HANDLER()
 /* this is needed because called from Fortran */
 </PRE>
<A NAME="Real_close">
 <H3>Real_close</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_util.c"> /usr/local/gifa/source/X_util.c </A> 
 <PRE> void Real_close(w)
 Widget          w;
 </PRE>
<A NAME="SAXPY">
 <H3>SAXPY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE SAXPY(N,SA,SX,INCX,SY,INCY)                            00000010
                                                                        00000020
      CONSTANT TIMES A VECTOR PLUS A VECTOR.                            00000030
      USES UNROLLED LOOP FOR INCREMENTS EQUAL TO ONE.                   00000040
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000050
                                                                        00000060
 </PRE>
<A NAME="SCOPY">
 <H3>SCOPY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  SCOPY(N,SX,INCX,SY,INCY)                              00000010
                                                                        00000020
      COPIES A VECTOR, X, TO A VECTOR, Y.                               00000030
      USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO 1.                    00000040
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000050
                                                                        00000060
 </PRE>
<A NAME="SETUP_VIEW">
 <H3>SETUP_VIEW</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void SETUP_VIEW(vd_id,type,zz1,zz2,zz3,zz4)
 int *vd_id, *type;
 float *zz1, *zz2, *zz3, *zz4;
 /* Defines zoom coordinates of the window
    used by OPEN_VIEW windows to compute viewfinder position.
    Value of the edges (zz1..zz4 are assumed to be in ppm
    zz1 = lower F1 zoom coordinate zz2 = lower F2 zoom coordinate,
    zz3 = upper F1 zoom coordinate zz4 = upper F2 zoom coordinate*/
 </PRE>
<A NAME="SET_AXIS">
 <H3>SET_AXIS</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void SET_AXIS(axes,vd_id)
 int *axes; /* 0=Off,1=f1, 2=f2, 3=f12*/
 int *vd_id;
 /*
 
 	calcule la position des ticks et affiche les axes
 	en f1, f2, f12, selon les choix
 int *axes; 	:0=Off,1=f1, 2=f2, 3=f12
 int *vd_id:	windows
 
 */
 </PRE>
<A NAME="SET_NB_ROWS">
 <H3>SET_NB_ROWS</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void SET_NB_ROWS(nbrowtitle)
 int *nbrowtitle;
 </PRE>
<A NAME="SET_PDMENU">
 <H3>SET_PDMENU</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void SET_PDMENU(pdmenu)
 int *pdmenu;
 </PRE>
<A NAME="SET_PROMPT">
 <H3>SET_PROMPT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void SET_PROMPT(pstring,lg)
 
 /*
    SET_PROMPT can be used to chane the prompt
    can be used also to reinstall the handler
 */
 
 int *lg;
 char pstring[];
 </PRE>
<A NAME="SGECO">
 <H3>SGECO</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/sgeco.for"> /usr/local/gifa/source/sgeco.for </A> 
 <PRE>       SUBROUTINE SGECO(A,LDA,N,IPVT,RCOND,Z)                            00000010
 </PRE>
<A NAME="SGEFA">
 <H3>SGEFA</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/sgeco.for"> /usr/local/gifa/source/sgeco.for </A> 
 <PRE>       SUBROUTINE SGEFA(A,LDA,N,IPVT,INFO)                               00000010
 </PRE>
<A NAME="SGESL">
 <H3>SGESL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/sgeco.for"> /usr/local/gifa/source/sgeco.for </A> 
 <PRE>       SUBROUTINE SGESL(A,LDA,N,IPVT,B,JOB)                              00000010
 </PRE>
<A NAME="SHOWPROMPT">
 <H3>SHOWPROMPT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void SHOWPROMPT(l)
 
 int  *l;
 
 </PRE>
<A NAME="SPERC">
 <H3>SPERC</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/facti3e.for"> /usr/local/gifa/source/facti3e.for </A> 
 <PRE> 	SUBROUTINE SPERC(COEF,ROOTR,ROOTI,NCOF)
 	sperc.for		Version 1 26/4/1990		Patrice Koehl
 
 	New program to solve a polynomial equation with real coefficient
 	( derived from Bj. Svejgaarg, Bit, 7 (1967), 240-246
 
 
 	Input :		- Coef	: coefficients of the equation (with coef(1)
 				  coef of x**0 and coef(n) coef of x**(m)
 			- N	: M+1, with M order of the polynomial
 	Output :	- Rootr	: real part of the solutions
 			- Rooti : imaginary part of the solutions
 
 	Beware : on output, roots are stored in positions 2 to N
 	of arrays Rootr and Rooti
 
 </PRE>
<A NAME="SROT">
 <H3>SROT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  SROT (N,SX,INCX,SY,INCY,C,S)                          00000010
                                                                        00000020
      APPLIES A PLANE ROTATION.                                         00000030
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000040
                                                                        00000050
 </PRE>
<A NAME="SROTG">
 <H3>SROTG</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE SROTG(SA,SB,C,S)                                       00000010
                                                                        00000020
      CONSTRUCT GIVENS PLANE ROTATION.                                  00000030
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000040
                                                                        00000050
 </PRE>
<A NAME="SSCAL">
 <H3>SSCAL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  SSCAL(N,SA,SX,INCX)                                   00000010
                                                                        00000020
      SCALES A VECTOR BY A CONSTANT.                                    00000030
      USES UNROLLED LOOPS FOR INCREMENT EQUAL TO 1.                     00000040
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000050
                                                                        00000060
 </PRE>
<A NAME="SSWAP">
 <H3>SSWAP</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/blas_lin.for"> /usr/local/gifa/source/blas_lin.for </A> 
 <PRE>       SUBROUTINE  SSWAP (N,SX,INCX,SY,INCY)                             00000010
                                                                        00000020
      INTERCHANGES TWO VECTORS.                                         00000030
      USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO 1.                    00000040
      JACK DONGARRA, LINPACK, 3/11/78.                                  00000050
                                                                        00000060
 </PRE>
<A NAME="SetAppIcon">
 <H3>SetAppIcon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void SetAppIcon(shell,orig)
 Widget shell;
 int orig;
 /*		orig = 1: logo general (else)
 		orig = 2: boite de zoom
 		orig = 3: disp 1d
 		orig = 4: disp 2d
 		orig = 5: disp 3d
 		orig = 6: phbox
 		orig = 7: 3dbox
 		orig = 8: freeze1d
 		orig = 9: freeze2d
 */
 </PRE>
<A NAME="TRACE_CADRE_ICON">
 <H3>TRACE_CADRE_ICON</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void TRACE_CADRE_ICON(aff)
 int *aff;
 </PRE>
<A NAME="UPDATE_LABEL_DIM">
 <H3>UPDATE_LABEL_DIM</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void UPDATE_LABEL_DIM(dim)
 int             *dim;
 /*
         met a jour le label dimension dans la boite de zoom
 */
 </PRE>
<A NAME="WAIT_CURSOR_IN_ALL_SHELL">
 <H3>WAIT_CURSOR_IN_ALL_SHELL</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void WAIT_CURSOR_IN_ALL_SHELL()
 /*
 	cursor montre (attente) dans
 	tout les shell de commandes
 	dans boite de zoom , window_mere,
 	et formulaire....
 */
 </PRE>
<A NAME="WIN_BGCOLOR">
 <H3>WIN_BGCOLOR</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_BGCOLOR( vd_id,color)
 int *vd_id,            /* Window ID to plot into. */
     *color;            /* color index 1..65 */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_bgcolor (vd_id,color)                                            C
 C                                                                        C
 C   sets the color for the next draw in the window                       C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       color = index in the color table                                 C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_CONFIG">
 <H3>WIN_CONFIG</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE>    void WIN_CONFIG(st)
   struct dsc$descriptor_s *st;
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCc
 C  subroutine win_config(st)
 C  Identifies Graphic Manager
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCc
 */
 </PRE>
<A NAME="WIN_ENABLE_DISPLAY_LIST">
 <H3>WIN_ENABLE_DISPLAY_LIST</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_ENABLE_DISPLAY_LIST(vd_id)
 int *vd_id;
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_enable_display_list(vd_id)                                       C
 C                                                                        C
 C     Enable keeping the display list (used after being disabled)        C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_FGCOLOR">
 <H3>WIN_FGCOLOR</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_FGCOLOR( vd_id,color)
 int *vd_id,            /* Window ID to plot into. */
     *color;            /* color index 1..65 */
     
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_fgcolor (vd_id,color)                                            C
 C                                                                        C
 C   sets the color for the next draw in the window                       C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       color = index in the color table                                 C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
  
 </PRE>
<A NAME="WIN_GET_BUTTONS">
 <H3>WIN_GET_BUTTONS</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int WIN_GET_BUTTONS(vd_id)
 int *vd_id;       /* Window ID to get pointer position in. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   status = win_get_buttons (vd_id)                                     C
 C                                                                        C
 C     Gets the current mouse button state.                               C
 C                                                                        C
 C       status = Address to return button state in                       C
 C                set to 0 if mouse buttons are up.                       C
 C                set to 1 if mouse button 1 is down.                     C
 C                set to 2 if mouse button 2 is down.                     C
 C                set to 3 if mouse button 3 is down.                     C
 C       vd_id =  window ID                                               C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_GET_POINTER_POSITION">
 <H3>WIN_GET_POINTER_POSITION</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int WIN_GET_POINTER_POSITION(vd_id,retx,rety)
 
 int *vd_id;        /* Window ID to get pointer position in. */
 float *retx,*rety;     /* Global return coords. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   status = win_get_pointer_position (vd_id, retx, rety)         C
 C                                                                        C
 C     Gets the current mouse position in world coordinates               C
 C                                                                        C
 C     Returns true/false if mouse is within the window                   C
 C       vd_id = Virtual display ID                                       C
 C       retx, rety = Address to return X,Y world coordinates             C
 C                                                                        C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_IMAGE_2D">
 <H3>WIN_IMAGE_2D</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_IMAGE_2D(vd_id,wd,ht,bitsperpixel,matrix)
 int *vd_id,          /* Window ID for image. */
      *wd,*ht,          /* Image width and height in units. */
      *bitsperpixel;   /* Number of bits per pixel. */
 char *matrix;     /* Natural matrix of dim wd x ht elements. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     win_image_2d (vd_id,                                               C
 C                wd,ht,bitsperpixel,                                     C
 C                matrix)                                                 C
 C                                                                        C
 C     Write a natural image bitmap into the specified virtual            C
 C     display rectangle.  If the size of the bitmap doesn't match        C
 C     the rectangle, scaling is done.                                    C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       wd = Width of image bitmap in pixels                             C
 C       ht = Height of image bitmap in pixels                            C
 C       bitsperpixel = Number of image bits which make up 1 "pixel"      C
 C       matrix = Address of natural image data                           C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_OPEN_GENE">
 <H3>WIN_OPEN_GENE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_OPEN_GENE(vd_id,cx,cy,vd_title,length, x,y, device)
 int *vd_id,        /* Window ID to return. */
     *length,       /* length of title. */
     *device;       /* type of window */
 float     *cx,*cy;       /* Width and Height of window in cm. */
 float     *x,*y;         /* position of window in cm, unused if both 0.0 unless device == 4 */
 char *vd_title;    /* Window title. */
 /*
      This subroutine opens a window for spectral display with the                
       dimensions cx and cy (in cm.) and with the specified title. 
 
      Vd_id is  assigned appropriately and passed back to the C
       calling procedure.                                                
 
       Device determines what is to be opened :
     	1 : Density 2D display
     	2 : Contour 2D window
     	3 : 3D display window
     	4 : View window
     	10 : 1D window (strange coding due to historical reasons
       */
 </PRE>
<A NAME="WIN_PLOT_1D">
 <H3>WIN_PLOT_1D</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_PLOT_1D( vd_id,x1,y1,x2,y2)
 int *vd_id;            /* Window ID to plot into. */
 float *x1,*y1,            /* Starting point of line in global coords. */
        *x2,*y2;            /* Ending point. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_plot_1d (vd_id,x1,y1,x2,y2)                                      C
 C                                                                        C
 C     Plot point or line(s)                                              C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       x1, y1 = x,y coordinates (floating) of start and end points.     C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_PLOT_ARRAY">
 <H3>WIN_PLOT_ARRAY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_PLOT_ARRAY(vd_id,count,xv,yv)
       int *vd_id,              /* Window ID for plotting. */
           *count;              /* Number of points to plot. */
       float    *xv,*yv; /* Array Data points in Global Coords. 0.0->1.0 */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_plot_array (vd_id,count,xv,yv)                                   C
 C                                                                        C
 C     Plot point or line(s)                                              C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       count = Number of points                                         C
 C       xv = Address of array of x coordinates (F floating)              C
 C       yv = Address of array of y coordinates (F floating)              C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_REFRESH">
 <H3>WIN_REFRESH</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_REFRESH()
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     WIN_REFRESH ()                                                     C
 C                                                                       C
 C     Redraws all of the mapped windows.                                 C
 C                                                                        C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_SET_POINTER_PATTERN">
 <H3>WIN_SET_POINTER_PATTERN</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_SET_POINTER_PATTERN( vd_id,pattern)
 int *vd_id,          /* Window ID in which to set pointer pattern. */
     *pattern;       /* Pattern #, 0 to reset, 1 for crosshair. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_set_pointer_pattern (vd_id,pattern)                        C
 C                                                                        C
 C     Setup a cursor pattern.                                            C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       pattern_no = number of the pattern                               C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_SET_WRITING_MODE">
 <H3>WIN_SET_WRITING_MODE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_SET_WRITING_MODE(vd_id,mode)
 int *vd_id,*mode;
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_set_writing_mode(vd_id,mode)                                     C
 C                                                                        C
 C     Sets the text and graphics writing mode.                           C
 C                                                                       C
 C       vd_id = Virtual display ID                                       C
 C       mode = Number of the mode                                        C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_SNAPSHOT">
 <H3>WIN_SNAPSHOT</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_SNAPSHOT(vd_id,filename) 
 int *vd_id;             /* Window ID to take snapshot of. */
 char filename[80];     /* Output file name and path. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     This subroutine produces a vms file of the specified window and    C
 C      puts the output into the file specified by filename.              C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_UPDATE">
 <H3>WIN_UPDATE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_UPDATE(vd_id)
 int *vd_id;   /* Window ID to update. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     win_update (vd_id)                                                 C
 C                                                                        C
 C     vd_id = Window ID to update                                        C
 C                                                                        C
 C     Recopies Pixmap(vd_id) into Window(vd_id)                          C
 C        and Flush the X requests      2eme                              C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WIN_WRITE">
 <H3>WIN_WRITE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void WIN_WRITE(vd_id,x,y,text,len)
 int *vd_id,*len;
 float *x,*y;
 char  text[256];
 /*
 
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   win_write(vd_id,x,y,text,len)                                        C
 C                                                                        C
 C     Write text(lenght) at position x,y.                                C
 C                                                                        C
 C       vd_id = Virtual display ID                                       C
 C       x,y  = coordinates where to write.                               C
 C       text = text to write                                             C
 C    note: the trailing blanks of the text are removed before writing.   C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="WLEVY">
 <H3>WLEVY</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/levy.c"> /usr/local/gifa/source/levy.c </A> 
 <PRE> void WLEVY(nin,lin,npar,lpar,data,si1,si2,itype,specw1,specw2,error)
 
 char *nin, *npar;
 float *data,*specw1,*specw2;
 int *lin, *lpar, *si1,*si2,*itype, *error;
 </PRE>
<A NAME="WUXNMR1D">
 <H3>WUXNMR1D</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/uxnmrio.for"> /usr/local/gifa/source/uxnmrio.for </A> 
 <PRE> 	subroutine WUXNMR1D(name,expno,procno,error)
  IN :  name,expno,procno
  OUT : error
 
  Write a UXNMR compatible 1d file
 
 </PRE>
<A NAME="ZOOMBOX_CLOSE">
 <H3>ZOOMBOX_CLOSE</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void ZOOMBOX_CLOSE()
 </PRE>
<A NAME="ZOOM_CATCHCB">
 <H3>ZOOM_CATCHCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void ZOOM_CATCHCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 /*
 catch a spectrum
 */
 </PRE>
<A NAME="Zoom_in">
 <H3>Zoom_in</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void Zoom_in(w)
 Widget          w;              /*  widget id           */
 </PRE>
<A NAME="Zoom_out">
 <H3>Zoom_out</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void Zoom_out(w)
 Widget          w;              /*  widget id           */
 /*
 	Zoom_out permet un recul dans le zoom
 	Il double la fenetre
 */
 </PRE>
<A NAME="_Xsetlocale">
 <H3>_Xsetlocale</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void _Xsetlocale()
 </PRE>
<A NAME="absvect">
 <H3>absvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine absvect(array1,array2,size)
  IN	: array2,size
  OUT	: array1
  
  ABSVECT(A,B,N) puts the absolute value of vector B into A.
 
 
 </PRE>
<A NAME="add_callback_point">
 <H3>add_callback_point</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void  add_callback_point(vd_id)
 int  *vd_id;
 /*
 	permet la mise en place des callback pour
 	la commande point
 */
 </PRE>
<A NAME="add_callback_zoom">
 <H3>add_callback_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void  add_callback_zoom(vd_id)
 int  *vd_id;
 /*
         permet l'initialisation des parametres de zoom pour les
         nouvelles fenetres crees.
 */
 </PRE>
<A NAME="add_shell_on_display">
 <H3>add_shell_on_display</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void add_shell_on_display(id_shell)
 Widget id_shell;
 </PRE>
<A NAME="addc1d">
 <H3>addc1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addc.for"> /usr/local/gifa/source/addc.for </A> 
 <PRE>       subroutine addc1d(idl,err)
  IN	: idl
  OUT	: err
  err=1 means no room for operation
  
  add the contents of the 1D buffer with the file pointed by idl 
 
  assume that most tests have been done by caller
 
 
 </PRE>
<A NAME="addc2d">
 <H3>addc2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addc.for"> /usr/local/gifa/source/addc.for </A> 
 <PRE>        subroutine addc2d(idl,err)
  IN	: idl
  OUT	: err
  err=1 means no room for operation
  
  add the contents of the 2D buffer with the file pointed by idl 
 
  assume that most tests have been done by caller
 
 
 </PRE>
<A NAME="addc3d">
 <H3>addc3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addc.for"> /usr/local/gifa/source/addc.for </A> 
 <PRE>        subroutine addc3d(idl,err)
  IN	: idl
  OUT	: err
  err=1 means no room for operation
  
  add the contents of the 3D buffer with the file pointed by idl 
 
  assume that most tests have been done by caller
 
 
 </PRE>
<A NAME="addh1d">
 <H3>addh1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addh.for"> /usr/local/gifa/source/addh.for </A> 
 <PRE>       subroutine addh1d(work,image,size,name,error)
  IN	: size,name
  OUT	: error
  INOUT	: image
  WORK	: work
  adds the contents of image(size) with the 1D file called 'name'
 
  work is a work area given by the caller. Should be at least size long
 
 </PRE>
<A NAME="addh2d">
 <H3>addh2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addh.for"> /usr/local/gifa/source/addh.for </A> 
 <PRE>       subroutine addh2d(work,image,si1,si2,name,error)
  IN	: si1,si2,name
  OUT	: work, error
  INOUT	: image
  adds the contents of image(si1,si2) with the 2D file called 'name'
  work is a work area given by the caller.
 
 </PRE>
<A NAME="addnoise">
 <H3>addnoise</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addnoise.for"> /usr/local/gifa/source/addnoise.for </A> 
 <PRE>       subroutine addnoise(tdata,size,noise,error)
  INOUT	: tdata
  IN	: size,noise
  OUT   : error
 
  add noise to the data
 
 </PRE>
<A NAME="addsimu1d">
 <H3>addsimu1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addsimu1d.for"> /usr/local/gifa/source/addsimu1d.for </A> 
 <PRE> 	subroutine addsimu1d (tdata,unit,error)
  IN	: unit
  INOUT	: tdata
  OUT	: error
 
  add to the current 1D data the line whose paramters are given by user.
  spectral width, frequence and data size are those currently defined
  (found in paramfilev.inc).
 
 
  input:
  sp1d: spectral width (paramfilev.inc)
  freq1d: frequency (paramfilev.inc)
  off1d: offset (paramfilev.inc)
  sizeimage1d: data size (paramfilev.inc)
  tdata(sizeimage1d): current data in the 1D buffer
  point unit: PPM, INDEX or HZ
 
  output:
  tdata(size): modified data in the 1D buffer
 
 </PRE>
<A NAME="addsimu2d">
 <H3>addsimu2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addsimu2d.for"> /usr/local/gifa/source/addsimu2d.for </A> 
 <PRE> 	subroutine addsimu2d (tdata,unit,error)
  IN	: unit
  INOUT	: tdata
  OUT	: error
 
  add to the current 2D data the line whose parameters are given by user.
  spectral width, frequence and data size are those currently defined
  (found in paramfilev.inc).
 
  input:
  specw1,specw2: spectral widthes (paramfilev.inc)
  freq1,freq2: frequencies (paramfilev.inc)
  offset1,offset2: offset (paramfilev.inc)
  sizeimage: data size (paramfilev.inc)
  tdata(sizeimage): current data in the 1D buffer
  point unit: PPM, INDEX or HZ
 
  output:
  tdata(size): modified data in the 1D buffer
 
 </PRE>
<A NAME="addsimu3d">
 <H3>addsimu3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/addsimu3d.for"> /usr/local/gifa/source/addsimu3d.for </A> 
 <PRE> 	subroutine addsimu3d (tdata,unit,error)
  IN	: unit
  INOUT	: tdata
  OUT	: error
 
  add to the current 3D data the line whose parameters are given by user.
  spectral width, frequence and data size are those currently defined
  (found in paramfilev.inc).
 
  input:
  sp3d1,sp3d2,sp3d3: spectral widthes (paramfilev.inc)
  freq3d1,freq3d2,freq3d3: frequencies (paramfilev.inc)
  of3d1,of3d2,of3d3: offset (paramfilev.inc)
  sizeimage3d: data size (paramfilev.inc)
  tdata(sizeimage3d): current data in the 1D buffer
  point unit: PPM, INDEX or HZ
 
  output:
  tdata(size): modified data in the 1D bufer
 
 </PRE>
<A NAME="addvect">
 <H3>addvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  addvect(arrayout,B,C,l,size)
  IN	: B,C,l,size
  OUT	: arrayout
  
  ADDVECT(A,B,C,L,N) multiply the vector C by the scalar l, add this vector
                     to B, and put the result into A
 
 </PRE>
<A NAME="adjust_cstring">
 <H3>adjust_cstring</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void adjust_cstring(st,l) 
 char *st;
 int l;
 </PRE>
<A NAME="adrvect">
 <H3>adrvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine adrvect(array,reel,size)
  IN	: reel,size
  INOUT	: array
 
  ADRVECT(A,L,N) add the scalar l to the content of vector A
  
 
 </PRE>
<A NAME="alloc_scale_var">
 <H3>alloc_scale_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void alloc_scale_var(str_sc)
 ScaleStruct *str_sc;    /*  data from application   */
 /*-------------------------------------------------------------
 **   alloc_scale_var
 *		alloc de la variable scale (cursor)
 */
 </PRE>
<A NAME="allocate">
 <H3>allocate</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine allocate(name,context,addr,err)
  IN	: name,context
  OUT	: addr,err
 
  allocate the variable called "name" in the internal table,
  with context "context"
 
  the table is held as a indexed hash table with rolling collision
 
  returns its address
  addr is 0 if not allocated
 
 **********Should not be used for normal use**************************
 </PRE>
<A NAME="alloue_variable">
 <H3>alloue_variable</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void alloue_variable(variable,string,context)
 char *variable; 
 char *string;
 int context;
 /*-------------------------------------------------------------
 *       void alloue_variable(variable,string,context)
 *
 *       IN: variable,string,context;
 *
 *       mise a jour de la variable
 *       var:
 *               char *variable; pt sur variable
 *               char *string; valeur de la variable
 *               int context; contexte de recherche
 */
 </PRE>
<A NAME="alpha_m10CB">
 <H3>alpha_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void alpha_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="alpha_m1CB">
 <H3>alpha_m1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void alpha_m1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="alpha_p10CB">
 <H3>alpha_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void alpha_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="alpha_p1CB">
 <H3>alpha_p1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void alpha_p1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="alphanum">
 <H3>alphanum</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       function alphanum(cc)
  IN	: cc
     true if "cc" is alpha numeral or _
 
 </PRE>
<A NAME="apply_segm">
 <H3>apply_segm</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segsec.for"> /usr/local/gifa/source/segsec.for </A> 
 <PRE>       subroutine apply_segm(size)
  part of BCORR 3
 
 </PRE>
<A NAME="approxim">
 <H3>approxim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/approx.for"> /usr/local/gifa/source/approx.for </A> 
 <PRE>       subroutine approxim(indice,debut,sizeb,size,
      *y10,y11,y12,y20,y21,y22)
 
  IN	: indice,debut,sizeb,size (??)
  OUT	: y10,y11,y12,y20,y21,y22 (??)
  computes the best polynomial approximation -
 
 </PRE>
<A NAME="arrondir">
 <H3>arrondir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void arrondir(val,retval,prec)
 float val;
 float *retval;
 int *prec;
 /*
 
 	arrondi la valeur absolue de 'val' a 10^n, 2*10^n, 5*10^n, le plus proche
 	retourne l'arrondi dans retval
 	retourne la precision (n) : prec
 
 float val	: valeur a arrondir
 float *retval	: valeur arrondie
 int *prec	: nbre de chiffre apres la virgule
 
 */
 </PRE>
<A NAME="arrow_rightCB">
 <H3>arrow_rightCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void arrow_rightCB(w,select_box,call_data)
 Widget w;
 Widget select_box;
 XtPointer call_data;
 /*-------------------------------------------------------------
 *      arrow_rightCB
 *               affiche la widget de selection de fichier
 */
 </PRE>
<A NAME="arrow_scale_lCB">
 <H3>arrow_scale_lCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void arrow_scale_lCB(w,str_sc, call_data)
 Widget          w;              /*  widget id           */
 ScaleStruct *str_sc;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="arrow_scale_rCB">
 <H3>arrow_scale_rCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void arrow_scale_rCB(w,str_sc, call_data)
 Widget          w;              /*  widget id           */
 ScaleStruct *str_sc;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="assert">
 <H3>assert</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/assert.for"> /usr/local/gifa/source/assert.for </A> 
 <PRE> 	subroutine assert (file, subr, test, line)
 
  IN	: file,subr,test,line
 
  Part of the ASSERT subsystem
  issue to the user a error msg, giving the name of the faulty code.
  and what to do it.
  to be used with the fpp program.
 
 </PRE>
<A NAME="assign">
 <H3>assign</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine assign(name,context,value,err)
  IN	: name,value,context
  OUT	: err
 
       assign a value to the variable called name, allocate if does
       not exist yet. Context is used for allocation and research.
       Variables in different context are independent.
       In GIFA, contexts are related to read unit, thus 20 to 29
       20 is held as a global context.
 
 </PRE>
<A NAME="autophase">
 <H3>autophase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/autophase.for"> /usr/local/gifa/source/autophase.for </A> 
 <PRE>       subroutine autophase(p01,p11,p02,p12,iter,miter,mode,verb)
  IN	: iter,miter,mode,verb
  OUT	: p01,p11,p02,p12
 
  computes the optimum phase corrections for the 2D current 2D data-set.
  use conjugate gradient method. 
  If mode .eq.0   order 0 only will be corrected, order 0 and 1 otherwise
  iter and miter : number of iterations
  if verb.eq.1 verbose output
 
 </PRE>
<A NAME="b10">
 <H3>b10</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readtc3d.for"> /usr/local/gifa/source/readtc3d.for </A> 
 <PRE>        subroutine b10(nb,n,err)
 
 </PRE>
<A NAME="backprod">
 <H3>backprod</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/backprod.for"> /usr/local/gifa/source/backprod.for </A> 
 <PRE>          subroutine backprod(v,u,si1,si2) 
 
  IN	: u,si1,si2
  OUT	: v
 
  computes V = U . transp(U)
  where U is (si2,si1), and V (si2,si2)
 
 </PRE>
<A NAME="backward">
 <H3>backward</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine backward (back,forw,size)
  IN	: for,size
  OUT	: back
 
  BACKWARD(A,B,N) calculate the backward coeff vector from forward 
 
 </PRE>
<A NAME="base10">
 <H3>base10</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readtc3d.for"> /usr/local/gifa/source/readtc3d.for </A> 
 <PRE>        subroutine base10(spec1,fact,sign1,espec1,csi1,err)
 </PRE>
<A NAME="base64">
 <H3>base64</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writetc3d.for"> /usr/local/gifa/source/writetc3d.for </A> 
 <PRE>        subroutine base64(ib,i)
      
 </PRE>
<A NAME="bcolor">
 <H3>bcolor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gcolor.for"> /usr/local/gifa/source/gcolor.for </A> 
 <PRE>       subroutine bcolor(vd_id,col_ind)
  IN	: vd_id,col_ind
 
  vd_id : id of the window
  col_ind : color index
  set the gc for the background color of the window
  1:white 2:red  3:orange 4:yellow
  5:green 6:cian 7:blue   8:purple  9:black
 
 
 </PRE>
<A NAME="bcrvect">
 <H3>bcrvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine bcrvect(array,size)
  IN	: size
  INOUT	: array
 
  BCRVECT(A,N) This subroutine will base line correct vector A, by removing
               any continuous contribution in A (i.e. removes the mean)
 
 </PRE>
<A NAME="beta_m10CB">
 <H3>beta_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void beta_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="beta_m1CB">
 <H3>beta_m1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void beta_m1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="beta_p10CB">
 <H3>beta_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void beta_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="beta_p1CB">
 <H3>beta_p1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void beta_p1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="borne1d">
 <H3>borne1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/borne1d.for"> /usr/local/gifa/source/borne1d.for </A> 
 <PRE>       subroutine borne1d(tablo,si,no,rap,monte,min,lim1,lim2,
      *     signpic,zq)
 
  IN	: tablo,si,no,rap,monte,min,signpic,zq (??)
  OUT	: lim1,lim2
  used by 1D INTEG
  returns the limits of peak no as defined in peak1d
  
 </PRE>
<A NAME="bornecol">
 <H3>bornecol</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/bornepic.for"> /usr/local/gifa/source/bornepic.for </A> 
 <PRE>       subroutine bornecol(tablo,si1,si2,no,rap,monte,min,
      *          lim1,lim2,signpic,zq)
 
  IN	: tablo,si1,si2,no,rap,monte,min,signpic,zq
  OUT 	: lim1,lim2
  used by 2D INTEG
  returns the limits along columns of peak no as defined in peak2d
 
 </PRE>
<A NAME="bornelig">
 <H3>bornelig</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/bornepic.for"> /usr/local/gifa/source/bornepic.for </A> 
 <PRE>       subroutine bornelig(tablo,si1,si2,no,rap,monte,min,
      *                    lim1,lim2,signpic,zq)
  IN	: tablo,si1,si2,no,rap,monte,min,signpic,zq
  OUT 	: lim1,lim2
  used by 2D INTEG
  returns the limits along lines of peak no as defined in peak2d
 
 </PRE>
<A NAME="boucle_event">
 <H3>boucle_event</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void boucle_event()
 /*-------------------------------------------------------------
 *       void boucle_event(str_form_data)
 *
 *       IN:str_form_data
 *       INOUT:
 *
 *       Mise en place d'une boucle locale d'evenements
 *       dans le cadre de formulaires bloquants
 *
 *       var:
 *               FORM_data str_form_data; Structure associee au
 *                                               formulaire
 */
 </PRE>
<A NAME="braket">
 <H3>braket</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/braket.for"> /usr/local/gifa/source/braket.for </A> 
 <PRE>        subroutine braket(ax,bx,cx,fa,fb,fc,func,verb)
  IN	: func,verb
  OUT	: ax,bx,cx,fa,fb,fc
   brakets the minimum value of function func with the three values ax,bx
   cx. fa,fb,fc are the values of func at ax,bx,cx
  verb.eq.1 is verbose mode
 
 </PRE>
<A NAME="brentmini">
 <H3>brentmini</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/brentmini.for"> /usr/local/gifa/source/brentmini.for </A> 
 <PRE>       subroutine brentmini(left,middle,right,func,tol,niter,
      *                     minimum,funcmini,verb	)
 
  IN	: left,middle,right,func,tol,niter,verb
  OUT	: minimum,funcmini	
     This  subroutine isolate the minimum of a 1D function, using the BRENT
  method
 
    On input:
 - left,middle,right is a triplet bracketing the minimum, such that
  left>middle>right and func(middle)<func(left) and func(middle)<func(right)
 
 - func is the function to minimize  y=func(x)  where x,y are real
 
 - tol is the tolerance to be obtain on the position of the minimum, should
  never be smaller than the machine epsilon. 1e-3 is typical
 
 - niter is the maximum number of iteration to achieve, the programme exit
  whenever one of the condition on tol or on niter is achieved, 20 is typical
  0 means nearly infinite
 
    On output:
 - minimum is the abscissa of the located minimum.
 - funcmini is the value of the function at minimum.
 
 </PRE>
<A NAME="bru2vect">
 <H3>bru2vect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  bru2vect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  
  BRU2VECT(A,B,N) copy real vector B of length N into A, changing the sign of
                 value with entries equal to 1 modulo 2.
 
 </PRE>
<A NAME="bruvect">
 <H3>bruvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  bruvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  BRUVECT(A,B,N) copy real vector B of length N into A, changing the sign of
                 value with entries equal to 2 and 3 modulo 4.
 
 </PRE>
<A NAME="bsort">
 <H3>bsort</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine bsort(x,size)
  INOUT	: x,size
 
  Performs a buble sort on a integer array of length size
  Removes duplicates (and changes size if so)
 
 </PRE>
<A NAME="burgc">
 <H3>burgc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/burg.for"> /usr/local/gifa/source/burg.for </A> 
 <PRE>       subroutine burgc (data,n,m,pow1,ar,wk1,wk2,error)
  IN	: data,n,m
  OUT	: pow,ar,error
  WORK	: wk1,wk2
  Burg method for finding AR coefficients.
  for complex data
  with :
  input:  data(n)   data to be evaluated
          m order of the AR
          wk1,wk2 work areas of n long
  output: ar(m) AR coeff.
          pow   power of the spectrum
 
 </PRE>
<A NAME="burgr">
 <H3>burgr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/burg.for"> /usr/local/gifa/source/burg.for </A> 
 <PRE>       subroutine burgr(data,n,m,pow,ar,wk1,wk2,wk3)
  IN	: data,n,m
  OUT	: pow,ar
  WORK	: wk1,wk2,wk3
  Burg method for finding AR coefficients.
  for real data
  with :
  input:  data(n)   data to be evaluated
          m order of the AR
          wk1,wk2,wk3 work areas of n long
  output: ar(m) AR coeff.
          pow   power of the spectrum
 </PRE>
<A NAME="burgspectrum">
 <H3>burgspectrum</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/burgspectrum.for"> /usr/local/gifa/source/burgspectrum.for </A> 
 <PRE> 	subroutine burgspectrum (data,siz,pow,ar,temp,work,order,specw2)
 
  IN	: siz,pow,ar,temp,work,order,specw2
  OUT	: data
  WORK	: temp,work
  data(siz) ar(order)
  computes pow/fft(ar)  and put it in data
 
 </PRE>
<A NAME="c_comp_update">
 <H3>c_comp_update</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> int c_comp_update(DATASET *pdata)
 /*
 Computes the size of the update for MAXDATA
 */
 </PRE>
<A NAME="c_creatblock">
 <H3>c_creatblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> BLOCK	*c_creatblock(DATASET *pdtset,int index,int mode,int *perror)
 /*
 	create a new block and insert it in hash and in LRU (as last entry),
 	typically called by c_getblock
 */
 </PRE>
<A NAME="c_getblock">
 <H3>c_getblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> BLOCK *c_getblock(DATASET *pdtset,int index,int mode,int *perror)
 /*
 	accesses the block from file "pdtset" at "index", with "mode" (CB_READ, CB_WRITE, CB_LOOK)
 
 	a pointer to the block is returned (NULL if error)
 	if mode is CB_LOOK or CB_READ or (CB_WRITE, but file access is CF_READ_WRITE) ,
             data are or retrieved in the
             currently set of blocks in memory
             or fetch from disk and put into the pool of blocks
             and then put at the end of LRU list
 	if mode is CB_WRITE  the block is set as dirty
 	if mode is CB_WRITE and file mode is CF_WRITE
            only allocation is done - no test on previous content	!!risky!!
 	if mode is CB_LOOK the data are transformed from float to unsigned char
 		in a logarithmic coding, thus compressing by a factor 4
 	if a block is accessed in CB_READ or CB_WRITE and already in memory in CB_LOOK, the old
           block is discarded and reloaded.
 
 	possible access modes depend on file mode : (see CH_JOIN):
 		= ok; x:impossible; 
 
 		file_mode	CF_R	CF_W	CF_RW
 	acces mode	CB_R	=	x	=
 			CB_W    x	=	=
 			CB_L	=	x	=
 
 	if x : close and reopen file with CF_RW mode
 
 */
 </PRE>
<A NAME="c_gtparam">
 <H3>c_gtparam</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_gtparam(char *header, char *val,char *param, int  *status)
 /*	find the value (string) of "param" into "dt->phead"
 	entries are of the form :
 	param       = value \n
 
 	local version of CH_GTPARAM
 */
 </PRE>
<A NAME="c_gtparam_type">
 <H3>c_gtparam_type</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_gtparam_type(char *header,void *val, char *param, int  h_type, int  *status)
 
 /*	find the value of "param" into "dt->header"
 	with type "h_type"
 	uses c_gtparam
 	
 	version local de CH_GTPARAM_TYPE
 */
 </PRE>
<A NAME="c_hash">
 <H3>c_hash</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> unsigned c_hash(DATASET *pdata, unsigned index)
 </PRE>
<A NAME="c_loadheader">
 <H3>c_loadheader</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_loadheader(int  fdes, char **ppheader,int *psize, int  *perror)
 /*
 reads in the header of the cache file fdes.
 allocates and return a block holding the header in its current state.
 will set an error if the file is invalid.
 The header block will then be accessed with ad-hoc functions
 */
 </PRE>
<A NAME="c_lookblock">
 <H3>c_lookblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_lookblock(BLOCK *ptb, float max0, int  *perror)
 /*
 looks to the block ptb
 */
 </PRE>
<A NAME="c_putparam">
 <H3>c_putparam</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_putparam(DATASET *dt,char *val,char *param, int *status)
 /*
 	insert a parameter named "param" into dt->phead,
 	will be of the form : param      = val\n
 
 	error if file mode is CF_READ
 
 	local version of CH_PUTPARAM
 */
 </PRE>
<A NAME="c_putparam_type">
 <H3>c_putparam_type</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_putparam_type(DATASET *dt,void *val,char *param, int  h_type, int *status)
 /* local version of CH_PUTPARAM_TYPE */
 </PRE>
<A NAME="c_readblock">
 <H3>c_readblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_readblock(BLOCK *ptb,int  *perror)
 /*
 reads the bloc ptb
 if dataset is big_endian and the machine is not (or dataset is not but machine is)
  then the data is byte swapped
 
 */
 </PRE>
<A NAME="c_remblock">
 <H3>c_remblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_remblock(BLOCK *pb, int *perror)
 /*
 	remove a block from memory
 */
 </PRE>
<A NAME="c_remdataset">
 <H3>c_remdataset</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_remdataset(DATASET *pdata, int *perror)
 /*
 	frees all the blocks from a given dataset
 	flushes them if needed
 */
 </PRE>
<A NAME="c_to_1d">
 <H3>c_to_1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine c_to_1d(axis,size,err)
  IN :	axis,size
  OUT : err
 
  copy the parameters of the cache file to the working 1D buffer
 
 </PRE>
<A NAME="c_to_2d">
 <H3>c_to_2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine c_to_2d(axis,si1,si2,err)
  IN :	axis
 
  copy the parameters of the cache file to the working 2D buffer
  axis is orthogonal to the 3D plane to copy
  i.e. axis=1 means F2-F3 plane
  thus axis=3 is for regular 2d
 </PRE>
<A NAME="c_to_3d">
 <H3>c_to_3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine c_to_3d(si1,si2,si3,error)
  copy the parameters of the cache file to the working 3D buffer
 </PRE>
<A NAME="c_unplug_hash">
 <H3>c_unplug_hash</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_unplug_hash(BLOCK *pb)
 
 /*
   unplug a block from hash
 */
 </PRE>
<A NAME="c_unplug_lru">
 <H3>c_unplug_lru</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_unplug_lru(BLOCK *pb)
 /*
   unplug a block from lru
 */
 </PRE>
<A NAME="c_writeblock">
 <H3>c_writeblock</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_writeblock(BLOCK *ptb,int  *perror)
 /*
 writes the block ptb
 */
 </PRE>
<A NAME="c_writeheader">
 <H3>c_writeheader</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void c_writeheader(DATASET *dt, int  *perror)
 /*	writes on file a dataset header */
 </PRE>
<A NAME="calcmask">
 <H3>calcmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine calcmask(nopk,tab,taille1,taille2,noise,shift,signpic)
 
  calculate the integral and the error from the mask of the peak nopk
 
  IN	: tab,nopk,taille1,taille2,noise,shift,signpic
  OUT	: amoeba
 
 </PRE>
<A NAME="calcsvd">
 <H3>calcsvd</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/calcsvd.for"> /usr/local/gifa/source/calcsvd.for </A> 
 <PRE>       subroutine calcsvd (x,svd,u,v,err,wk,sizdat,order,nd1,error)
  IN	: x,sizdat,order,nd1
  OUT	: u,v,svd,error
  WORK	: err,wk
 
  Calculate the singular decomposition of matrix x and remove noise
  from the singular values
  complex*16 x(nd1,order)
  complex*16 svd(order) singular values
  complex*16 u(nd1,nd1),v(order,order) transformation matrices
  err,wk : working areas
 
 </PRE>
<A NAME="calcule_tick">
 <H3>calcule_tick</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void calcule_tick(x1,x2,valtick,nbtick,prec,axe)
 float x1,x2; 		/* coord d'encadrement en unite courante */
 float valtick[]; 	/* tab avec valeurs de tick */
 int *nbtick; 		/* nb de tick desire, retourne le nbre reel de tick*/
 int *prec;
 int axe;                /* 1 ou 2 */
 /*
 
 	 Segmente une longueur (x2-x1) en un nombre defini (nbtick) de
 	batonnet. Les valeurs sont mises dans un tableau (valtick). 
 	Retourne la precision (prec) significative apres la virgule
 
 float x1,x2 ->coord d'encadrement en unite courante
 float valtick[] -> tab avec valeurs de tick
 int *nbtick; -> nb de tick desire, retourne le nbre reel de tick, -1 si erreur
 int *prec -> precision	
 	
 
 */
 </PRE>
<A NAME="cconvert_string">
 <H3>cconvert_string</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void cconvert_string(st2,st1,l)
 
 /*  ATTENTION   A REECRIRE */
 char st2[];
 struct dsc$descriptor_s *st1;
 int l;
 </PRE>
<A NAME="cdiavect">
 <H3>cdiavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cdiavect(a,b,c,size)
  IN	: b,c,size
  OUT	: a
 
  CDIAVECT(A,B,C,N) multiply the vector (complex*8) C by the diagonal matrix whose diagonal
                   is in vector (complex*8) B, and put the result into(complex*8)  A
 
  i.e. a(i) = b(i)*c(i)
 
 </PRE>
<A NAME="cdotvect">
 <H3>cdotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cdotvect(d,a,b,size)
  IN	: a,b,size
  OUT	: d
 
  CDOTVECT(D,A,B,N) performs the dot product of vectors A (complex) and
 		    B (complex) and put the result into D (complex)
 
 </PRE>
<A NAME="centre">
 <H3>centre</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lisse.for"> /usr/local/gifa/source/lisse.for </A> 
 <PRE>       subroutine centre(source,size)
  used by linecor2
 
 </PRE>
<A NAME="change_scaleCB">
 <H3>change_scaleCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void change_scaleCB(w, str_sc, call_data)
 Widget          w;              /*  widget id           */
 ScaleStruct *str_sc;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 /*-------------------------------------------------------------
 **     change_scaleCB
 */
 </PRE>
<A NAME="changedir">
 <H3>changedir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine changedir(st,err)
  OUT	: st,err
  This subroutine changes the current working directory
 </PRE>
<A NAME="chdir_">
 <H3>chdir_</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> int chdir_(path,lp)
 char *path;
 int  *lp;
 
 </PRE>
<A NAME="checkdim">
 <H3>checkdim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       function checkdim(axis,type,dim)
  IN	: axis,type,dim
 
  true if type describes a complex data-set
  in the axis st, with dimentionality dim
 
 </PRE>
<A NAME="checkoverflow">
 <H3>checkoverflow</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine checkoverflow(size,not_ok,fdata)
  IN	: size,fdata
  OUT	: not_ok
 
  check if, when using the upper memory, starting at size (counted from
  starting point of image), any buffer will be overflowed
  if fdata=1, datab will also be checked
  not_ok will be true if not Ok.
  If Ok, data will be clipped
  
 </PRE>
<A NAME="checkunderflow">
 <H3>checkunderflow</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine checkunderflow(size,not_ok)
  IN	: size
  OUT	: not_ok
 
  check if, when increasing the memory of the current data-set, up to size
  any buffer will be overflowed
  if fdata=1, datab will also be checked
  not_ok will be true if not Ok.
  If Ok, data will be clipped
 
  will be trigged only if data size is increasing!
 
 </PRE>
<A NAME="checkvar">
 <H3>checkvar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine checkvar(vname,context,err)
  IN	: vname,context
  INOUT : err
 
       check if the variable called name exists in "context", returns with err :
  err = 0 means found
  err = 1 means not found
 
 </PRE>
<A NAME="chivect">
 <H3>chivect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine chivect(chi,A,B,size)
  IN	: A,B,size
  OUT	: chi
 
  CHIVECT(C,A,B,N) C is the euclidian distance between vectors A and B
                   ( dot square product of (A-B) )
 
 </PRE>
<A NAME="chkborder">
 <H3>chkborder</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>        subroutine chkborder(lf1,lf2,ur1,ur2,it)
  IN	: it
  INOUT	: lf1,lf2,ur1,ur2
 
  this subroutine verify the border of a window on a 2D spectra,
  to be coherent with itype, i.e. begins on a real (odd) address, ends on
  imaginary (even) address (if complex in that direction)
 </PRE>
<A NAME="chkborder2d">
 <H3>chkborder2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine chkborder2d(lf1,ur1,axis,it)
  IN    : axis,it
  INOUT : lf1,ur1
  this subroutine verify the border of a window on a 2D spectra,
  to be coherent with itype, i.e. begins on a real (odd) address, end
  imaginary (even) address (if complex in that direction)
 </PRE>
<A NAME="chkborder3d">
 <H3>chkborder3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine chkborder3d(lf1,ur1,axis,it)
  IN    : axis,it
  INOUT : lf1,ur1
  this subroutine verify the border of a window on a 3D spectra,
  to be coherent with itype, i.e. begins on a real (odd) address, end
  imaginary (even) address (if complex in that direction)
 </PRE>
<A NAME="cicopsvect">
 <H3>cicopsvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cicopsvect(index,a,b,size,size1)
 
  CICOPVECT(INDX,A,B,N,N1) copy the complementary part of B(INDX(i)) into A
  A and B are strings
 
  Be careful! the index array INDX should be sorted in ascending order
 
 </PRE>
<A NAME="cicopvect">
 <H3>cicopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cicopvect(index,a,b,size,size1)
 
  CICOPVECT(INDX,A,B,N,N1) copy the complementary part of B(INDX(i)) into A
  Be careful! the index array INDX should be sorted in ascending order
 
 </PRE>
<A NAME="classif">
 <H3>classif</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/nuee.for"> /usr/local/gifa/source/nuee.for </A> 
 <PRE>       subroutine classif(verbose,origine,size,classe,
      *          nbclasse,rep,nbrep,nbpt)
 
  used by linecor2
 
 
 
 </PRE>
<A NAME="clean">
 <H3>clean</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/roots.for"> /usr/local/gifa/source/roots.for </A> 
 <PRE>       subroutine clean (zn,order,new)
  IN	: order,new
  INOUT	: zn
 
  part of the LPSVD package
 
 
  Keep only the roots outside of the unity-circle ; new is the new order
 
 </PRE>
<A NAME="cleanst">
 <H3>cleanst</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine cleanst(s,n)
  IN	: n
  INOUT	: s
 
     clean the string  "s(n)" for non-printable char
 
 </PRE>
<A NAME="clear_infoCB">
 <H3>clear_infoCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void clear_infoCB(w,client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="clesvd">
 <H3>clesvd</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/clesvd.for"> /usr/local/gifa/source/clesvd.for </A> 
 <PRE>       subroutine clesvd (svd,before,after,job)
 
  IN	: before,after,job
  INOUT	: svd
 
  Clean the singular values of matrix x : remove noise
  from the singular values
  complex*16 svd(before) singular values
  integer after : number of signals others than noise
  when job = 1, the mean power of the removed SVD is removed from
                the remaining ones
 
 </PRE>
<A NAME="closest">
 <H3>closest</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       function closest(nbre)
  IN	: nbre
   return the integer greater then 1, and nearest to the real nbre
 
 </PRE>
<A NAME="cmltvect">
 <H3>cmltvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cmltvect(a,b,l,size)
  IN	: b,l,size
  OUT	: a
 
  CMLTVECT(A,B,L,N) multiply complex vector B by complex l, and put it into A
  
 
 </PRE>
<A NAME="codedelta">
 <H3>codedelta</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine codedelta (rec,szar,szdata)
  IN	: rec,szar,szdata
  
  calculate size of compacted data
 
  szar : 2*order of burg
  rec(szdata) data compacted : first exp.data (szar), and deltas (rec(i+szar))
  between exp. data and calculated data with ar(szar)
 
 </PRE>
<A NAME="codoptim">
 <H3>codoptim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE>       subroutine codoptim (delta,size,code)
  IN	: delta,size
  OUT	: code
  computes optimal codage for compacted data 
 
  code : optimum number of bits
  delta(size) : tot be compacted
 
  Builds a table (sumloc(ncode)) of all possiible coding, and choses
  the best one
 
 </PRE>
<A NAME="compac64">
 <H3>compac64</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writetc3d.for"> /usr/local/gifa/source/writetc3d.for </A> 
 <PRE>        subroutine compac64(cspeci1,especi1,csi1)
      
 </PRE>
<A NAME="compxy_view">
 <H3>compxy_view</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void compxy_view(w, vd_id, evt,xppm,yppm)
 Widget          w;              /*  widget id           */
 int             *vd_id;                 /*  id struct   */
 XEvent          *evt;
 float	          *xppm,*yppm;
 
 /*
 computes the x and y values for view_finder
 */
 </PRE>
<A NAME="confidence">
 <H3>confidence</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/confidence.for"> /usr/local/gifa/source/confidence.for </A> 
 <PRE>       subroutine confidence(func1d,p,xi,size,sizedata,up,down,verb)
  IN	: func1d,p,xi,size,verb
  OUT	: up,down
 
  search around the optimum value p(size) of the given func1d function,
  along the axis xi(size)
  and give the 95% confidence interval.
  func1d : the 1d version of the function to search
      (usually the 1d version of a nD function, using the conjgrad.inc common)
  p:       the optimum value. Should be an extremum for the function !
  size:    the number of dependent variables in func1d, determines the chi2 law
      If larger than 1.0, a larger confidence interval will be used.
  up, down: the confidence interval,
  verb:    verbose mode if 1.0
 
  axis should be normalized for results to be correct.
 
 </PRE>
<A NAME="conjgrad">
 <H3>conjgrad</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/conjgrad.for"> /usr/local/gifa/source/conjgrad.for </A> 
 <PRE>       subroutine conjgrad(func,func1d,dfunc,size,p,iter,miter,
      *                    tol,fmini,verb)
  IN	: func,func1d,dfunc,size,iter,miter,tol,verb
  OUT	: fmini
  INOUT	: p
 
   Computes the minimum of the real function func, using the conjugate gradient
  method. func(x) where x is a vector size-dimentionnal vector
  - func(x(size)) : function to minimize
  - func1d(y) : real version of func
  - dfunc(x(size),dfret(size)) : derivative of func, returns dfret.
  - size : size of the vectors
  - p(size) : initial value, returns the minimum found in p
  - fmini : on output  minimum found
  - iter : number max of iterations
  - miter : number max of iterations for line minisation
            if 0.0 do standard steps, fmini is then used on input as initial
            step
  - tol : epsilon of the minimization.
  - verb : if 1, verbose output
 
 </PRE>
<A NAME="conjvect">
 <H3>conjvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  conjvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  CONJVECT(A,B,N) conjugate the complex*16 vector B, of size N and copy it 
  into complex*16 vector A of size N
  
 </PRE>
<A NAME="contclear">
 <H3>contclear</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine contclear(context)
  IN	: context
 
        dealloc all variable within context
 </PRE>
<A NAME="controlc">
 <H3>controlc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>       subroutine controlc(i,j,k)
  This subroutine is called whenever the user hits ^C.
 </PRE>
<A NAME="controlgull">
 <H3>controlgull</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/controlgull.for"> /usr/local/gifa/source/controlgull.for </A> 
 <PRE>       subroutine controlgull(verbose)
  IN	: verbose
  SIDE	: a lot !
 
  Performs initialisation of the MaxEnt run, a realise the loop over 
  iterations
 
 </PRE>
<A NAME="convert_string">
 <H3>convert_string</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void convert_string(st2,st1,l)
 
 char st2[];
 struct dsc$descriptor_s *st1;
 int l;
 </PRE>
<A NAME="convxy_hp">
 <H3>convxy_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine convxy_hp(x,y,stx,sty,lenx,leny)
  
 </PRE>
<A NAME="convxy_ps">
 <H3>convxy_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine convxy_ps(x,y,retx,rety)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="copvect">
 <H3>copvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  copvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  COPVECT(A,B,N) copy the real vector B, of size N into vector A of size N
 
 </PRE>
<A NAME="copvecti">
 <H3>copvecti</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  copvecti(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  COPVECTI(A,B,N) copy the integer vector B, of size N into integer vector A 
  of size N
 
 </PRE>
<A NAME="copy_pixmap">
 <H3>copy_pixmap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void copy_pixmap(vd_id_orig)
 int *vd_id_orig;
 /*******************************************************************
 *	duplique la fenetre contenant la pixmap
 *	mode: 1 fenetre complete
 *******************************************************************/
 
 </PRE>
<A NAME="copypic3d">
 <H3>copypic3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/stockpic.for"> /usr/local/gifa/source/stockpic.for </A> 
 <PRE>       subroutine copypic3d(n2d,ind3d,sign,zq)
 
  this sub makes an incremental load of the 3D peak table with the contents
  of the 2d peak table, removing non-maximum entries
 
  every thing is done within common blocks
 
  n2d   is the size of the current 2d peak table
  ind3d is the index of the current F1 plane being processed
 
 </PRE>
<A NAME="countlevel">
 <H3>countlevel</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/clesvd.for"> /usr/local/gifa/source/clesvd.for </A> 
 <PRE>       subroutine countlevel (svd,before,after,job,level)
 
  IN	: before,after,job,level
  INOUT	: svd
 
  Keep the singular values greater than level
  svd(before): complex*16 singular values
  after: number of singular values greater than level 
  Clean the singular values of matrix x : remove noise
  from the singular values
  complex*16 svd(before) singular values
  integer after : number of signals others than noise
  when job = 1, the mean power of the removed SVD is removed from
                the remaining ones
 
 </PRE>
<A NAME="cp2vect">
 <H3>cp2vect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cp2vect(arrayout,arrayin,sizeout,sizein)
  IN	: arrayin,sizeout,sizein
  OUT	: arrayout
 
  CP2VECT(A,B,NA,NB) copy real vector of length NB into real vector A of length
                     NA, NA and NB may be different, zero fill or truncate
                     accordingly.
  copy is done on direct order
 
 </PRE>
<A NAME="cprvect">
 <H3>cprvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  cprvect(arrayout,arrayin,sizeout,sizein)
  IN	: arrayin,sizeout,sizein
  OUT	: arrayout
 
  CPRVECT(A,B,NA,NB) copy real vector of length NB into real vector A of length
                     NA, NA and NB may be different, zero fill or truncate
                     accordingly. Starting form the end
  In reverse order.
 
 </PRE>
<A NAME="creat_Multi_select">
 <H3>creat_Multi_select</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_Multi_select(str_form,name,variable,list_states,nb_but,val_def)
 FORM_data *str_form;
 char name[MAX_CHAR];
 char variable[32];
 int nb_but;
 char *list_states[32];
 char val_def[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_Multi_select(str_form,name,variable,list_states,nb_but,list_def,nb_def)
 *
 *       IN: str_form,name,variable,list_states,nb_but,list_def,nb_def
 *
 *       Creation d'un champ de type multienum (multiple select)
 *       var:
 *               Widget parent; id widget du cadre general formulaire
 *               FORM_data *str_form; pt struct generale;
 *               char *name; label du champ
 *               char *variable; nom de la variable
 *               int nb_but; nbre de champs dans la liste de selection
 *               char *list_states[]; liste pt des differents champs de la liste de selection
 *               char *list_def[]; liste pt des differents champs preselectionnes 
 *		int nb_def; nbre de champs preselectionnes
 *
 */
 </PRE>
<A NAME="creat_PulldownMenu">
 <H3>creat_PulldownMenu</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_PulldownMenu(str_form,name,variable,list_states,nb_but,def_val)
 FORM_data *str_form;
 char name[MAX_CHAR];
 char variable[32];
 int nb_but;
 char *list_states[32];
 char def_val[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_PulldownMenu(str_form,name,variable,list_states,nb_but,def_val)
 *
 *       IN: str_form,name,variable,list_states,nb_but,def_val;
 *
 *       Creation d'un champ de type enum
 *       -> text sur une ligne
 *       var:
 *               Widget parent; id widget du cadre general formulaire
 *               FORM_data *str_form; pt struct generale;
 *               char *name; label du champ
 *               char *variable; nom de la variable
 *               int nb_but; nbre de boutons dans le pulldown
 *               char *list_states[]; liste pt des differentes valeurs predefinies
 *               char *def_val;valeur par defaut
 *
 */
 </PRE>
<A NAME="creat_action">
 <H3>creat_action</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_action(str_form,label,command_f,lg_comm)
 FORM_data *str_form;
 char label[MAX_CHAR];
 char command_f[];
 int *lg_comm;
 /*-------------------------------------------------------------
 *       void creat_action(str_form,label,command)
 *
 *       IN: str_form,label,command;
 *
 *       creation d'un champ de formulaire de type action
 *	button with action
 *       var:
 *
 *               FORM_data *str_form; pt struct generale
 *               char *label; Label du button
 *               char *command;  command
 *
 */
 </PRE>
<A NAME="creat_file">
 <H3>creat_file</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_file(str_form,label_var,variable,val_def)
 FORM_data *str_form;
 char label_var[MAX_CHAR];
 char variable[32];
 char val_def[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_file(str_form,label_var,variable,val_def)
 *
 *       IN: parent,label_var,variable,val_def;
 *
 *       creation d'un champ de formulaire de type file
 *               -> TextField avec SelectionFile
 *       var:
 *
 *               FORM_data *str_form; pt struct generale
 *               char *label_var; Label du champ
 *               char *variable;  nom de la variable
 *               char *val_def;   valeur par defaut
 *
 */
 </PRE>
<A NAME="creat_message_text">
 <H3>creat_message_text</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_message_text(str_form,message)
 FORM_data *str_form;
 char message[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_message_text(str_form,message)
 *
 *       IN: message
 *
 *       Creation d'un champ de type message
 *       -> text sur une ligne
 *       var:
 *               char *message; texte
 */
 </PRE>
<A NAME="creat_scale">
 <H3>creat_scale</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_scale(str_form,label_var,variable,min,max,val_def,dec_pt,error)
 FORM_data *str_form;
 char label_var[MAX_CHAR];
 char variable[32];
 char min[MAX_CHAR];
 char max[MAX_CHAR];
 char val_def[MAX_CHAR];
 char dec_pt[MAX_CHAR];
 int *error;
 /*-------------------------------------------------------------
 *	void creat_scale(str_form,label_var,variable,min,max,val_def)
 *
 *       IN: str_form,label_var,variable,list_states,val_def,type
 *
 *       Creation d'un champ de type scale
 *
 *               FORM_data *str_form; pt sur struct general
 *               char *label_var; Label du champ
 *               char *variable; nom de la variable
 *		char *min,*max; min et max du cursor scale
 *               char *val_def; valeur par defaut
 *		char *dec_pt; nombre de chiffre apres virgule
 *
 *               str_form->nor_var == 0 : variable gifa
 *               str_form->nor_var == 1 : variable non gifa
 */
 </PRE>
<A NAME="creat_text">
 <H3>creat_text</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> int creat_text(str_form,file_name)
 FORM_data *str_form;
 char file_name[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_text(str_form,file_name)
 *
 *       IN: file_name
 *
 *       Creation d'un champ de type texte
 */
 </PRE>
<A NAME="creat_var_champ">
 <H3>creat_var_champ</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void creat_var_champ(str_form,label_var,variable,type,val_def)
 FORM_data *str_form;
 char label_var[MAX_CHAR];
 char variable[32];
 char type[MAX_CHAR];
 char val_def[MAX_CHAR];
 /*-------------------------------------------------------------
 *       void creat_var_champ(str_form,label_var,variable,type,val_def)
 *
 *       IN: parent,label_var,variable,type,val_def
 *
 *       Creation d'un champ de type string
 *       -> TextField pour saisir une chaine de char
 *       var:
 *               FORM_data *str_form; pt sur struct general
 *               char *label_var; Label du champ
 *               char *variable; nom de la variable
 *               char *type; type de la variable; int,char,real...
 *               char *val_def; valeur par defaut
 *	
 *		str_form->nor_var == 0 : variable gifa
 *               str_form->nor_var == 1 : variable non gifa
 */
 </PRE>
<A NAME="create_label">
 <H3>create_label</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void create_label(valtick,label,lglabel,prec)
 float valtick;
 char *label;            
 int *lglabel;
 int prec;
 /*
 void create_label(float valtick,char *label,int *lglabel,int prec)
 
 	Cree une chaine de caracteres contenant la valeur flotante 
 	(valtick), avec une precision de "prec" apres la virgule.
 	Retourne la chaine (label) et sa longeur (lglabel).
 
 
 float valtick; 		valeur en unite courante 
 char *label; 		label de retour 
 int *lglabel;		longueur du label 
 int prec;		precision apres la virgule
 
 */
 </PRE>
<A NAME="create_pixmap_icon">
 <H3>create_pixmap_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void create_pixmap_icon(mere,x,y)
 Widget mere;
 int x,y;
 </PRE>
<A NAME="creer_image">
 <H3>creer_image</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void creer_image(wd,ht,mx,my,matrix) 
 /*XImage *creer_image(wd,ht,mx,my,matrix)*/
 int my,mx,
    *wd,*ht;          /* Image width and height in units. */
 unsigned char *matrix;     /* Natural matrix of dim wd x ht elements. */
 </PRE>
<A NAME="crevvect">
 <H3>crevvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  crevvect(array,size)
  IN	: size
  INOUT	: array
 
  CREVVECT(A,N) reverse the order of the vector A(complex) and put the 
  result back into A (complex)
  
 </PRE>
<A NAME="ctrvect">
 <H3>ctrvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  ctrvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  CTRVECT(A,B,N) copy the real part of the complex vector B of length N into real
                 vector A.
 
 </PRE>
<A NAME="currunit">
 <H3>currunit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine currunit(val,x,dd)
  integer version of currunitr
 </PRE>
<A NAME="currunitr">
 <H3>currunitr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine currunitr(val,x,dd)
  IN	: x,dd
  OUT	: val
 
    index => current
  return the x position (in index) expressed in current unit
  based on current file parameters
  dd is the axis when in nD (1, 2, (3) )
 
 </PRE>
<A NAME="cux1d">
 <H3>cux1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/uxnmrcio.c"> /usr/local/gifa/source/uxnmrcio.c </A> 
 <PRE> void cux1d(lname, ln, column, sizeimage1d, error)
 
 char *lname;
 int *ln, *sizeimage1d, *error;
 float *column;
 
 </PRE>
<A NAME="d3_arrow_downCB">
 <H3>d3_arrow_downCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_arrow_downCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_arrow_leftCB">
 <H3>d3_arrow_leftCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_arrow_leftCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_arrow_rightCB">
 <H3>d3_arrow_rightCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_arrow_rightCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 
 </PRE>
<A NAME="d3_arrow_upCB">
 <H3>d3_arrow_upCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_arrow_upCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_closeCB">
 <H3>d3_closeCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_closeCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_scale_m10CB">
 <H3>d3_scale_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_scale_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_scale_p10CB">
 <H3>d3_scale_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_scale_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d3_scale_resetCB">
 <H3>d3_scale_resetCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void d3_scale_resetCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="d_htoir">
 <H3>d_htoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function d_htoir(hz,dime,axis,error)
  IN	: hz, dime, axis
  OUT   : error
 
  realize the transformation hz to index
  with the coord system of the dim data-set, along axis.
  if dim is 0 ==> use joined exp
 
 </PRE>
<A NAME="d_itohr">
 <H3>d_itohr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function d_itohr(index,dime,axis,error)
  IN	: index, dime, axis
  OUT   : error
 
  realize the transformation index to hz
  with the coord system of the dim data-set, along axis.
  if dim is 0 ==> use joined exp
 
 </PRE>
<A NAME="d_itopr">
 <H3>d_itopr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function d_itopr(index,dime,axis,error)
  IN	: index, dime, axis
  OUT   : error
 
  realize the transformation index to ppm
  with the coord system of the dim data-set, along axis.
  if dim is 0 ==> use joined exp
 
 </PRE>
<A NAME="d_ptoir">
 <H3>d_ptoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function d_ptoir(ppm,dime,axis,error)
  IN	: ppm, dime, axis
  OUT   : error
 
 </PRE>
<A NAME="daddvect">
 <H3>daddvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  daddvect(arrayout,B,C,l,size)
  IN	: B,C,l,size
  OUT	: arrayout
  
  DADDVECT(A,B,C,L,N) multiply the vector C (real*8) by the scalar l,
      add this vector to B(real*8), and put the result into A (real*8)
 
 
 </PRE>
<A NAME="dbmassign">
 <H3>dbmassign</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmassign(dbm_name,array,error)
 
  IN: dbm_name,array
  OUT: error
 
  to open a DBM file
 
  input:
  dbm_name: DBM name
  array: associative array name
 
  output:
  error: error flag
 
 </PRE>
<A NAME="dbmcheck">
 <H3>dbmcheck</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE>         subroutine dbmcheck(array,error)
 
  IN: array
  OUT: error
 
  to check if the array name correspond to a DBM file
 
  input:
  array: associative array name
 
  output:
  error: flag = 0 if found = 1 if not found
 
 </PRE>
<A NAME="dbmdealloc">
 <H3>dbmdealloc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmdealloc(array,error)
 
  IN: array
  OUT: error
 
  to close a DBM file
 
  input:
  array: associative array name
 
  output:
  error: error flag
 
 </PRE>
<A NAME="dbmdel">
 <H3>dbmdel</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmdel(array,key,error)
 
  IN: array,key
  OUT: error
 
  to delete an element in a DBM file
 
  input:
  array: associative array name
  key: database element key
 
  output:
  error: error flag
 
 </PRE>
<A NAME="dbmexist">
 <H3>dbmexist</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmexist(array,key,error)
 
  IN: array,key
  OUT: error
 
  to determines whether the key key exist in a DBM file
 
  input:
  array: associative array name
  key: database element key
 
  output:
  error: error flag
 
 </PRE>
<A NAME="dbmfirst">
 <H3>dbmfirst</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmfirst(array,first_key,error)
 
  IN: array
  OUT: error,first_key
 
  to find the first element key in a DBM file
 
  input:
  array: associative array name
 
  output:
  error: error flag
  first_key: first database element key
 
 </PRE>
<A NAME="dbmget">
 <H3>dbmget</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmget(array,key,value,error)
 
  IN: array,key
  OUT: error,value
 
  to get an element value from a DBM file
 
  input:
  array: associative array name
  key: database element key
 
  output:
  error: error flag
  value: database element value
 
 </PRE>
<A NAME="dbmnext">
 <H3>dbmnext</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmnext(array,next_key,error)
 
  IN: array
  OUT: error,next_key
 
  to find the next element key in a DBM file
 
  input:
  array: associative array name
 
  output:
  error: error flag
  next_key: next database element key
 
 </PRE>
<A NAME="dbmput">
 <H3>dbmput</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine dbmput(array,key,value,error)
 
  IN: array,key,value
  OUT: error
 
  to store an element (key,value) in a DBM file
 
  input:
  array: associative array name
  key: database element key
  value: database element value
 
  output:
  error: error flag
 
 </PRE>
<A NAME="dclosest">
 <H3>dclosest</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       function dclosest(nbre)
  IN	: nbre
   return the integer greater then 1, and nearest to the real nbre
 
 </PRE>
<A NAME="ddcopvect">
 <H3>ddcopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  ddcopvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  DDCOPVECT(A,B,N) copy the real*8 vector B, of size N into real*8 vector A 
  of size N
 
 </PRE>
<A NAME="dddotvect">
 <H3>dddotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  dddotvect(d,a,b,size)
  IN	: a,b,size
  OUT	: d
 
  DDDOTVECT(D,A,B,N) performs the dot product of vectors A (real*8)and
 		    B (real*8) and put the result into D (real*8)
 
 </PRE>
<A NAME="ddotvect">
 <H3>ddotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  ddotvect(d,a,b,size)
  IN	: a,b,size
  OUT	: d
  DDOTVECT(D,A,B,N) performs the dot product of vectors A (complex*16)and
 		    B (complex*8) and put the result into D (complex*8)
 
 </PRE>
<A NAME="dealloc">
 <H3>dealloc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine dealloc(name,context,err)
  IN	: name,err,context
 
 	forget variable name in context
 
 </PRE>
<A NAME="debut_cadre_zoom">
 <H3>debut_cadre_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void debut_cadre_zoom(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int      	*vd_id;    		/*  id struct   */
 XEvent          *evt;
 /*
 	recupere les coordonnees au premier click
 	de la souris
 	initialisation de parametres
 */
 </PRE>
<A NAME="default_butt_form">
 <H3>default_butt_form</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void default_butt_form(str_form_data)
 FORM_data *str_form_data;
 /***************************************************************************
 *       void default_butt_form(str_form_data)
 *
 *       IN:str_form_data
 *       INOUT:
 *
 *       Creation des buttons ok, cancel, apply
 *
 *       var:
 *               FORM_data str_form_data; Structure associee au
 *                                               formulaire
 */
 </PRE>
<A NAME="del_copy">
 <H3>del_copy</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void del_copy(w, donnees, call_data)
 Widget          w;              /*  widget id           */
 donnees_pixmap  *donnees;
 XtPointer       call_data ;
 </PRE>
<A NAME="del_cursor_wait_on_display">
 <H3>del_cursor_wait_on_display</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void del_cursor_wait_on_display(flag)
 int flag;
 </PRE>
<A NAME="del_shell_on_display">
 <H3>del_shell_on_display</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void del_shell_on_display(id_shell)
 Widget id_shell;
 </PRE>
<A NAME="del_wait_cursor">
 <H3>del_wait_cursor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void  del_wait_cursor(win)
 Window win;
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C   del_wait_cursor                                                      C
 C                                                                        C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="delete_last_cadre_zoom">
 <H3>delete_last_cadre_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void delete_last_cadre_zoom(vd_id)
 int       *vd_id;    
 
 /* 
 	efface le cadre de zoom associe a la fenetre
 */
 </PRE>
<A NAME="delmask">
 <H3>delmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine delmask(nopk)
 
  delete the mask of the peak nopk
 
  IN	: nopk
  OUT	: amoeba
 
 </PRE>
<A NAME="deriv">
 <H3>deriv</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/deriv.for"> /usr/local/gifa/source/deriv.for </A> 
 <PRE>       subroutine deriv(debug,quoi,size)
  IN	: debug,quoi,size
  SIDE	: work3(20*bcmax+1)
  computes derivative and/or curvature of the 1D data held
  in source  ( work3(16*bcmax+1) ) and put it back in source1
 
  if quoi eq 1 derivative
             2 curvature
             3 both
  
 </PRE>
<A NAME="detmsk">
 <H3>detmsk</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/detmsk.for"> /usr/local/gifa/source/detmsk.for </A> 
 <PRE> 	subroutine detmsk (masktab,tab,taille1,taille2,
      & verbose,indxx,indxy,factor,slope,
      & threshold,rad,signpic,zq)
 
  Determine a peak amoeba from the peak maximum, and the peak 
  maximum coordinatesstab
  
  IN	: tab,masktab,taille1,taille2,amp,factor,slope,
  IN    : threshold,radius,signpic,verbose,zq
  OUT	: peak2d
 
 </PRE>
<A NAME="dfgauss">
 <H3>dfgauss</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine dfgauss(size,param,x,dyda) 
  IN	: size,param,x
  OUT	: dyda
  Computes the derivative of the gaussian line in x, the parameters are 
  found in param
 
 
 
 </PRE>
<A NAME="dfitg2">
 <H3>dfitg2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine dfitg2(size,p,x,dy)
 
  compute  derivative of f(x)
 
  where f is defined as a string to be evaluated by eval()
  and x is set to $X
      p(i)     to $Pi
 
  derivative is done numerically
 
 </PRE>
<A NAME="dflogau">
 <H3>dflogau</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine dflogau(size,param,x,dyda)
  IN    : size,param,x
  OUT   : dyda
  Computes the derivative of the lorentzian or gaussiean line in x, the 
  parameters are found in param
 
  
 
 </PRE>
<A NAME="dflogau2d">
 <H3>dflogau2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine dflogau2d(size,param,x,dyda)
  IN	: size,param,x
  OUT	: dyda
  computes the derivative of the 2D lorent/gaussian line in x, the parameters are 
  found in param
 
  dg2d/dx = a [ dg1/dx g2  +   dg2/dx g1]    (only one term is !=0 )
 
 </PRE>
<A NAME="dflorenz">
 <H3>dflorenz</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine dflorenz(size,param,x,dyda)
  IN	: size,param,x
  OUT	: dyda
  computes the derivative of the lorentzian line in x, the parameters are 
  found in param
 </PRE>
<A NAME="diavect">
 <H3>diavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  diavect(a,b,c,size)
  IN	: b,c,size
  OUT	: a
 
  DIAVECT(A,B,C,N) multiply the vector C by the diagonal matrix whose diagonal
                   is in vector B, and put the result into A
 
  i.e. a(i) = b(i)*c(i)
 
 </PRE>
<A NAME="disjconnect">
 <H3>disjconnect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine disjconnect(err)
  OUT	: err
 
  closes the alternate journaling file currently opened
  and returns to regular journaling
 
 	  implicit none
 </PRE>
<A NAME="display1d">
 <H3>display1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/display1d.for"> /usr/local/gifa/source/display1d.for </A> 
 <PRE>       subroutine display1d(vd_id,size,spectrum,max0,scaling,mode,vh,ref)
 
  IN	: vd_id,size,spectrum,max0,scaling,mode,vh,ref
 
  displays array spectrum(size) on visual display vd_id, with scaling 
  if mode.eq.0 display every thing, if mode.eq.1 only one over two
  modified to compute mean over undisplayed points
    (more realistic on gif data-sets)
 
 </PRE>
<A NAME="display2d">
 <H3>display2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/display2d.for"> /usr/local/gifa/source/display2d.for </A> 
 <PRE>       subroutine display2d(vd_id,size2,size1,array,max0,
      *          scaling,mode,signl,
      *          zoom,zolf1,zolf2,zour1,zour2)
  IN    : vd_id,size2,size1,array,max0, scaling,mode,signl,zoom,zolf1,
 
  displays array array(size2,size1) on visual display vd_id, with scaling
  if mode.eq.0 display every thing, if mode.eq.1 only one over two in dim
  1 if mode.eq.2 only one over two in dim 2, if mode.eq.3,only one over
  two in both dim
  if signl is -1 display only negative points...
  if signl is 1  display only positive points...
  if signl is 0 display both
  if zoom.eq.1  zolf1,zolf2,zour1,zour2 are used as window coordinates
 
 </PRE>
<A NAME="display_icon">
 <H3>display_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine display_icon(simax,s1,s2,bitmap)
  used to set the 'catch spectrum' small icon
 
 </PRE>
<A NAME="display_pivot_point">
 <H3>display_pivot_point</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine display_pivot_point(temp1,p0,p1,x0,vd_id,flag)
  affichage du trait vertical durant le PH
 </PRE>
<A NAME="dmexp">
 <H3>dmexp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fitexp.for"> /usr/local/gifa/source/fitexp.for </A> 
 <PRE>       subroutine dmexp(size,param,x,dyda) 
  IN	: size,param,x
  OUT	: dyda
  Computes the derivative of the mexp function at x, the parameters are 
  found in param
 
 
 
 </PRE>
<A NAME="do_action">
 <H3>do_action</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void do_action(w,struct_command, call_data)
 Widget          w;              /*  widget id           */
 STR_ACT_FORM       *struct_command;
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="do_nothing">
 <H3>do_nothing</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/util.c"> /usr/local/gifa/source/util.c </A> 
 <PRE> void do_nothing()
 </PRE>
<A NAME="dofilter">
 <H3>dofilter</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dofilter.for"> /usr/local/gifa/source/dofilter.for </A> 
 <PRE>       subroutine dofilter
 
  this subroutine, compute the filter from the parameters lb, gb, J1 and
  actualize the filter buffer. Set it to 1.0 if no filter used.
  part of the MaxEnt package
 
 </PRE>
<A NAME="doref2d">
 <H3>doref2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dorefresh.for"> /usr/local/gifa/source/dorefresh.for </A> 
 <PRE>       subroutine doref2d(win_id)
  refresh the 2D-density window called win_id
 
 </PRE>
<A NAME="doref2dcont">
 <H3>doref2dcont</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dorefresh.for"> /usr/local/gifa/source/dorefresh.for </A> 
 <PRE>       subroutine doref2dcont(win_id)
  refresh the 2D-contour window called win_id
 
 </PRE>
<A NAME="dorefresh">
 <H3>dorefresh</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dorefresh.for"> /usr/local/gifa/source/dorefresh.for </A> 
 <PRE>       subroutine dorefresh()
  part of the GIFA command parser,
  determines whether the display should be recomputed.
  uses the global variable refresh to do so, and call accordingly
  the correct display routines.
 
 </PRE>
<A NAME="dorefresh1d">
 <H3>dorefresh1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dorefresh.for"> /usr/local/gifa/source/dorefresh.for </A> 
 <PRE>       subroutine dorefresh1d(win_id)
  IN : win_id
  refresh the 1D window called win_id
 
 </PRE>
<A NAME="doslide">
 <H3>doslide</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/doslide.for"> /usr/local/gifa/source/doslide.for </A> 
 <PRE>       subroutine doslide (indxx,indxy,x0,y0,rad)
 
  IN x0,y0,rad
  OUT indxx,indxy
 
  find the coordinates of the pixels belonging to
  the square number rad around the pixel (x0,y0)
 
 </PRE>
<A NAME="dotvect">
 <H3>dotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  dotvect(d,a,b,size)
  IN	: a,b,size
  OUT	: d
  DOTVECT(D,A,B,N) performs the dot product of vectors A and B and put the
                   result into D
  
 
 </PRE>
<A NAME="dphasemerit">
 <H3>dphasemerit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/phasemerit.for"> /usr/local/gifa/source/phasemerit.for </A> 
 <PRE>        subroutine dphasemerit(phase,dphase)
  IN	: phase
  OUT	: dphase
   dphase is the gradient of the function phasemerit at point phase.
  the first two elements are order 0 and 1 in dim1
  the two others are order 0 and 1 in dim2.
  
 </PRE>
<A NAME="draw_h_vwf">
 <H3>draw_h_vwf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void draw_h_vwf(vd_id, y)
 int             *vd_id;                 /*  id struct   */
 float           *y;                     /* in 0..1 coord */
 /*  draw the horinzontal viewfinder 
     added by MAD, july `99 */
 </PRE>
<A NAME="draw_tick">
 <H3>draw_tick</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void draw_tick(vd_id,axe,pos,label,taille)
 int *vd_id;
 int axe;
 float pos;
 int taille;
 char *label;
 /*
 void draw_tick(int *vd_id,int axe,float pos,char *label,int taille)
 
 	plot tick at position pos with label .
 
 
 int *vd_id;      Virtual display ID         
 int axe; 	 1=f1, 2=f2 
 float pos;       position sur tick sur l'axe   
 int taille;	 taille du label
 char *label;	 text to write
 
 */
 
 </PRE>
<A NAME="draw_v_vwf">
 <H3>draw_v_vwf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void draw_v_vwf(vd_id, x)
 int             *vd_id;                 /*  id struct   */
 float  *x;                              /* in 0..1 coord */
 /*  draw the vertical viewfinder 
     added by MAD, july `99 */
 </PRE>
<A NAME="dsavect">
 <H3>dsavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dsavect.for"> /usr/local/gifa/source/dsavect.for </A> 
 <PRE>       subroutine dsavect(data,size,shift,factor)
  IN	: size,shift,factor
  INOUT	: data
 
  replaces data(i) by data(i) + factor*data(i+shift)
 
 </PRE>
<A NAME="dscopvect">
 <H3>dscopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  dscopvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  DSCOPVECT(A,B,N) copy the real*8 vector B, of size N into real*4 vector A 
  of size N
 
 </PRE>
<A NAME="dt1func">
 <H3>dt1func</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/t1fit.for"> /usr/local/gifa/source/t1fit.for </A> 
 <PRE>       subroutine dt1func(param,dx)
 </PRE>
<A NAME="dumpvar">
 <H3>dumpvar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine dumpvar()
 	prints the content of the variable table
 </PRE>
<A NAME="end_input_iconCB">
 <H3>end_input_iconCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void end_input_iconCB(w, client_data, evt)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XEvent          *evt;
 </PRE>
<A NAME="entier">
 <H3>entier</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>        subroutine entier(espec1,rspec1,size,fact)
  IN	: rspec1,size,fact
  OUT	: espec1
 
    This subroutine, given real vector "rspec1(size)", returns
  the corresponding integer vector "espec1(size)" such that
  espec1 = int( fact*rspec1 ) .
      
      
 </PRE>
<A NAME="entvect">
 <H3>entvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine entvect(ent,image,scale,size)
  IN	: image,scale,size
  OUT	: ent
 
  C ENTVECT(E,A,S,N) E is the entropy of vector A for scaling S
                   ( sum of -Z(i)*LOG(Z(i)), where  Z(i) = A(i)/S )
 
 </PRE>
<A NAME="eucvect">
 <H3>eucvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine eucvect(n,a,b,size)
  IN	: a,b,size
  OUT	: n
 
  EUCVECT(E,A,B,N) compute the norm of the vector A weighted by the diagonal
           metric matrix whose diagonal is in B, and put the result into E
  i.e.  E = sum( a(i)^2 . b(i) ) 
 
 
 </PRE>
<A NAME="eval">
 <H3>eval</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine eval(st,result,err)
  IN	: st
  OUT	: result,err
  performs the evaluation of the string st and put the result back into 
  result.
  evaluates operators, functions, variables
  operates through a virtual stack machine, implemented with
  pushval stackop evalstack
 
 </PRE>
<A NAME="evaln">
 <H3>evaln</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/evaln.for"> /usr/local/gifa/source/evaln.for </A> 
 <PRE>       subroutine evaln(array,size,noise,shift)
  IN	: array,size
  OUT	: noise,shift
 
  evaluates the noise from the data
  the mean is returned in shift
  the standard deviation is returned in noise
 
 </PRE>
<A NAME="evaln2D">
 <H3>evaln2D</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/evaln2d.for"> /usr/local/gifa/source/evaln2d.for </A> 
 <PRE>       subroutine evaln2D(smx, si1,si2,noise,shift,err)
  IN	: smx, si1,si2
  OUT	: noise,shift,err
 
  evaluates the noise from the 2D smx, prompt the user for the
  area to evaluate
  the mean is returned in shift
  the standard deviation is returned in noise
 
 </PRE>
<A NAME="evalstack">
 <H3>evalstack</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine evalstack(current,err)
  IN	: current
  OUT	: err
 
  operates the stack machine, at the "current" level of priority
  used by eval
 
 </PRE>
<A NAME="excvect">
 <H3>excvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  excvect(arrayout,arrayin,size)
  IN	: size
  INOUT	: arrayout,arrayin
 
  EXCVECT(A,B,N) exchange the values of vectors A and B.
 
 
 </PRE>
<A NAME="execute">
 <H3>execute</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/execute.for"> /usr/local/gifa/source/execute.for </A> 
 <PRE>       subroutine execute(todocomm,tdlen,error)
  IN	: todocomm,tdlen
  OUT	: error
 
  execute the GIFA string of command held into todocomm,tdlen
 
 </PRE>
<A NAME="existvar">
 <H3>existvar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine existvar(vname,context,err)
  IN	: vname,context
  INOUT : err
 
       check if the variable called name exists in "context", returns with err :
  err = 0 means found
  err = 1 means not found
 
 </PRE>
<A NAME="exp2d">
 <H3>exp2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine exp2d(smx,size1,size2,x,y,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by an damped exponential.
  x is damping on F1 y on F2
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="exp3d">
 <H3>exp3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine exp3d(smx,si1,si2,si3,lb1,lb2,lb3,it3d)
  IN	: si1,si2,si3,mode,lb1,lb2,lb3,it3d
  INOUT	: smx
 
  3D exponential apodisation
 
 </PRE>
<A NAME="expmult">
 <H3>expmult</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/expmult.for"> /usr/local/gifa/source/expmult.for </A> 
 <PRE>       subroutine expmult(array,size,lb,itype)
  IN	: size,lb,itype
  INOUT	: array
 
  multiplies the array with an exponential, which damping is lb.
  if itype .eq. 0 data are real
  if itype .eq. 1 data are complex
 
 </PRE>
<A NAME="expose_icon">
 <H3>expose_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void expose_icon(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;
 
 </PRE>
<A NAME="extpic">
 <H3>extpic</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/extpic.for"> /usr/local/gifa/source/extpic.for </A> 
 <PRE>       subroutine extpic(zn,width,freq,amp,phas,
      *		ipvt,order,zz,wk,data,sizdat,a,specw,offset,
      *          error,stdev,delay)
  IN	: zn,order,zz,data,sizdat,a,specw,offset,delay
  OUT	: width,freq,amp,phas,error,stdev
  WORK	: ipvt,wk
 
  Computes line parameters form the data "data" and the set of 
  roots of the autoregresseive polynomial "zn"
  amplitude and phases are computed by a matrix inversion, using
  the Prony's method.
 
 </PRE>
<A NAME="extr2d">
 <H3>extr2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/extr2d.for"> /usr/local/gifa/source/extr2d.for </A> 
 <PRE>       subroutine extr2d(smx,si1,si2,col1,col2,lig1,lig2)
  IN	: col1,col2,lig1,lig2
  INOUT	: smx,si1,si2
 
  extract a submatrix from the matrix smx
  1 is for second index, 2 is for first index
 
 </PRE>
<A NAME="extr3d">
 <H3>extr3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/extr3d.for"> /usr/local/gifa/source/extr3d.for </A> 
 <PRE>       subroutine extr3d(smx,si1,si2,si3,pil1,pil2,
      *                              col1,col2,lig1,lig2)
  IN	: pil1,pil2,col1,col2,lig1,lig2
  INOUT	: smx,si1,si2,si3
 
  extract a subcube from the smx cube
  3 is for 1st index, 2 for second, 1 for third
 
 </PRE>
<A NAME="fairemat">
 <H3>fairemat</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fairemat.for"> /usr/local/gifa/source/fairemat.for </A> 
 <PRE>       subroutine fairemat (data,sizdat,order,x,nd1)
  IN	: data,sizdat,order,nd1
  OUT	: x
 
  Prepare the data for calculation of svd 
  data(sizdata) complex
  integer order : number of coeff ar
  integer nd1 : sizdat-order-1 : other dimension of matrix X
  complex*16 x(nd1,order) : matrix whose svd will be calculated
  
 </PRE>
<A NAME="famini">
 <H3>famini</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rotation.for"> /usr/local/gifa/source/rotation.for </A> 
 <PRE>       function famini(x)
 
  part of diagonalisation package, ROTATION command
 
 
 </PRE>
<A NAME="fftcpx">
 <H3>fftcpx</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fftcpx.for"> /usr/local/gifa/source/fftcpx.for </A> 
 <PRE>       subroutine fftcpx(fdata,size,sign)
  IN	: size,sign
  INOUT	: fdata
  This subroutine performs an in-place complex fourier-transform
  on the complexe array fdata of length SIZE.
  SIGN = 1 for direct FT and -1 for inverse FT
  from numerical recipes, Cambridge univ. press W.H.Press et al.
 
 </PRE>
<A NAME="fftreal">
 <H3>fftreal</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fftreal.for"> /usr/local/gifa/source/fftreal.for </A> 
 <PRE>        subroutine fftreal(fdata,size,sign,direc)
  IN	: size,sign,direc
  INOUT	: fdata
  This subroutine performs an in-place real fourier-transform
  on the real array fdata of length SIZE.
  SIGN = 1 for direct FT and -1 for inverse FT
  DIREC=1 FT real to complex, DIREC=-1 complex to real
  from numerical recipes, Cambridge univ. press W.H.Press et al.
 
 </PRE>
<A NAME="fgauss">
 <H3>fgauss</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine fgauss(size,param,x,y) 
  IN	: size,param,x
  OUT	: y
  Computes the value of the gaussian line in x, the parameters are 
  found in param
                    x-xo
  g = A exp( -( a -------)^2 )   a = 2sqrt(log(2))
                     w
 
 </PRE>
<A NAME="file_exist">
 <H3>file_exist</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE> 	subroutine file_exist(namep,error)
 
   file_exist - check file.  Returns error=0 if file exists
  IN    : namep
  OUT   : error
 </PRE>
<A NAME="fill_bitmap">
 <H3>fill_bitmap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/display2d.for"> /usr/local/gifa/source/display2d.for </A> 
 <PRE>       subroutine fill_bitmap(simax,size2,size1,array,max0,
      *          scaling,mode,signl,
      *          zoom,zolf1,zolf2,zour1,zour2,s1im,s2im,bitmap)
  IN	: size2,size1,array,max0, scaling,mode,signl,zoom,zolf1,zolf2,zour1,zour2
 
  displays array array(size2,size1) on visual display , with scaling 
  if mode.eq.0 display every thing, if mode.eq.1 only one over two in dim
  1 if mode.eq.2 only one over two in dim 2, if mode.eq.3,only one over
  two in both dim
  if signl is -1 display only negative points...
  if signl is 1  display only positive points...
  if signl is 0 display both
  if zoom.eq.1  zolf1,zolf2,zour1,zour2 are used as window coordinates
 
 </PRE>
<A NAME="fin_cadre_zoom">
 <H3>fin_cadre_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void fin_cadre_zoom(vd_id,evt)
 int       *vd_id;    
 XEvent    *evt;
 
 /*
 	recupere les coordonnees finales de la souris et les
 	sauvegarde afin de pouvoir effacer le cadre plus tard
 */
 </PRE>
<A NAME="find_var">
 <H3>find_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine find_var(name,context,addr)
  IN	: name,context
  OUT	: addr
 
  find the variable called "name" in "context" or in gloabl context 
  in the internal table, and returns its address
 
 
  addr is 0 if not found
 
  correction 13-dec-1996  MAD
  removed the tests varname .eq. ' '
  this may happend when a collision occured and the colliding var
  was then unset.
 
 **********Should not be used for normal use**************************
 </PRE>
<A NAME="finmsk">
 <H3>finmsk</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/finmsk.for"> /usr/local/gifa/source/finmsk.for </A> 
 <PRE> 	subroutine finmsk (masktab,tab,taille1,taille2,
      & indxx,indxy,factor,slope,x0,y0,
      & threshold,signpic)
 
  Finish the peak amoeba determination by resolving conflicts
  
  IN	: tab,masktab,taille1,taille2,amp,factor,slope,
  IN    : threshold,signpic
  OUT	: peak2d
 
 </PRE>
<A NAME="fitg2">
 <H3>fitg2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine fitg2(size,p,x,y)
 
  compute  f(x)
 
  where f is defined as a string to be evaluated by eval()
  and x is set to $X
      p(i)     to $Pi
 
 </PRE>
<A NAME="fitgend">
 <H3>fitgend</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine fitgend(p,chi2,cov,size,nbpt,verb,err)
  IN:   p,chi2,cov,size,nbpt,verb
  SIDE: copy into user Gifa variable $Pi and $DPi
 
  size: The number of independent parameters
  nbpt: the number of points in the fit
  p(size) : the fortran array that will hold the counter part of $Pi
  cov(size,size) the covariance matrix, of the fit
  chi2: the chi square of the fit
 
  copies all running parameters to User variables
  sets $Pi equal to p(i)
 
  it also computes error bars, using cov() and put them in $DPi
 
  verbose if verb > 1
 
 </PRE>
<A NAME="fitgene">
 <H3>fitgene</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       function fitgene(p,size)
 
  compute a CHI2 = szamp(data[i] - computed(tab[i]))^2
 
 </PRE>
<A NAME="fitgene1d">
 <H3>fitgene1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>        function fitgene1d(x)
  IN	: x
  1d version of fitgene
  x a real, parameting along axis, starting from start (in conjgrad.inc)
 </PRE>
<A NAME="fitgeneinit">
 <H3>fitgeneinit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine fitgeneinit(st,p,size,err)
  IN:   st,size
  OUT:  p
 
  This one initialize every thing for the generic minimizer (FITGENE)
  st : the string to evaluate, should be a function of the global
       variables $Pi and $X
  size: The number of independent parameters
  p(size) : the fortran array that will hole the counter part of $Pi
 
  initializes the common for powell
  sets p(i) equal to $Pi and $X equal to 0.0
 
 </PRE>
<A NAME="flogau">
 <H3>flogau</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine flogau(size,param,x,y)
  IN    : size,x
  OUT   : y
  INOUT : param (changed if error)
  Computes the value of the lorentzian or gaussian line in x, the 
  parameters are found in param
 
 
 </PRE>
<A NAME="flogau2d">
 <H3>flogau2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine flogau2d(size,param,x,y)
  IN	: size,x
  OUT	: y
  INOUT : param
  computes the value of the 2D lorent/gaussian line in x, the parameters are 
  found in param
 
  param is modified when negative width are found
 
  g2d(x) = A g1d(i) g1d(j)
 
  with i = mod(x,code)   j = x/code    i.e. x = j*code + i
  and g1d are 1d lorent/gaussian function with amplitude 1.0
 
 
 </PRE>
<A NAME="florenz">
 <H3>florenz</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine florenz(size,param,x,y)
  IN	: size,param,x
  OUT	: y
  Computes the value of the lorentzian line in x, the parameters are 
  found in param
 
             A
  f = -------------------
       1 + (2(x-xo)/w)^2
 
  will also reset negative widthes
 
 
 
 </PRE>
<A NAME="fplot2d">
 <H3>fplot2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fplot2d.for"> /usr/local/gifa/source/fplot2d.for </A> 
 <PRE>       subroutine fplot2d(pl_id,vd_id,si1,si2,matrix,
      *        maxi,scaling,mode,dx,dy,levels,sign2,loga,
      *        zoom,zolf1,zolf2,zour1,zour2)
  IN	: all parameters
  equivalent to plot2d, but outputs to the file which id is "pl_id"
 
 </PRE>
<A NAME="free_struct">
 <H3>free_struct</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void free_struct(str_form_data)
 FORM_data *str_form_data;
 /*-------------------------------------------------------------
 *       void free_struct(str_form_data)
 *
 *       IN:str_form_data
 *       INOUT:
 *
 *       desalloue les struct TextField,PullDown et form_data.
 *
 *       var:
 *               FORM_data str_form_data; Structure associee au
 *                                               formulaire
 */
 </PRE>
<A NAME="freeze_comm">
 <H3>freeze_comm</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void freeze_comm(w, vd_id, call_data)
     Widget      w;
     int   *vd_id, *call_data;
 </PRE>
<A NAME="g3d_config">
 <H3>g3d_config</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_config(text,l)
  OUT	: text,l
  common to all 3D routines
  
  returns name of 3D library
 </PRE>
<A NAME="g3d_init">
 <H3>g3d_init</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_init
  common to all 3D routines
  
  initializes the 3d space
 </PRE>
<A NAME="g3d_setalpha">
 <H3>g3d_setalpha</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setalpha(a)
  IN	: a
  common to all 3D routines
  
  set alpha angle
 </PRE>
<A NAME="g3d_setbeta">
 <H3>g3d_setbeta</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setbeta(a)
  IN	: a
  common to all 3D routines
  
  set beta angle
 </PRE>
<A NAME="g3d_setgama">
 <H3>g3d_setgama</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setgama(a)
  IN	: a
  common to all 3D routines
  
  set gama angle
 </PRE>
<A NAME="g3d_setoff">
 <H3>g3d_setoff</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setoff(x,y,z)
  IN	: x,y,z
  common to all 3D routines
  
  set offset on axes x,y,z
 </PRE>
<A NAME="g3d_setscale">
 <H3>g3d_setscale</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setscale(a)
  IN	: a
  common to all 3D routines
  
  set global scale
 </PRE>
<A NAME="g3d_setscxyz">
 <H3>g3d_setscxyz</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setscxyz(a,b,c)
  IN	: a,b,c
  common to all 3D routines
  
  set scale on axes x,y,z
 </PRE>
<A NAME="g3d_setznot">
 <H3>g3d_setznot</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine g3d_setznot(a)
  IN	: a
  common to all 3D routines
  
  set z0 view parameter
 </PRE>
<A NAME="gama_m10CB">
 <H3>gama_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void gama_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="gama_m1CB">
 <H3>gama_m1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void gama_m1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="gama_p10CB">
 <H3>gama_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void gama_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="gama_p1CB">
 <H3>gama_p1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void gama_p1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="gasdev">
 <H3>gasdev</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/random.for"> /usr/local/gifa/source/random.for </A> 
 <PRE>       function gasdev(idum)
  INOUT	: idum
 
  this function returns a normally distributed deviate with 0 mean and unit
  variance, usins RANDOMD(IDUM)
  form Num. Recipes p203
       
 </PRE>
<A NAME="gaus2d">
 <H3>gaus2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine gaus2d(smx,size1,size2,x,y,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by an damped gaussian.
  x is damping on F1 y on F2
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="gaus3d">
 <H3>gaus3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine gaus3d(smx,si1,si2,si3,gb1,gb2,gb3,it3d)
  IN	: si1,si2,si3,mode,gb1,gb2,gb3,it3d
  INOUT	: smx
 
  3D gaussian apodisation
 </PRE>
<A NAME="gauscplx">
 <H3>gauscplx</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/trigmult.for"> /usr/local/gifa/source/trigmult.for </A> 
 <PRE>       subroutine gauscplx(vect,size)
  IN	: size,itype
  INOUT	: vect
 
  multiply  (cplx*8) vect(size) by the exp(i pi/n k^2) function
  which appears in deconvolution theory
 
 </PRE>
<A NAME="gausmult">
 <H3>gausmult</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gausmult.for"> /usr/local/gifa/source/gausmult.for </A> 
 <PRE>       subroutine gausmult(array,size,gb,itype)
  IN	: size,gb,itype
  INOUT	: array
 
  multiplies the array with an gaussian, which damping is gb.
  if itype .eq. 0 data are real
  if itype .eq. 1 data are complex
 
 
 </PRE>
<A NAME="gcolor">
 <H3>gcolor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gcolor.for"> /usr/local/gifa/source/gcolor.for </A> 
 <PRE>       subroutine gcolor(vd_id,col_ind)
  IN	: vd_id,col_ind
 
  vd_id : id of the window
  col_ind : color index
  set the gc for the color of the window
  1:white 2:red  3:orange 4:yellow
  5:green 6:cian 7:blue   8:purple  9:black
 
 </PRE>
<A NAME="genfid2">
 <H3>genfid2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/genfid2.for"> /usr/local/gifa/source/genfid2.for </A> 
 <PRE> 	subroutine genfid2 (fid,si1,si2,tabindex,inten,
      $          depchim,largeur,borne,ntachefen,sw1,sw2)
 
  IN	: si1,si2,tabindex,inten,depchim,largeur,borne,ntachefen,sw1,sw2
  OUT	: fid
 
  generate a 2D fid from the spectral parameters
 
 </PRE>
<A NAME="gestion_bouton">
 <H3>gestion_bouton</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void gestion_bouton(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int             vd_id;
 XEvent          *evt;      /*  data from widget class  */
 /*
 	Gere l'ensemble des appels souris et clavier
 	pour le zoom
 */
 </PRE>
<A NAME="get1d_1d">
 <H3>get1d_1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get1d_1d(valmi,valma,err)
  OUT   : valmi,valma,err
 
  gets coordinates for a line
  1D -> 1D
 
 </PRE>
<A NAME="get1d_gene">
 <H3>get1d_gene</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get1d_gene (lf1,ur1,valmax,err)
 
  IN    : valmax
  OUT   : err,lf1,ur1
  used for the GIFA cache interface to enter a spectral interval;
  preset the coordinates, ask the user, and verify coherence
 
 </PRE>
<A NAME="get2d_1d">
 <H3>get2d_1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get2d_1d(axis,indexe,valmi,valma,err)
  INOUT : axis, indexe
  OUT   : valmi,valma,err
 
  gets coordinates for a line from a 2D.
  2D -> 1D
 
 </PRE>
<A NAME="get2d_2d">
 <H3>get2d_2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get2d_2d(lf1,lf2,ur1,ur2,err)
 
  INOUT : axis,index
  OUT   : lf1,lf2,ur1,ur2,err
  gets coordinates for a plane from a 2D.
  2D -> 2D
 </PRE>
<A NAME="get2d_gene">
 <H3>get2d_gene</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get2d_gene(lf1,lf2,ur1,ur2,max1,max2,err)
  IN    : max1,max2
  OUT   : lf1,lf2,ur1,ur2,err
  used for the GIFA cache interface to enter a 2D spectral interval;
  preset the coordinates, ask the user, and verify coherence
 
 </PRE>
<A NAME="get3d_1d">
 <H3>get3d_1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get3d_1d(axis,indexea,indexeb,valmi,valma,err)
  INOUT : axis,indexea,indexeb
  OUT   : valmi,valma,err
 
  gets coordinates for a line from a 3D.
  3D -> 1D
 
 </PRE>
<A NAME="get3d_2d">
 <H3>get3d_2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get3d_2d(axis,index,lf1,lf2,ur1,ur2,err)
 
  INOUT : axis,index
  OUT   : lf1,lf2,ur1,ur2,err
 
  gets coordinates for a plane from a 3D.
  3D -> 2D
 
 </PRE>
<A NAME="get3d_3d">
 <H3>get3d_3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/c_inter.for"> /usr/local/gifa/source/c_inter.for </A> 
 <PRE>       subroutine get3d_3d(lf1,lf2,lf3,ur1,ur2,ur3,err)
  OUT   : lf1,lf2,lf3,ur1,ur2,lf3,err
  gets coordinates for a subcube from a 3D.
  3D -> 3D
 
 </PRE>
<A NAME="get_currunit">
 <H3>get_currunit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine get_currunit(retunit,l,axe)
  IN : axe
  OUT : retunit,l
 
  returns current unit along axe
 </PRE>
<A NAME="get_var_3d">
 <H3>get_var_3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine get_var_3d(retalpha,retbeta,retgama,retsc3d,retz0,
      *                   retox,retoy,retoz,retdx3d,retdy3d,retdz3d)
 </PRE>
<A NAME="get_zoom_coord">
 <H3>get_zoom_coord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine get_zoom_coord(llx,lly,urx,ury,sizey,sizex)
  returns the current zoom coord.
 </PRE>
<A NAME="getbit">
 <H3>getbit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine getbit(a,bit)
  IN	: bit
  OUT	: a
  SIDE	: offset, buffer
  get the the word "a" of length "bit" bits using variables offset and buffer
  in common
 </PRE>
<A NAME="getbool2">
 <H3>getbool2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getbool2(b,help_file,err)
  IN	: help_file
  INOUT	: b
  OUT	: err
  SIDE	: param
 
  reads a boolean value, based on getstring2
 
  the user is prompted for the initial value of b, a return will let 
  b unchanged
  legal entries are y (yes) n (no) c (cancel) h (help) the latter will 
  print "help_file"
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 </PRE>
<A NAME="getcol">
 <H3>getcol</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools2d.for"> /usr/local/gifa/source/tools2d.for </A> 
 <PRE>        subroutine getcol(col,mat,number,size1,size2)
  IN	: mat,number,size1,size2
  OUT	: col
 
       read-in a column from matrix "mat" at index "number"
  and put it in  "col"
 
 </PRE>
<A NAME="getcoord">
 <H3>getcoord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getcoord(coordi,dd,err)
  INOUT	: coordi
  IN	: dd
  OUT	: err
  SIDE	: param
 
  getcoor is the integer version of getcoorf
  (i.e. coordi is integer instead of rel)
 </PRE>
<A NAME="getcoordf">
 <H3>getcoordf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getcoordf(coord,dd,err)
  INOUT	: coord
  IN	: dd
  OUT	: err
  SIDE	: param
 
  reads a coordinate on the spectrum value, based on getstring2
 
  coord is the return value in index, dd is the axis to use
  entry of the form
   123 or 123i for index;   123h 123p 123s for hertz ppm and second
 
 </PRE>
<A NAME="getcube">
 <H3>getcube</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>        subroutine getcube(zz1l,zz2l,zz3l,zz1u,zz2u,zz3u,err)
  INOUT zz1l,zz2l,zz3l,zz1u,zz2u,zz3u,err
  get coordinates for a subcube in a 3D
 
 </PRE>
<A NAME="getdiag">
 <H3>getdiag</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/getdiag.for"> /usr/local/gifa/source/getdiag.for </A> 
 <PRE>         subroutine getdiag(diag,size,smx,si1,si2)
  IN	: size,smx,si1,si2
  OUT	: diag
  this subroutine extracts the main diagonal from the 2D array smx
  and puts it into the array diag
 
 </PRE>
<A NAME="getdiag2d">
 <H3>getdiag2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/getdiag.for"> /usr/local/gifa/source/getdiag.for </A> 
 <PRE>         subroutine getdiag2d(diag,size,smx,si1,si2,si3,zz)
  IN	: size,smx,si1,si2,si3,zz
  OUT	: diag
  this subroutine extracts one of the 3 diagonal planes form the 3D 
  array smx and puts it into the array plane2d
  zz determines which plane to be extracted
  zz = 3 : 
  zz = 5 : 
  zz = 6 : 
 
 </PRE>
<A NAME="getdim">
 <H3>getdim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getdim(dd,err)
  INOUT	: dd
  OUT	: err
  SIDE	: param
 
  reads a dim axis, based on getstring2
 
  legal entries are F1 F2 F3 F12 F13 F23 F123
 
 </PRE>
<A NAME="getdouble2">
 <H3>getdouble2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getdouble2(x,err)
  INOUT	: x
  OUT	: err
  SIDE	: param
 
  reads a real value, based on getstring2
 
  the user is prompted for the initial value of x, a return will let 
  x unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 </PRE>
<A NAME="getenum2">
 <H3>getenum2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getenum2(st,list,err)
  IN	: list
  INOUT	: st
  OUT	: err
  SIDE	: param
 
  reads a string value, which value is chosen in list (blank separated).
  based on getstring2
 
  test are case insensitive - value is returned in uppercase !
 
  limited to 32 values of length 32 !!!
 
 </PRE>
<A NAME="getfreq2">
 <H3>getfreq2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getfreq2(x,sw,err)
  IN	: sw
  INOUT	: x
  OUT	: err
  SIDE	: param
 
  reads a frequency value, based on getstring2
 
  the user is prompted for the initial value of x, a return will let 
  x unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 
 </PRE>
<A NAME="gethome">
 <H3>gethome</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine gethome(st)
  OUT	: st
  This subroutine returns the value of the $HOME directory
 </PRE>
<A NAME="getinput">
 <H3>getinput</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getinput(ppt,err)
  IN	: ppt
  OUT	: error
  SIDE	: param
  get direct input for gifa, either user (input=20; stdin) or
  in a file (unit>20).
  ppt == 0 prompted
  ppt == 1 if continuation line
  ppt == 2 no prompt
 </PRE>
<A NAME="getint">
 <H3>getint</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine getint(x)
  INOUT	: x
 
    get a int from input
  basic I/O routine, prompts the user with x, no change if return
 
     accepts input such as 16k
 
 </PRE>
<A NAME="getint2">
 <H3>getint2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getint2(x,err)
  INOUT	: x
  OUT	: err
  SIDE	: param
 
  reads a integer value, based on getstring2
 
  the user is prompted for the initial value of x, a return will let 
  x unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 </PRE>
<A NAME="getmaskno">
 <H3>getmaskno</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       function getmaskno(crdx,crdy)
 
  returns the peak number of the amoeba to which the pixel belongs.
 
  IN	: crdx,crdy
 
 </PRE>
<A NAME="getnumber">
 <H3>getnumber</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readtc3d.for"> /usr/local/gifa/source/readtc3d.for </A> 
 <PRE>        subroutine getnumber(line,spec,i,j,size1,size2,size3,
      *                  fact,error)
 
 </PRE>
<A NAME="getout2">
 <H3>getout2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getout2(st,err)
  INOUT	: st
  OUT	: err
  SIDE	: param
 
  reads the name of an output device, based on getstring2
 
  legal entries are *S (screen) *PR (printer) *PL (plotter) or file_name
 
 </PRE>
<A NAME="getplane">
 <H3>getplane</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/getplane.for"> /usr/local/gifa/source/getplane.for </A> 
 <PRE>        subroutine getplane(plane,cube,
      *                     size1,size2,size3,index)
  IN	: cube,size1,size2,size3,index
  OUT	: plane
 
  extracts the plan "index" orthogonal to F1 dim from "cube"
 
 
 </PRE>
<A NAME="getplane2">
 <H3>getplane2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/getplane.for"> /usr/local/gifa/source/getplane.for </A> 
 <PRE>        subroutine getplane2(plane,cube,
      *                     size1,size2,size3,index) 
  IN	: cube,size1,size2,size3,index
  OUT	: plane
 
  extracts the plan "index" orthogonal to F2 dim from "cube"
 
 
 </PRE>
<A NAME="getplane3">
 <H3>getplane3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/getplane.for"> /usr/local/gifa/source/getplane.for </A> 
 <PRE>        subroutine getplane3(plane,cube,
      *                     size1,size2,size3,index) 
  IN	: cube,size1,size2,size3,index
  OUT	: plane
 
  extracts the plan "index" orthogonal to F3 dim from "cube"
 
 
 </PRE>
<A NAME="getreal">
 <H3>getreal</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine getreal(x)
  INOUT	: x
 
    get a real from input
  basic I/O routine, prompts the user with x, no change if return
 
 </PRE>
<A NAME="getreal2">
 <H3>getreal2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getreal2(x,err)
  INOUT	: x
  OUT	: err
  SIDE	: param
 
  reads a real value, based on getstring2
 
  the user is prompted for the initial value of x, a return will let 
  x unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 </PRE>
<A NAME="getrect">
 <H3>getrect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getrect(lf2,lf1,ur2,ur1,err)
  INOUT	: lf2,lf1,ur2,ur1
  OUT	: err
  gets coordinates for a rectangle on the data set.
  uses the last clicked data if any available in clickt()
  lf2=lf2 lf1=lf1
 </PRE>
<A NAME="getstring">
 <H3>getstring</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine getstring(s)
  INOUT	: s
 
    get a string from input
  basic I/O routine, prompts the user with s, no change if return
 
 </PRE>
<A NAME="getstring2">
 <H3>getstring2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getstring2(st,err)
  INOUT	: st
  OUT	: err
  SIDE	: param
 
   will read either word 'quotted string' "quotted string" $variable
                    (arithmetic_exp) $_ <filename  %  %%
             ( filename can be any of the other syntaxes )
  the user is prompted for the initial value of st, a return will let 
  st unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
 
 
 </PRE>
<A NAME="getunit2">
 <H3>getunit2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine getunit2(unit,err)
  INOUT	: unit
  OUT	: err
  SIDE	: param
 
  reads a unit value, based on getstring2
 
  the user is prompted for the initial value of unit, a return will let 
  unit unchanged
  Reads in the input stream (either file or interactive)
  if the line is finished on file, redirected to the user
  legal entries are (h (Hz) p (ppm) i (index) s (seconds)
 
 </PRE>
<A NAME="getvar">
 <H3>getvar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine getvar(vname,context,value,err)
  IN	: vname,context
  OUT	: value,err
       get the value of the variable called name in the context "context"
  search order is : in current context
                    in global context (20)
                    as predefined internal GIFA variables
 
 
  added in-line documentation on 20/05/99 MAD
 
 </PRE>
<A NAME="getvcontext">
 <H3>getvcontext</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine getvcontext(vcont)
 </PRE>
<A NAME="getwdir">
 <H3>getwdir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine getwdir(st)
  OUT	: st
  This subroutine returns the value of the current workingdirectory
 </PRE>
<A NAME="gifa">
 <H3>gifa</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gifa.for"> /usr/local/gifa/source/gifa.for </A> 
 <PRE>                         program gifa
  main entry point
 </PRE>
<A NAME="gifaerr">
 <H3>gifaerr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine gifaerr(st)
 
  used for error msg
 
 </PRE>
<A NAME="gifaout">
 <H3>gifaout</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine gifaout(a)
  IN	: a
 
  this subroutine permits to print a string on the same time on the screen
  and on the log file (unit journal), protect the line with a ";"
 
 </PRE>
<A NAME="gifaoutc">
 <H3>gifaoutc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine gifaoutc(st)
 
  used to 'gifaout' form the C level
 
 </PRE>
<A NAME="gifaouti">
 <H3>gifaouti</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine gifaouti(tline,i)
  IN	: tline,i
 
  this subroutine permits to print a string followed by an integer
  on the same time on the screen and on the log file (unit journal)
 
 </PRE>
<A NAME="gifaoutr">
 <H3>gifaoutr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine gifaoutr(tline,zz)
  IN	: tline,zz
 
  this subroutine permits to print a string followed by a real
  on the same time on the screen and on the log file (unit journal)
 
 </PRE>
<A NAME="goto_endif">
 <H3>goto_endif</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gifshell.for"> /usr/local/gifa/source/gifshell.for </A> 
 <PRE>       subroutine goto_endif(job,retest,err)
  IN	: job
  OUT	: retest, err
 
  if job = 1 search for next ENDIF    ( jump after else - no else/elsif permitted)
  if job = 2 search for next ELSE / ELSIF / ENDIF ( jump after false if )
        retest = 0 means was ELSE / ENDIF
        retest = 1 means was ELSIF
  if job = 3 search for next ENDIF    ( jump after 'else' elsif )
  if job = 4 search for next ENDWHILE
  if job = 5 search for next ENDFOR
 
  updates currline, param
 
 </PRE>
<A NAME="goto_label">
 <H3>goto_label</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gifshell.for"> /usr/local/gifa/source/gifshell.for </A> 
 <PRE>       subroutine goto_label(label,err)
 
  jumps to label - used by GOTO
 
  updates currline, param, etc..
 
 </PRE>
<A NAME="goto_line">
 <H3>goto_line</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/gifshell.for"> /usr/local/gifa/source/gifshell.for </A> 
 <PRE>        subroutine goto_line(line,err)
  IN	: line
 
  jump to line "line" in the current input file
  used by the GIFA control langage
 
 </PRE>
<A NAME="grid1">
 <H3>grid1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/grid.for"> /usr/local/gifa/source/grid.for </A> 
 <PRE>       subroutine grid1(pl_id,cx,cy,n)
  IN	: pl_id,cx,cy,n
  plots a grid of n horizontal stripes on a cx by cy square
 </PRE>
<A NAME="grid2">
 <H3>grid2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/grid.for"> /usr/local/gifa/source/grid.for </A> 
 <PRE>       subroutine grid2(pl_id,cx,cy,n)
  IN	: pl_id,cx,cy,n
  plots a grid of n vertical stripes on a cx by cy square
 
 </PRE>
<A NAME="hash">
 <H3>hash</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>       function hash(st,l)
  IN	: st,l
 
  implements a hash function, "st(l)" -> integer.
  this one comes from Chris Torek, said to be very good!
 
  hash(st,l) can eventually be used as a generic hash function
 
 </PRE>
<A NAME="hash_find">
 <H3>hash_find</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/hash_wrap.for"> /usr/local/gifa/source/hash_wrap.for </A> 
 <PRE>       subroutine hash_find(var, context, dim, zz1, zz2, zz3,
      *                   id, bestdist, error)
   returns in id the peak hashed in var/context
    which is matched by coordinates z1 ( z2 ( z3 ) )
    err will non zero on return if an error occured :
 
  version temporaire, calcul sans table de hash
 
 </PRE>
<A NAME="hdiavect">
 <H3>hdiavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  hdiavect(a,b,c,size1,size2)
  IN	: b,c,size1,size2
  OUT	: a
 
  HDIAVECT(A,B,C,N1,N2) multiply matrices hypercomplex (size1,size2) B and C
  point by point, and put the result into A
 
      i.e. a(i) = b(i)*c(i)       where * is the 2D hypercomplex product
 
 </PRE>
<A NAME="hdist">
 <H3>hdist</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/hash_wrap.for"> /usr/local/gifa/source/hash_wrap.for </A> 
 <PRE>       subroutine hdist(value,dim,zz1,zz2,zz3,dist,err)
  IN :  value,di,zz1,zz2,zz3
  OUT : dist,err
 
  computes the distance between zz1,zz2,zz3
  and the (dim) coordinates coded in string st
 
 </PRE>
<A NAME="hphase">
 <H3>hphase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/hphase.for"> /usr/local/gifa/source/hphase.for </A> 
 <PRE>       subroutine hphase(rspec,p0,p1,n)
  IN	: p0,p1,n
  INOUT	: rspec
   this subroutine applies a NMR-type phase correction to the REAL
  data A(i) of length N, with p0 as zero-order correction and p1 as first-order
  correction. P0 and P1 are both in degree.
  First the imaginary part is reconstructed from A: A is inverse Fourier 
  transformed,(real to complex), and dephased by 90 degrees, then Fourier 
  transformed (complex to real). The result is considered as the imaginary
  part of A: B
   
  then  C(i)=(A(i),B(i)) is (complex) multiplied by exp(2*pi*(P0 + P1*(i-1/N))
  to give C': the result of this subroutine is the real part of C'
 
 
 </PRE>
<A NAME="hphase2d">
 <H3>hphase2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/hphase2d.for"> /usr/local/gifa/source/hphase2d.for </A> 
 <PRE>       subroutine hphase2d(tdata,size1,size2,p0,p1,direc)
  IN	: size1,size2,p0,p1,direc
  INOUT	: tdata
   This subroutine applies a NMR-type phase correction to the hypercomplex
  data tdata(i,j) of length si1im,si2im, with p0 as zero-order correction and
  p1 as first-order correction. P0 and P1 are both in degree. If Direc is
  1 correction is applied in Dim 1 (vertical), if direc is 2, correction
  is applied in dim 2
 
 </PRE>
<A NAME="htoi">
 <H3>htoi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function htoi(hertz,size,specw,off)
  integer version of hotir (i.e. index is integer)
 </PRE>
<A NAME="htoir">
 <H3>htoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function htoir(hertz,size,specw,off)
  IN	: hertz,size,specw,off
 
  returns index from hertz value
 
 </PRE>
<A NAME="hyste">
 <H3>hyste</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lisse.for"> /usr/local/gifa/source/lisse.for </A> 
 <PRE>       subroutine hyste(imaged,images,size,pr)
  used by linecor2
 
 
 </PRE>
<A NAME="i2dotvect">
 <H3>i2dotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  i2dotvect(index,d,a,b,size)
  IN	: index,a,b,size
  OUT	: d
 
    This subroutine performs the dot product between vectors
  a(index()) and b(index())
 
 </PRE>
<A NAME="iaddvect">
 <H3>iaddvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  iaddvect(index,arrayout,B,C,l,size)
  IN	: index,B,C,l,size
  OUT	: arrayout
    This subroutine put B + l*C(index()) into arrayout,
  A, B and C may be equal
 
 </PRE>
<A NAME="icopsvect">
 <H3>icopsvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  icopsvect(index,a,b,size,sizei)
  IN	: index,b,size
  OUT	: a
 
    This subroutine copy b(index(i)) into a
    a and b are strings
 
 </PRE>
<A NAME="icopusvect">
 <H3>icopusvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  icopusvect(index,a,size,sizei)
  IN	: index,size
  INOUT	: a
 
    This subroutine copy a(index(i)) into a
    a is a string
 
 </PRE>
<A NAME="icopvect">
 <H3>icopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  icopvect(index,a,b,size,sizei)
  IN	: index,b,size
  OUT	: a
 
    This subroutine copy b(index(i)) into a
 
 </PRE>
<A NAME="idiavect">
 <H3>idiavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  idiavect(index,a,b,c,size)
  IN	: index,b,c,size
  OUT	: a
 
    This subroutine multiplies the vector C(index()) by the diagonal matrix, whose
  diagonal is in B(index()), and put it in A
 
 </PRE>
<A NAME="idotvect">
 <H3>idotvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  idotvect(index,d,a,b,size)
  IN	: index,a,b,size
  OUT	: d
 
    This subroutine performs the dot product between vectors
  a(index()) and b()
 
 </PRE>
<A NAME="imltvect">
 <H3>imltvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  imltvect(index,a,b,l,size)
  IN	: index,b,l,size
  OUT	: a
    This subroutine multiplies vector B(index()) by l and put it in A(index())
 
 </PRE>
<A NAME="index2winr">
 <H3>index2winr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine index2winr(retval,indexval,dime,axe)
 
  IN :  indexval (index unit), axe (1:f1, 2:f2), dime
  OUT:  retval  (window unit 0-1)
 
    index => window 
  modif MAD jul `99 (added dime)
 
 </PRE>
<A NAME="init_approx">
 <H3>init_approx</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/approx.for"> /usr/local/gifa/source/approx.for </A> 
 <PRE>       subroutine init_approx(size)
 
  IN	: size
  SIDE	: base
  initialize buffer for polynomial base line correction
  polynomial base depends on global var approx
       
 </PRE>
<A NAME="init_cadre_icon">
 <H3>init_cadre_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void init_cadre_icon()
 </PRE>
<A NAME="init_color">
 <H3>init_color</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int init_color()
 </PRE>
<A NAME="init_input_iconCB">
 <H3>init_input_iconCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void init_input_iconCB(w, client_data, evt)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XEvent          *evt;
 </PRE>
<A NAME="init_timer">
 <H3>init_timer</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine init_timer
  This subroutine is used to access the unix internal clock.
  Init_timer initializes the timer for subsequent use by show_timer.
 </PRE>
<A NAME="initclassif">
 <H3>initclassif</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/nuee.for"> /usr/local/gifa/source/nuee.for </A> 
 <PRE>       subroutine initclassif(verbose,src,origine,size,classe,
      *nbclasse,rep,nbrep,nbpt)
 
  used by linecor2
 
 </PRE>
<A NAME="initcolor">
 <H3>initcolor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_color.c"> /usr/local/gifa/source/X_color.c </A> 
 <PRE> void initcolor(flag,display,colortable,colormap,visual,cursor1,cursor2)
 Display *display;
 int flag,colortable[];
 Colormap *colormap;
 Visual **visual;
 Cursor cursor1,cursor2;
 
 </PRE>
<A NAME="initcolortable">
 <H3>initcolortable</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_color.c"> /usr/local/gifa/source/X_color.c </A> 
 <PRE> void initcolortable(r,g,b,bg1,fg1,bg2,fg2)
 unsigned short r[NColor],g[NColor],b[NColor];
 XColor *bg1,*fg1,*bg2,*fg2;
 
 
 </PRE>
<A NAME="initdefaultcolor">
 <H3>initdefaultcolor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_color.c"> /usr/local/gifa/source/X_color.c </A> 
 <PRE> void initdefaultcolor(r,g,b,bg1,fg1,bg2,fg2)
 unsigned short r[NColor],g[NColor],b[NColor];
 XColor *bg1,*fg1,*bg2,*fg2;
 
 </PRE>
<A NAME="initgraytable">
 <H3>initgraytable</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_color.c"> /usr/local/gifa/source/X_color.c </A> 
 <PRE> void initgraytable(r,g,b,bg1,fg1,bg2,fg2)
 unsigned short r[NColor],g[NColor],b[NColor];
 XColor *bg1,*fg1,*bg2,*fg2;
 
 </PRE>
<A NAME="initgull">
 <H3>initgull</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/initgull.for"> /usr/local/gifa/source/initgull.for </A> 
 <PRE>       subroutine initgull
  initialises the parameters and memory for MaxEnt run
 
 </PRE>
<A NAME="initprm1d">
 <H3>initprm1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine initprm1d(nbp,err)
 
  INOUT : nbp, err
 
  The following subroutine initializes the 4*nbpic paramaters (prm)
  that will have to be fitted in the 1d spectrum
 
 
 
 </PRE>
<A NAME="initprm2d">
 <H3>initprm2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine initprm2d(nbp,code,err)
 
  IN : code
  INOUT : nbp, err
 
  The following subroutine initializes the 6*nbpic paramaters (prm)
  that will have to be fitted in the 2d spectrum
 
  code is the size (in F2) of the area that will used for the fit
 
 
 </PRE>
<A NAME="input_iconCB">
 <H3>input_iconCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void input_iconCB(w, client_data, evt)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XEvent       	*evt;
 </PRE>
<A NAME="input_picCB">
 <H3>input_picCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void input_picCB(w, client_data, event)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer      event ;      /*  data from widget class  */
 
 </PRE>
<A NAME="integ1">
 <H3>integ1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/integ1.for"> /usr/local/gifa/source/integ1.for </A> 
 <PRE>        subroutine integ1(tab,rap,monte,min,
      & taille,zq,signpic,shift,noise)
  IN	: tab,rap,monte,min,taille,zq,signpic,shift,noise
  OUT	: peak1d
  realizes the integration of the 1D peak table
 
 </PRE>
<A NAME="intpic">
 <H3>intpic</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intpic.for"> /usr/local/gifa/source/intpic.for </A> 
 <PRE>        subroutine intpic(tab,masktab,num,vol,poinpic,rap,mon,stop,
      *      taille1,taille2,ligb,ligh,limg,limd,com,signpic,zq)
  IN	: tab,num,poinpic,rap,mon,stop,taille1,taille2,com,signpic,zq
  INOUT	: masktab
  OUT	: vol,ligb,ligh,limg,limd
 
  realizes the intregration of peak "num" as found in peak2d table
  and returns the volume "vol", the extention, and update the amoeba
  "masktab"
 </PRE>
<A NAME="intpic1d">
 <H3>intpic1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intpic1d.for"> /usr/local/gifa/source/intpic1d.for </A> 
 <PRE>        subroutine intpic1d(tab,num,vol,poinpic,rap,mon,stop,
      *                   taille,colg,cold,signpic,zq)
  IN	: tab,num,poinpic,rap,mon,stop,taille,signpic,zq
  OUT	: vol,colg,cold
  realizes the intregration of peak "num" as found in peak1d table
  and returns the volume "vol", the extention
 
 </PRE>
<A NAME="intrec1d">
 <H3>intrec1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intrec.for"> /usr/local/gifa/source/intrec.for </A> 
 <PRE>       subroutine intrec1d(vect,si,somme,nbpoint,err)
  IN	: vect,si,err
  OUT	: somme,nbpoint
 
  computes the sum of the points in an area of the 1D data "vect"
  area is prompted from the user,
 </PRE>
<A NAME="intrec2d">
 <H3>intrec2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intrec.for"> /usr/local/gifa/source/intrec.for </A> 
 <PRE>       subroutine intrec2d(smx,si1,si2,somme,nbpoint,err)
  IN    : smx,si1,si2,err
  OUT   : somme,nbpoint
 
  computes the sum of the points in an area of the 2D data "smx"
  area is prompted from the user,
 </PRE>
<A NAME="intsct">
 <H3>intsct</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/stplot.for"> /usr/local/gifa/source/stplot.for </A> 
 <PRE>       subroutine intsct(x1,x2,y11,y12,y21,y22,xx,yy)
  IN	: x1,x2,y11,y12,y21,y22
  OUT	: xx,yy
 
  used by stplot
      intsct calculates intersection pt of 2 lines with endpoints
      (x1,y11)->(x2,y12)   and   (x1,y21)->(x2,y22)
      and returns this point in xx,yy
 
 </PRE>
<A NAME="intvect">
 <H3>intvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine intvect(array,size,itype)
  IN	: size,itype
  INOUT	: array
  INTVECT(A,N,T) Compute the running sum of the vect A
                 i.e. A'(I) = Sum( j=1,I-1;A(j) )
                 if T=0 data are real, if T=1 , data are complex
 </PRE>
<A NAME="inverse">
 <H3>inverse</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/roots.for"> /usr/local/gifa/source/roots.for </A> 
 <PRE>       subroutine inverse (zno,zni,order)
  IN	: zni,order
  OUT	: zno
 
  part of the LPSVD package
 
  Calculate the inverse conjugates of the roots of polynome
  complex*16 zno(order) : output roots 
  complex*16 zni(order) : input roots 
  integer order : degree of the polynome
 
 </PRE>
<A NAME="invnorm">
 <H3>invnorm</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine invnorm (arrayout,arrayin,size,scale)
  IN	: arrayin,size,scale
  OUT	: arrayout
 
  INVNORM (B,A,N,L) transform the vector A(N) complex into the vector B(N) real
  composed of the inverse of complex norm of elements of A multiplied by the
  real L
  
 </PRE>
<A NAME="iprpvect">
 <H3>iprpvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  iprpvect(a,l,size)
  IN	: l,size
  OUT	: a
 
  IPRPVECT(A,L,N) propagates scalar L integer into vector A integer
  
 
 </PRE>
<A NAME="isalphanum">
 <H3>isalphanum</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       function isalphanum(st,n)
  IN	: st,n
     true if st is a alpha numeral or _
 
 </PRE>
<A NAME="iscopvect">
 <H3>iscopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine iscopvect (arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  
  ISCOPVECT(A,B,N) copy the real vector B, of size N into integer vector A 
 
 </PRE>
<A NAME="isnumeral">
 <H3>isnumeral</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       function isnumeral(st,n)
  IN	: st,n
     true if st is a numeral value
 
 </PRE>
<A NAME="itergull">
 <H3>itergull</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/itergull.for"> /usr/local/gifa/source/itergull.for </A> 
 <PRE>       subroutine itergull(verbose)
  INT	: verbose
 
  realizes a single iteration of the MaxEnt run
 </PRE>
<A NAME="itoh">
 <H3>itoh</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itoh(index,size,specw,off)
  integer version of itohr (i.e. index is integer)
 </PRE>
<A NAME="itohr">
 <H3>itohr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itohr(index,size,specw,off)
  IN	: index,size,specw,off
 
  returns hertz from index value
 
 </PRE>
<A NAME="itok">
 <H3>itok</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itok(index,size,kmin,kmax,kfact)
  integer version of itokr
 </PRE>
<A NAME="itokr">
 <H3>itokr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itokr(index,size,kmin,kmax,kfact)
  IN	: index,size,kmin,kmax,kfact
 
  returns damping from index value
 
 
 </PRE>
<A NAME="itop">
 <H3>itop</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itop(index,size,specw,off,freq)
  integer version of itopr (i.e. index is integer)
 </PRE>
<A NAME="itopr">
 <H3>itopr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itopr(index,size,specw,off,freq)
  IN	: index,size,specw,off,freq
 
  returns ppm from index value
 
 </PRE>
<A NAME="itos">
 <H3>itos</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itos(index,specw)
  integer version of itosr (i.e. index is integer)
 </PRE>
<A NAME="itosr">
 <H3>itosr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itosr(index,specw)
  IN	: index,size,specw
 
  returns second from index value
 
 </PRE>
<A NAME="itot">
 <H3>itot</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itot(index,tab,sztab)
  integer version of itotr
 </PRE>
<A NAME="itotr">
 <H3>itotr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function itotr(index,tab,sztab)
  IN	: index,tab,sztab
 
  returns tabulated from index value
 
  ASSUMES regularly spaced tabulated values
 
 
 </PRE>
<A NAME="j2d">
 <H3>j2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine j2d(smx,size1,size2,j1,j2,type,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by a sinusoide of frequency j1,j2.
  type is A or P for sine or cosine
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="jconnect">
 <H3>jconnect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine jconnect(st,err)
  IN	: st
  OUT	: err
 
  creates a file called st as the new journaling file
  if an alternate journaling is aready opened, it is first closed
 
 	  implicit none
 </PRE>
<A NAME="jmult">
 <H3>jmult</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/jmult.for"> /usr/local/gifa/source/jmult.for </A> 
 <PRE>       subroutine jmult(array,size,j,type,itype)
  IN	: size,j,type,itype
  INOUT	: array
 
  multiply the data "array" by a sinusoid of freq j
  itype 0 or 1 : real or complex
  type A or P : sine or cosine
 
 </PRE>
<A NAME="ktoi">
 <H3>ktoi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ktoi(k,size,kmin,kmax,kfact)
  integer version of ktoir
 </PRE>
<A NAME="ktoir">
 <H3>ktoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ktoir(k,size,kmin,kmax,kfact)
  IN	: k, size,kmin,kmax,kfact
 
  returns index from damping value
 
  dampings are exponentially spaced Kmin x kfact .. Kmax  x kfact
  =>     k = Kmin*exp(cst*(i-1))
         log(k) = log(Kmin) + cst*(i-1)
         cst = (Log(Kmax)-log(Kmin)) / (size-1)
         i = 1+ ( log(k)-log(kmin) ) / cst
 
 </PRE>
<A NAME="laplace">
 <H3>laplace</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine laplace(A,n,B,p,KK1,KK2,Tmax)
  performs the Laplace transform between dampings KK1 and KK2
  i.e. given a series of damping amplitudes,
       exponentially spaced between KK1 and KK2
       the time response F(t) 0..Tmax is computed
            over linearly sampled time points
 
      A(N) : the array of damping amplitudes
      B(P) : the computed time response
 
  IN :  N, P, A(N), KK1, KK2, Tmax
  OUT : B(P)
 
 </PRE>
<A NAME="leading">
 <H3>leading</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine leading(st)
  INOUT	: st
 
   Removes leading blanks from the string st
 
 </PRE>
<A NAME="lect">
 <H3>lect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lect.for"> /usr/local/gifa/source/lect.for </A> 
 <PRE>         subroutine lect(natomfen,ntachefen,intens,tabindex,
      $                   borne,depchim,largeur,s1,s2,nerr)
 
            subroutine de saisie des donnees
 
        variables:
                  y          dimension des tableaux parcourant        
 		             les taches
                  z          dimension des tableaux parcourant    
                             les atomes
                  depchim    deplacement chimique
                  largeur    largeur des raies a demi hauteur
                  freq       frequence du spectro
                  inten      intensite d une tache
                  natome     nombre d atome
                  tabindex   tableau contenant le rang des atomes
                             de la tache k
                  ntache     nombre de taches
                  natomfen   nombre d'atome dans la fenetre
                  datadec    nom du fichier de deplacement chimique
                  dataint    nom du fichier corma
                  datacoor   nom du fichier des coordonnees des 
                             taches
                  numresidu  numero du residu
                  residu     nom du residu
                  atomnres   atome et numero du residu
                  s1         taille dimension 1 du fid
                  s2         taille dimension 2 du fid
                  ndiag      nombre de tache sur la diagonale
 
  ****************************************************************            
 
 </PRE>
<A NAME="leftprod">
 <H3>leftprod</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  leftprod(vout,mat,vin,n,m)
  IN	: mat,vin,n,m
  OUT	: vout
  
  computes the result of applying a left product with the
  matrix mat(n x m) on the vect vin(m x 1)
  i.e.  vout(n x 1) = mat(n x m) * vin(m x 1)
 
 </PRE>
<A NAME="levenberg">
 <H3>levenberg</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/levenberg.for"> /usr/local/gifa/source/levenberg.for </A> 
 <PRE>       subroutine levenberg (x,y,wndw,sizdat,sig,prm,npc,
      *                      permut,nactif,chi2,toler,nbiter,
      *                      func,dfunc,covar,verbose,debug,err)
  IN	: x,y,wndw,sizdat,sig,npc, permut,nactif,toler,nbiter,func,dfunc,verbose,debug
  INOUT	: prm
  OUT	: chi2,err,covar
 
  fits the data x(sizdat) / y(sizdat) with the levenberg-marquardt method
  with the 1d function func(size,prm(size),x,y)
  of derivative        dfunc(size,prm(size),x,dy(size))
  parameters are stored in prm(npc).
  only the parameters  prm(permut(1:nactif)) will be modified
  where permut(1:nactif) is a valid partial permutation on 1:npc
 
  covar(npc,npc) should be provided to compute covariance.
 
  standard deviation (sigma) of point x(i)/y(i) is sig/wndw(i)
  i.e. window is a descriptor of the quality of the data.
  typically window(i) holds 1.0 for sigma(i) = sig => stanard point
                            0.0 for sigma(i) = inf => no good signal there
 
  output is found in prm(), result of the fit is chi2
  
  exit condition is iter>=nbiter or last move on chi2 < toler
 
  on return, covar(i,j) contains the covariance matrix.
  covar(i,i) is the square of the error on prm(i)
 </PRE>
<A NAME="lhare">
 <H3>lhare</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lhare.for"> /usr/local/gifa/source/lhare.for </A> 
 <PRE>        subroutine lhare(tdata,size,name,noise,error)
  INOUT	: name
  OUT	: tdata,size,noise,error
 
  reads a file called "name" in 1D D.Hare format
 </PRE>
<A NAME="lhare2d">
 <H3>lhare2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lhare2d.for"> /usr/local/gifa/source/lhare2d.for </A> 
 <PRE>        subroutine lhare2d(tdata,dim1,dim2,name,error,noise)
  INOUT	: name
  OUT	: tdata,dim1,dim2,noise,error
 
  reads a file called "name" in 2D D.Hare format
 
 </PRE>
<A NAME="lhare3d">
 <H3>lhare3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lhare3d.for"> /usr/local/gifa/source/lhare3d.for </A> 
 <PRE>        subroutine lhare3d(tdata,dim1,dim2,dim3,name,error,noise)
  INOUT	: name
  OUT	: tdata,dim1,dim2,dim3,noise,error
 
  reads a file called "name" in pseudo 3D D.Hare format
 
 </PRE>
<A NAME="limlig">
 <H3>limlig</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/bornepic.for"> /usr/local/gifa/source/bornepic.for </A> 
 <PRE>       subroutine limlig(tablo,si1,si2,no,rap,monte,min,
      *            lig,colsom,lim1,lim2,limlig1,limlig2,signpic,zq)
      
  IN	: tablo,si1,si2,no,rap,monte,min,lig,colsom,lim1,lim2,signpic,zq
  OUT 	: limlig1,limlig2
  used by 2D INTEG
  returns the limits along lines of peak no as defined in peak2d
 
 </PRE>
<A NAME="linecor2">
 <H3>linecor2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/linecor2.for"> /usr/local/gifa/source/linecor2.for </A> 
 <PRE>       subroutine linecor2(debug,verbose,yy)
  IN	: debug,verbose,yy
  SIDE	: depends on DIM
 
  performs polynomial baseline correction
  yy is axis to correct
  yy : 1 or 2 in 2D   / 1, 2, or 3 in 3D
 </PRE>
<A NAME="linecor21d">
 <H3>linecor21d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/linecor2.for"> /usr/local/gifa/source/linecor2.for </A> 
 <PRE>       subroutine linecor21d(verbose,size,indice,portion)
  IN	: verbose,size,indice,portion
  realizes the 1D polynomial baseline correction
 
  called by linecor2
 </PRE>
<A NAME="linecorr">
 <H3>linecorr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/linecorr.for"> /usr/local/gifa/source/linecorr.for </A> 
 <PRE>       subroutine linecorr(array,size,index,szindex,radius,algo)
  IN	: size,index,szindex,radius,algo
  INOUT	: array
 
     This subroutine will correct the base line of the 1D data-set in
  array[size], with a linear correction (will add a linear baseline to the data
  set) or a Spline correction. The base line to be removed is evaluated from the
  szindex points whose indexes are in the table index[szindex], with averaging
  around each points within a area of +/-radius wide. 
    Spline correction supposes that index is ordered in ascending order.
 
  size is at least 3
  szindex is at least 1 (if 1, will remove a horizontal base-line)
  szindex cannot be more than 100.
  radius may be zero or more (less than size!)
  algo is 1 for linear, 2 for spline
 </PRE>
<A NAME="linemini">
 <H3>linemini</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/conjgrad.for"> /usr/local/gifa/source/conjgrad.for </A> 
 <PRE>       subroutine linemini(func1d,p,xi,size,fmini,miter,tol,verb)
  IN	: func1d,xi,size,miter,tol,verb
  OUT	: fmini
  INOUT	: p
  performs a 1D minisation of the real function func1d along one axis, using the
  Brent method. The axis used is xi, the starting point is start
  both are put in common for func1d.
  - func1d(y) : function to minimize
  - p(size) : initial value, returns found minimum in p
  - xi(size) : axis for minimization
  - size : size of the vectors
  - fmini : minimum found
  - miter : number max of iterations for line minisation
  - tol : epsilon of the minimization.
  - verb : if 1, verbose output
 
 </PRE>
<A NAME="linereg">
 <H3>linereg</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/linecorr.for"> /usr/local/gifa/source/linecorr.for </A> 
 <PRE>       subroutine linereg(table,size,la,lb)
  IN	: table,size
  OUT	: la,lb
 
  computes the linear approx of the tabulated function "table"
  where table(1,i) is x(i) and table(2,i) is y(i)
  returns the coordinates of the line as y = la*x + lb
 </PRE>
<A NAME="listdcpx">
 <H3>listdcpx</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine listdcpx(array,size,indx1,indx2)
  IN	: array,size,indx1,indx2
 
    This subroutine  outputs to user the vector array, complex*16, typed real
   in gifa.for, from indx1 to indx2 element
 
 </PRE>
<A NAME="listfreq">
 <H3>listfreq</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine listfreq(array,size,dfreq,freq0,indx,specw)
  IN	: array,size,dfreq,freq0,indx,specw
    This subroutine  outputs to user the elements of vector array, complex*16
    whose argumant is in the interval [freq0-dfreq,freq0+dfreq]
 
 </PRE>
<A NAME="load_font">
 <H3>load_font</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void load_font()
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C and  subroutine load_font() are used for internal use
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="load_matlab">
 <H3>load_matlab</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/matlab.for"> /usr/local/gifa/source/matlab.for </A> 
 <PRE> 	subroutine load_matlab(file_nm, sizemax,
      *                         matrix, line, col, error)
  IN	: file_nm, sizemax
  OUT	: error,  matrix, line, col,
 
  read matrix(col, line) from a matlab compatible file
 
  typical use is through recombinant array
  eg :
 	integer sizemax, line, col, error
 	parameter (sizemax=some large number)
 	real matrix(sizemax)
 	...
 	file_nm = 'my_file.dat'
 	call load_matlab(file_nm, sizemax, matrix, line, col, error)
 	if (error.ne.0) you should do something
 	call work(matrix, line, col, other param ...)
 	....
  and work is such :
 	subroutine work(matrix, line, col, other param ...)
 	integer line, col
 	real work(col,line)
 	... do your work here
 
 
 </PRE>
<A NAME="loaddata">
 <H3>loaddata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/loaddata2.for"> /usr/local/gifa/source/loaddata2.for </A> 
 <PRE>       subroutine loaddata(tdata,size,noise)
  OUT	: tdata,size,noise
  SIDE	: spectral parameters
 
  simulates a 1D fid form values entered by the user
 
 </PRE>
<A NAME="lowercase">
 <H3>lowercase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine lowercase(s,n)
  IN	: n
  INOUT	: s
     put the string of char "s(n)" in lowercase
 
 </PRE>
<A NAME="lpback">
 <H3>lpback</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine lpback(rec,szrec,ar,szar,data,szdata,error)
  IN	: szrec,ar,szar,data,szdata
  OUT	: rec,error
  lpback reconstruct the data before the first point, using the
  linear prediction equation.
  i.e. :  data(i) = -sum(k=1 to szar, ar(k)*data(i+k) )
 
  rec(szrec) final data.
  ar(szar) the autoregressive polynome.
  data(szdata) experimental data
  error error signal for overflow
  
 </PRE>
<A NAME="lpcclose">
 <H3>lpcclose</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcclose(totsize)
  OUT	: totsize
 
  close the currently opend lpc coded file,
  returns the size of the file
 
 </PRE>
<A NAME="lpcomp">
 <H3>lpcomp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine lpcomp (rec,ar,szar,data,szdata)
  IN	: ar,szar,data,szdata
  OUT	: rec
  calculate deltas for compaction of data
 
  rec(szdata) first szar exp.data and delta between exp. data
  and calculated data with ar(szar)
  ar(szar) the autoregressive polynome.
  data(szdata) experimental data
 </PRE>
<A NAME="lpcopen">
 <H3>lpcopen</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcopen(name,error)
  IN	: name
  OUT	: error
 
  opens a LPC coded file, connect to unit 10
 
 </PRE>
<A NAME="lpcreadfid">
 <H3>lpcreadfid</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcreadfid(fid,delta,error)
  OUT	: fid,delta,error
 
  reads a fid from the opened lpc coded file
 </PRE>
<A NAME="lpcreadhead">
 <H3>lpcreadhead</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcreadhead(szi1,szi2,sar,ar,specw1,specw2,
      *		off1,off2,itype,error)
  IN	: szi1,szi2,sar,ar,specw1,specw2,off1,off2,itype
  OUT	: error
 
  read the header of the currently opened lpc coded file
 
 </PRE>
<A NAME="lpcwrtfid">
 <H3>lpcwrtfid</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcwrtfid(fid,delta,error)
  IN	: fid,delta
  OUT	: error
 
  write a fid to the opened lpc coded file
 </PRE>
<A NAME="lpcwrthead">
 <H3>lpcwrthead</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine lpcwrthead(szi1,szi2,sar,ar,specw1,specw2,
      *		off1,off2,itype,error)
  IN	: szi1,szi2,sar,ar,specw1,specw2,off1,off2,itype
  OUT	: error
 
  write the header of the opened lpc coded file.
 
 </PRE>
<A NAME="lpdecomp">
 <H3>lpdecomp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine lpdecomp (rec,ar,szar,data,szdata)
  IN	: rec,ar,szar,szdata
  OUT	: data
  calculate exp. data from data compacted
 
  rec(szdata) data compacted : first exp.data (szar), and deltas (rec(i+szar))
  between exp. data and calculated data with ar(szar)
  ar(szar) the autoregressive polynome.
  data(szdata) experimental data
 </PRE>
<A NAME="lpfilter">
 <H3>lpfilter</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine lpfilter(rec,szrec,ar,szar,data,szdata)
  IN	: szrec,ar,szar,data,szdata
  OUT	: rec
  filter the water signal with LP
  rec(szrec) final data.
  ar(szar) the autoregressive polynome.
  data(szdata) experimental data
 </PRE>
<A NAME="lpforw">
 <H3>lpforw</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine lpforw(rec,szrec,ar,szar,data,szdata,error)
  IN	: szrec,ar,szar,data,szdata,error
  OUT	: rec, error
  lpforw reconstruct the data after the last point, using the
  linear prediction equation.
  i.e. :  data(i) = -sum(k=1 to szar, ar(k)*data(i-k) )
          data(i) = -sum(s=i-1 to i-szar, ar(i-s)*data(s) )
 
  rec(szrec) final data.
  ar(szar) the autoregressive polynome.
  data(szdata) experimental data
  error error signal for overflow
  
 </PRE>
<A NAME="lpreconstruct1d">
 <H3>lpreconstruct1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpreconstruct.for"> /usr/local/gifa/source/lpreconstruct.for </A> 
 <PRE> 	subroutine lpreconstruct1d (sizedata,rdata,amp,width,
      &			phas,freq,nsignals,specw2,offset)
  IN	: sizedata,amp,width,phas,freq,nsignals,specw2,offset
  OUT	: rdata
 
  Calculate the 1D data (FID) from parameter peaks
 
 </PRE>
<A NAME="makeGC">
 <H3>makeGC</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void makeGC(vd_id,color,bgcol)
 int *vd_id,color,bgcol;
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C                                                                         C
 C      subroutine makegc(vd_id)
 C        makeGC builds and store the GC for window vd_id                  C
 C                                                                         C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="makebwtable">
 <H3>makebwtable</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_color.c"> /usr/local/gifa/source/X_color.c </A> 
 <PRE> void makebwtable(display,colortable,bg1,fg1,bg2,fg2,black,white,cursor1,cursor2)
 int colortable[];
 XColor *bg1,*fg1,*bg2,*fg2;
 unsigned long black,white;
 Cursor cursor1,cursor2;
 Display *display;
 </PRE>
<A NAME="map_logo">
 <H3>map_logo</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void map_logo()
 </PRE>
<A NAME="match">
 <H3>match</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/roots.for"> /usr/local/gifa/source/roots.for </A> 
 <PRE>       subroutine match (zn1,zn2,order,nsignals,x,zn)
  IN	: zn1,zn2,order,nsignals
  OUT	: zn
  WORK	: x
 
  part of the LPSVD package
  Compare two sets of roots zn1 and zn2 to determine which of them are noise
  complex*16 zn1 forward roots,zn2 backward roots
  integer order : degree of polynome,number of roots
  integer nsignals : number of real signals
  real*8 x : working area
  complex*16 zn : the final roots
 
 </PRE>
<A NAME="maxinbox1d">
 <H3>maxinbox1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intrec.for"> /usr/local/gifa/source/intrec.for </A> 
 <PRE>       subroutine maxinbox1d(vect,si,maxi,err)
  IN	: vect,si,err
  OUT	: max
 
  computes the largest of the points in an area of the 1D data "vect"
  area is prompted from the user,
 </PRE>
<A NAME="maxinbox2d">
 <H3>maxinbox2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/intrec.for"> /usr/local/gifa/source/intrec.for </A> 
 <PRE>       subroutine maxinbox2d(smx,si1,si2,maxi,err)
  IN    : smx,si1,si2,err
  OUT   : maxi
 
  computes the largest of the points in an area of the 2D data "smx"
  area is prompted from the user,
 </PRE>
<A NAME="maxlig">
 <H3>maxlig</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/bornepic.for"> /usr/local/gifa/source/bornepic.for </A> 
 <PRE>        subroutine maxlig(tablo,si1,si2,lig,lim1,lim2,colsom,signpic,zq)
 
  IN	: tablo,si1,si2,lig,lim1,lim2,signpic,zq
  OUT 	: colsom
  used by 2D INTEG
 
 </PRE>
<A NAME="maxvect">
 <H3>maxvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  maxvect(arrayout,B,C,size)
  IN	: B,C,size
  OUT	: arrayout
  
  MAXVECT(A,B,C,N) put into the vector A, the largest value of vector B and C
 
 </PRE>
<A NAME="median1d">
 <H3>median1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/median.for"> /usr/local/gifa/source/median.for </A> 
 <PRE>       subroutine median1d(array,size,nsm,inx)
  IN	: size,nsm,inx
  INOUT	: array
 
  performs a median filtering on a nsm wide window, and gets the inxth
  point 
  moves array by nsm/2 points
 
 </PRE>
<A NAME="median2d">
 <H3>median2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/median.for"> /usr/local/gifa/source/median.for </A> 
 <PRE>       subroutine median2d(array,size1,size2,nsm1,nsm2,inx)
  IN	: size1,size2,nsm1,nsm2,inx
  INOUT	: array
  performs a median filtering on a nsm1.nsm2 wide window, and gets the inxth
  point 
  array(size2,size1) is real
 
 </PRE>
<A NAME="merit1d">
 <H3>merit1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/phasemerit.for"> /usr/local/gifa/source/phasemerit.for </A> 
 <PRE>        function merit1d(x)
  IN	: x
  1d version of phasemerit
  x a real, parameting along axis, starting from start (in conjgrad.inc)
 </PRE>
<A NAME="message">
 <H3>message</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine message(text)
  IN	: text
  SIDE  : imsg, cleanable, msg(*)
 
  put in a string for reusal by getstring2() for user interface
  used for prompting in MAIN GIFA program...
 
  The message buffer is a set of char(imsgmax)
  the number of string to display in it is kept in imsg
 
  for the MESSAGE command, a strange set-up has been made :
  The buffer can be cleanable or not. (set uncleanable by SET)
  if cleanable ,
      getstring2 empties the buffer (imsg=0)
      message adds to the buffer (imsg++)
  if not cleanable (cleanable != 0)
      getstring2 does nothing
      message empties the buffer, and makes it cleanable
 
  cleanable is set from outside (for instance the MESSAGE command)
 
 
 </PRE>
<A NAME="mexp">
 <H3>mexp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fitexp.for"> /usr/local/gifa/source/fitexp.for </A> 
 <PRE>       subroutine mexp(size,param,x,y) 
 </PRE>
<A NAME="miniend">
 <H3>miniend</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine miniend(p,size,verb,err)
  IN:   p,size,verb
  SIDE: copy into user Gifa variable $Pi
 
  size: The number of independent parameters
  p(size) : the fortran array that will hold the counter part of $Pi
 
  copies all running parameters to User variables
  sets $Pi equal to p(i)
 
  verbose if verb > 1
 
 </PRE>
<A NAME="miniinit">
 <H3>miniinit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       subroutine miniinit(st,p,size,err)
  IN:   st,size
  OUT:  p
 
  This one initialize every thing for the generic minimizer (MINIMIZE)
  st : the string to evaluate, should be a function of the global
       variables $Pi
  size: The number of independent parameters
  p(size) : the fortran array that will hole the counter part of $Pi
 
  initializes the common for powell
  sets p(i) equal to $Pi
 
 </PRE>
<A NAME="minimize">
 <H3>minimize</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>       function minimize(p,size)
 
 </PRE>
<A NAME="minimize1d">
 <H3>minimize1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/minimize.for"> /usr/local/gifa/source/minimize.for </A> 
 <PRE>        function minimize1d(x)
  IN	: x
  1d version of minimize
  x a real, parameting along axis, starting from start (in conjgrad.inc)
 </PRE>
<A NAME="minvect">
 <H3>minvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  minvect(arrayout,B,C,size)
  IN	: B,C,size
  OUT	: arrayout
  
  MINVECT(A,B,C,N) put into the vector A, the smallest value of vector B and C
 
 </PRE>
<A NAME="misaj">
 <H3>misaj</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE>       subroutine misaj (nbits,sumloc,ncode)
  IN	: nbits,ncode
  OUT	: sumloc
 
  internaly used by codoptim to update the optimal code table.
 
 </PRE>
<A NAME="mkmask">
 <H3>mkmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/mkmask.for"> /usr/local/gifa/source/mkmask.for </A> 
 <PRE> 	subroutine mkmask (tab,masktab,taille2,taille1,
      & verbose,tindex,factor,slope,thres,radius,signpic,zq)
 
  Determine the peak amoeba table from the peak table
  
  tab(taille2,taille1): 2D experiment
  masktab(taille2,taille1): amoeba table
  tindex(16*radius): working area
  radius: maximum amoeba radius
  signpic: peak sign
 
  IN	: tab,masktab,taille1,taille2,factor,slope,
  IN    : thres,radius,signpic,verbose
  OUT	: peak2d
 
 </PRE>
<A NAME="mltvect">
 <H3>mltvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  mltvect(a,b,l,size)
  IN	: b,l,size
  OUT	: a
 
  MLTVECT(A,B,L,N) multiply vector B by scalar l, and put it into A
  
 
 </PRE>
<A NAME="mnxvect">
 <H3>mnxvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine mnxvect(mini,maxi,imini,imaxi,A,size)
  IN	: A,size
  OUT	: mini,maxi,imini,imaxi
 
  MNXVECT(mini,maxi,imini,imaxi,A,N)  find values and locations of the largest
           point (maxi,imaxi) and the smallest point (mini,imini) of vector
           A of size N
 
 </PRE>
<A NAME="modu2d">
 <H3>modu2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine modu2d(image,size1,size2)
  INOUT	: image,size1,size2
 
  modu2d computes the module of the 2D bicomplex array image, and put it
  back in image changed to 2D real, size1 and size2 then refer to real.
 
 
 </PRE>
<A NAME="modu3d">
 <H3>modu3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine modu3d(image,size1,size2,size3)
  INOUT	: image,size1,size2,size3
 
  modu3d computes the module of the 3D tricomplex array image, and put it
  back in image changed to 3D real, size1, size2 and size3 then refer to real.
 
 </PRE>
<A NAME="module">
 <H3>module</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/trigmult.for"> /usr/local/gifa/source/trigmult.for </A> 
 <PRE>       subroutine module(image,size)
  INOUT	: image,size
 
  module computes the module of the complex array "image", and put it
  back in image changed to real, "size" is divided by two
 
 </PRE>
<A NAME="moindo">
 <H3>moindo</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/moindo.for"> /usr/local/gifa/source/moindo.for </A> 
 <PRE>         subroutine moindo(spectre,n,min,max)
 
 </PRE>
<A NAME="morpho">
 <H3>morpho</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segpri.for"> /usr/local/gifa/source/segpri.for </A> 
 <PRE>       subroutine morpho(size,n10,n20)
  part of BCORR 3
 
 </PRE>
<A NAME="mouse_coordCB">
 <H3>mouse_coordCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void mouse_coordCB(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int             *vd_id;
 XEvent          *evt;      /*  data from widget class  */
 </PRE>
<A NAME="movave">
 <H3>movave</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lisse.for"> /usr/local/gifa/source/lisse.for </A> 
 <PRE>       subroutine movave(imaged,images,size,p,bb)
 
  used by linecor2
 
 </PRE>
<A NAME="movave2">
 <H3>movave2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lisse.for"> /usr/local/gifa/source/lisse.for </A> 
 <PRE>       subroutine movave2(imaged,images,size,win,bb,iter)
 
  used by linecor2
 
 </PRE>
<A NAME="movave3">
 <H3>movave3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lisse.for"> /usr/local/gifa/source/lisse.for </A> 
 <PRE>       subroutine movave3(imaged,images,size,fen,bb,iter)
 
  used by linecor2
 
 </PRE>
<A NAME="move_viewfinder">
 <H3>move_viewfinder</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void move_viewfinder(w, vd_id, evt)
      /* called when the mouse is moved with the viewfinder on */
 Widget          w;              /*  widget id           */
 int             *vd_id;
 XEvent          *evt;
 </PRE>
<A NAME="move_vwf">
 <H3>move_vwf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void move_vwf(vd_id, x,y)
 int             *vd_id;
 float           x,y;
 </PRE>
<A NAME="mrqcof">
 <H3>mrqcof</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/levenberg.for"> /usr/local/gifa/source/levenberg.for </A> 
 <PRE>       subroutine mrqcof(x,y,sig,w,szd,size,pr,adj,sort,
      *           mata,matb,chisq,func,dfunc,debug,verbose)
  IN	: x,y,sig,w,szd,size,pr,adj,sort,func,dfunc,debug,verbose
  OUT	: mata,matb,chisq
  elementary step of the levenberg module
  called by mrqmin
 
 </PRE>
<A NAME="mrqmin">
 <H3>mrqmin</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/levenberg.for"> /usr/local/gifa/source/levenberg.for </A> 
 <PRE>       subroutine mrqmin (x,y,sig,win,sizdt,p,sz,tripar,ajus,
      *              lwerror,cov,alf,bet,lambda,func,dfunc,verbose,debug)
  IN	: x,y,sig,win,sizdt,p,sz,tripar,ajus,func,dfunc,verbose,debug
  INOUT	: lambda
  OUT	: lwerror,cov,alf,bet
  called by levenberg
 
  it's by repeating the calling to mrqmin subroutine that we will
  minimize the error function (err) and find the best suited values
  for the parameters (p) involved in the chosen function (func).
 
      
 </PRE>
<A NAME="mskintg">
 <H3>mskintg</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/mskintg.for"> /usr/local/gifa/source/mskintg.for </A> 
 <PRE>        subroutine mskintg(tab,masktab,taille1,taille2,
      *    noise,shift,signpic)
  tab(taille1,taille2): 2D experiment array
  makstab(taille1,taille2): amobea array
  noise: noise level (calculated by EVALN)
  shift: shift (calculated by EVALN)
  
  IN	: tab,masktab,taille1,taille2,noise,shift,signpic
  OUT	: peak2d
 
  calculate the volume of all the peaks from the amobea table information
  and put the volume in peak2d(*,3) and incertitude in peak2d(*,6)
 </PRE>
<A NAME="mult2d">
 <H3>mult2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine mult2d(vector,smx,si1,si2)
  IN	: vector,si1,si2
  INOUT	: smx
 
  used by 2D apodisation.
  vector is holding function if F2 and in F1 concatenated
  smx(i,j) is multiplied by F2(i)*F1(j)
 
 </PRE>
<A NAME="mult3d">
 <H3>mult3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine mult3d(vector,smx,si1,si2,si3)
  IN	: vector,si1,si2,si3
  INOUT	: smx
 
  3D equivalent of mult2d
 
 </PRE>
<A NAME="mxavect">
 <H3>mxavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine mxavect(mini,maxi,imini,imaxi,A,size)
  IN	: A,size
  OUT	: mini,maxi,imini,imaxi
 
  MXAVECT(mini,maxi,imini,imaxi,A,N)   same as MNXVECT but for the absolute
           value of the vector A
  
 
 </PRE>
<A NAME="nbneigh">
 <H3>nbneigh</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/nbneigh.for"> /usr/local/gifa/source/nbneigh.for </A> 
 <PRE>       function nbneigh (masktab,taille2,taille1,crdf2,crdf1,
      & pkno)
 
  IN masktab,taille2,taille1,crdf1,crdf2,pkno
  OUT nbneigh
 
  For a given pixel(crdf2,crdf1) and a given peak number
  pkno, calculate
  the number of the neighboring pixels belonging to the 
  peak amoeba
  if (x,y) are the pixel coordinates, the considered pixel
  neighbors have the following coordinates: (x-1,y),(x+1,y),
  (x,y-1) and (x,y+1)
 
 </PRE>
<A NAME="nbneigha">
 <H3>nbneigha</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/nbneigh.for"> /usr/local/gifa/source/nbneigh.for </A> 
 <PRE>       function nbneigha (masktab,taille2,taille1,crdf2,crdf1,
      & pkno)
 
  IN masktab,taille2,taille1,crdf1,crdf2,pkno
  OUT nbneigh
 
  For a given pixel(crdf2,crdf1) and a given peak number
  pkno, calculate
  the number of the neighboring pixels belonging to the 
  peak amoeba
  if (x,y) are the pixel coordinates, the considered pixel
  neighbors have the following coordinates: (x-1,y),(x+1,y),
  (x,y-1),(x,y+1),(x-1,y-1),(x+1,y+1),(x-1,y+1),(x+1,y-1)
 
 </PRE>
<A NAME="nextelem">
 <H3>nextelem</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine nextelem(array,context,indx,next,err)
  IN	: array,context,indx,err
  OUT	: next
 
       if index is an entry in the associative array $array, in "context"
       next will be the next elemen,
       if index = \127 or ' ' will return the first elem
       if index is the last, will return \127
       err <> 0 if array does not exist
 
 </PRE>
<A NAME="nothingCB">
 <H3>nothingCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void nothingCB(w, client_data, event)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer      event ;      /*  data from widget class  */
 
 </PRE>
<A NAME="opengif">
 <H3>opengif</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine opengif(namep,unumb,error)
  IN	: namep,unumb
  OUT	: error
 
  Opens the file called "namep" and connects it to "unumb"
 
  This subroutine is used to open the macro file.
 
  if the global variable PATH is empty, the old set-up is used :
    First search the file in working directory,
 
    then in $HOME/macro    (sys$login:[MACRO] in vms)
 
    then in the standard place for gif files :
     gifa$gif            on VMS
     /usr/local/gifa/macro  on Unix
 
  else
    search in all entries in PATH, (blank separated)
 
  in any case, do nothing if the file name starts with a / (UNIX)
  Author : Marc A.Delsuc
  rev date 6-dec-95
 ************************************************************
 </PRE>
<A NAME="os_config">
 <H3>os_config</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>       subroutine os_config(st)
  OUT	: st
  returns the name of the system
 </PRE>
<A NAME="parselit">
 <H3>parselit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine parselit(st,var,err)
  IN	: st
  OUT	: var,err
 
  this one parse a literal ('string' "string" or number) in the exp. string
  will set var, and move he accordingly
 
  I known, this is sloppy, but hey, I got it working, and I WON't change it now
 
  change 20-3-93 blanks in strings are changed to DEL to keep leading 
  and trailing blanks in literals
 
 </PRE>
<A NAME="parsest">
 <H3>parsest</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine parsest(st,val,loc,job,err)
  IN	: st,job
  OUT	: val,loc,err
 
  the string parser
 
  parsest will parse a string for :
  o isolated words
  o quotted string ('xxx' or "xxx")
  o GIFA variables
  o (expressions)
 
  val will return the value, loc the position of the next char in st
 
  if job = 1 will only locate next word
  if job = 2 will parse and return in val
 ************************************************************
 </PRE>
<A NAME="parsevar">
 <H3>parsevar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine parsevar(st,var,err)
  IN	: st
  OUT	: var,err
 
  this one parse a variable name in the exp. string st, at location he
  (global with eval) and returns the value into var.
  if the var is an array, just the name is return, since [ is a pseudo 
  operator
 
 </PRE>
<A NAME="peakproj">
 <H3>peakproj</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/peakproj.for"> /usr/local/gifa/source/peakproj.for </A> 
 <PRE> 	subroutine peakproj (error,axis,proj,tol)
  IN	: axis,proj,tol
  OUT	: error
  SIDE	: 1D peak table
 
  Load the 1D peak table with content of the 2D peak table projected along one 
  dimension
 
  input:
  pead1d(nbpic1d,pk1d): 1D peak table
  pead2d(nbpic2d,pk2d): 2D peak table
  axis: projection flag: axis = 2, projection along f2 (on f1)
 			 axis = 1, projection along f1 (on f2)
  proj: 'S' or 'M', skyline or mean projection
  tol: precision on the ppm values
 
  output:
  error: error label
  nbpic1d: modified number of 1D peaks
 
 </PRE>
<A NAME="peaksym_add">
 <H3>peaksym_add</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/peaksym.for"> /usr/local/gifa/source/peaksym.for </A> 
 <PRE> 	subroutine peaksym_add (error,tol)
  IN	: tol
  OUT	: error
  SIDE	: 2D peak table
 
  Symetrize the peak table by adding non symetrical values
 
  input:
  pead2d(nbpic2d,pk2d): 2D peak table
  tol: precision on the ppm values
 
  output:
  error: error label
  nbpic2d: modified number of peaks
 
 </PRE>
<A NAME="peaksym_rem">
 <H3>peaksym_rem</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/peaksym.for"> /usr/local/gifa/source/peaksym.for </A> 
 <PRE> 	subroutine peaksym_rem (tindex,szindex,error,tol)
  IN	: tol,szindex
  OUT	: error
  WORK	: tindex
  SIDE	: 2D peak table
 
  Symetrize the peak table by removing non symetrical values
 
  input:
  pead2d(nbpic2d,pk2d): 2D peak table
  tol: precision on the ppm values
 
  output:
  error: error label
  nbpic2d: modified number of peaks
 
 </PRE>
<A NAME="pente">
 <H3>pente</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/redfield.for"> /usr/local/gifa/source/redfield.for </A> 
 <PRE>       subroutine pente (data,sizdat,specw,redf)
  IN	: data,sizdat,specw
  OUT	: redf
 
  part of the build-up curve analysis
  Calculate the initial slope of a build-up curve
  real data(sizdat) build-up curve's data
  real redf : relaxation rate
  integer order : number of exponentials detected.
  integer sizdat : considered size of data, can be lesser then the total size
  real specw : spectral width, should be the same that the used one in
  linear prediction processing
 
 </PRE>
<A NAME="phase">
 <H3>phase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/phase.for"> /usr/local/gifa/source/phase.for </A> 
 <PRE>       subroutine phase(A,P0,P1,N)
  IN	: P0,P1,N
  INOUT	: A
 
   this subroutine applies a NMR-type phase correction to the complex
  data A(i) of length N, with p0 as zero-order correction and p1 as first-order
  correction. P0 and P1 are both in degree.
 
  i.e    A(i) is (complex) multiplied by exp(2*pi*(P0 + P1*(i-1/N))
 
 </PRE>
<A NAME="phase2d">
 <H3>phase2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/phase2d.for"> /usr/local/gifa/source/phase2d.for </A> 
 <PRE>       subroutine phase2d(tdata,size1,size2,p0,p1,direc)
  IN	: size1,size2,p0,p1,direc
  INOUT	: tdata
   This subroutine applies a NMR-type phase correction to the hypercomplex
  data tdata(i,j) of length si1im,si2im, with p0 as zero-order correction and
  p1 as first-order correction. P0 and P1 are both in degree. If Direc is
  1 correction is applied in Dim 1 (vertical), if direc is 2, correction
  is applied in dim 2
 
  MAD modified 10 jul 2002 
      to remove the column move, and write on complex rotations.
 
 </PRE>
<A NAME="phase_cancelCB">
 <H3>phase_cancelCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_cancelCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_closeCB">
 <H3>phase_closeCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_closeCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_m10CB">
 <H3>phase_o0_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_m1CB">
 <H3>phase_o0_m1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_m1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_m90CB">
 <H3>phase_o0_m90CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_m90CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_p10CB">
 <H3>phase_o0_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_p1CB">
 <H3>phase_o0_p1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_p1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o0_p90CB">
 <H3>phase_o0_p90CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o0_p90CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_m10CB">
 <H3>phase_o1_m10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_m10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_m1CB">
 <H3>phase_o1_m1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_m1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_m90CB">
 <H3>phase_o1_m90CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_m90CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_p10CB">
 <H3>phase_o1_p10CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_p10CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_p1CB">
 <H3>phase_o1_p1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_p1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_o1_p90CB">
 <H3>phase_o1_p90CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_o1_p90CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phase_okCB">
 <H3>phase_okCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void phase_okCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 Data_phase      *client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="phasemerit">
 <H3>phasemerit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/phasemerit.for"> /usr/local/gifa/source/phasemerit.for </A> 
 <PRE>        function phasemerit(phase)
  IN	: phase
  merit function for auto phase
  phase(4) is the phase parameters
  phase(1), (2) are the oth order, (3),(4) are the 1st order.
 
 </PRE>
<A NAME="pickkey">
 <H3>pickkey</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/dbm.for"> /usr/local/gifa/source/dbm.for </A> 
 <PRE> 	subroutine pickkey(array,key,vname,error)
 
  IN: vname
  OUT: error,array,key
 
  to get the key and array name from an array element
 
  input:
  vname: array element variable
 
  output:
  array: associative array name
  key: database element key
  error: error flag
 
 </PRE>
<A NAME="picmaxave">
 <H3>picmaxave</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxave(comp,nombrepic,dist)
  IN	   : comp,dist
  INOUT  : nombrepic
  SIDE   : in peak2d
 
  remove all peaks in a radius of comp
   and create a new one with coordinates at the barycenter of
               the found peaks, and intensity equal to the sum
 
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="picmaxave3d">
 <H3>picmaxave3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxave3d(comp,nombrepic,dist)
  IN	   : comp,dist
  INOUT  : nombrepic
  SIDE   : in peak3d
 
  remove all peaks in a radius of comp
   and create a new one with coordinates at the barycenter of
               the found peaks, and intensity equal to the sum
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="picmaxlink">
 <H3>picmaxlink</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxlink(comp,nombrepic,dist)
  IN	: comp,nombrepic,dist
  SIDE	: in peak2d
 
  link peak in a radius of comp
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="picmaxlink3d">
 <H3>picmaxlink3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxlink3d(comp,nombrepic,dist)
  IN	: comp,nombrepic,dist
  SIDE	: in peak3d
 
  link peak in a radius of comp
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="picmaxrem">
 <H3>picmaxrem</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxrem(comp,nombrepic,dist)
  IN	   : comp,dist
  INOUT  : nombrepic
  SIDE   : in peak2d
 
  remove peak in a radius of comp
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="picmaxrem3d">
 <H3>picmaxrem3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/picmax.for"> /usr/local/gifa/source/picmax.for </A> 
 <PRE>        subroutine picmaxrem3d(comp,nombrepic,dist)
  IN	   : comp,dist
  INOUT  : nombrepic
  SIDE   : in peak3d
 
  remove peak in a radius of comp
  dist determines which distance is used :
    1 : dist = abs(x) + abs(y)  => square   was the default in previous version
    2 : dist = sqrt(x^2 + y^2)  => circle
    0 : dist = x+y              => diamond
 
 </PRE>
<A NAME="pl3d_draw">
 <H3>pl3d_draw</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine  pl3d_draw(vd_id, x1, y1, z1)
  IN	: vd_id, x1, y1, z1
 
  for 3D plot
  draw from current position to x1, y1, z1
 </PRE>
<A NAME="pl3d_move">
 <H3>pl3d_move</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine  pl3d_move(vd_id, x1, y1, z1)
  IN	: vd_id, x1, y1, z1
 
  for 3D plot
  move pen to x1, y1, z1
 </PRE>
<A NAME="pl3d_text">
 <H3>pl3d_text</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine pl3d_text(vd_id,x,y,z,text,length)
  IN	: vd_id, x1, y1, z1
 
  for 3D plot
  draw text at position x1, y1, z1
 </PRE>
<A NAME="pl_config">
 <H3>pl_config</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibgpgl.for"> /usr/local/gifa/source/plotlibgpgl.for </A> 
 <PRE>       subroutine pl_config(st)
 </PRE>
<A NAME="pl_config_hp">
 <H3>pl_config_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pl_config_hp(st)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pl_config_ps">
 <H3>pl_config_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pl_config_ps(st)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="plchpage">
 <H3>plchpage</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine plchpage(pl_id)
  IN	: pl_id
  generic plotter library
 
  plchpage changes the page on a plotter installed to do so
 </PRE>
<A NAME="plchpage_hp">
 <H3>plchpage_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plchpage_hp(pl_id)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="plchpage_ps">
 <H3>plchpage_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plchpage_ps(pl_id)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="plchpen">
 <H3>plchpen</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine plchpen(pl_id,colour)
  IN	: pl_id,colour
  generic plotter library
  plchpen selects another pen for plotting,colour is the number of the selected
  pen ,
  in postscript it becomes :
  1 normal, 2 small dash, 3 big dash, 4 asymetric dash, 5-8 same effect with
  larger line.
 
 </PRE>
<A NAME="plchpen_hp">
 <H3>plchpen_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plchpen_hp(pl_id,colour)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="plchpen_ps">
 <H3>plchpen_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plchpen_ps(pl_id,colour)
  Postscript version of the generic plotter call
 
 </PRE>
<A NAME="plclose">
 <H3>plclose</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>        subroutine plclose(plid)
 </PRE>
<A NAME="plcolor">
 <H3>plcolor</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine plcolor(pl_id,colour)
  IN	: pl_id,colour
  generic plotter library
  plcolor selects another color, specific to postscript
 
 </PRE>
<A NAME="plcolor_hp">
 <H3>plcolor_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plcolor_hp(pl_id,colour)
  on hpgl, plcolor and plchpen are equivalent
 </PRE>
<A NAME="plcolor_ps">
 <H3>plcolor_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plcolor_ps(pl_id,colour)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="pldotdraw">
 <H3>pldotdraw</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine pldotdraw(pl_id,dx,dy)
  IN	: pl_id,dx,dy
  generic plotter library
  pldotdraw draw a dotted line of dx and dy centimeters, starting
  from current position, coordinates in absolute.
 </PRE>
<A NAME="pldotdraw_hp">
 <H3>pldotdraw_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pldotdraw_hp(pl_id,dx,dy)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pldotdraw_ps">
 <H3>pldotdraw_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pldotdraw_ps(pl_id,dx,dy)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="pldraw">
 <H3>pldraw</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibgpgl.for"> /usr/local/gifa/source/plotlibgpgl.for </A> 
 <PRE>       subroutine pldraw(pl_id,dx,dy)
 </PRE>
<A NAME="pldraw_hp">
 <H3>pldraw_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pldraw_hp(pl_id,dx,dy)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pldraw_ps">
 <H3>pldraw_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pldraw_ps(pl_id,dx,dy)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="pleject">
 <H3>pleject</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine pleject(pl_id)
  IN	: pl_id
  generic plotter library
 
  pleject changes the page on a plotter installed to do so
  reinitialize the plotter as well
  and send the file to the plotter through a shell call
  forgets about the file name
  closes the file, so no need for a close(plid)
 </PRE>
<A NAME="plforget">
 <H3>plforget</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>        subroutine plforget(name,err)
  IN	: pl_id
  OUT	: err
 
  generic plotter library
 
  "forgets" the plotter file "pl_id", i.e. removes it from the list f 
  currently opened plotter file
 </PRE>
<A NAME="plhome">
 <H3>plhome</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibgpgl.for"> /usr/local/gifa/source/plotlibgpgl.for </A> 
 <PRE>       subroutine plhome(pl_id)
 </PRE>
<A NAME="plhome_hp">
 <H3>plhome_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plhome_hp(pl_id)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="plhome_ps">
 <H3>plhome_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plhome_ps(pl_id)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="plinit">
 <H3>plinit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine plinit(pl_id)
  IN	: pl_id
  generic plotter library
  plinit sends back the pen to home position, initializes the plotter,
  and sets current default values for plotting,
 </PRE>
<A NAME="plinit_hp">
 <H3>plinit_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plinit_hp(pl_id)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="plinit_ps">
 <H3>plinit_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plinit_ps(pl_id)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="plmove">
 <H3>plmove</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibgpgl.for"> /usr/local/gifa/source/plotlibgpgl.for </A> 
 <PRE>       subroutine plmove(pl_id,dx,dy)
 </PRE>
<A NAME="plmove_hp">
 <H3>plmove_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine plmove_hp(pl_id,dx,dy)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="plmove_ps">
 <H3>plmove_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine plmove_ps(pl_id,dx,dy)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="plopen">
 <H3>plopen</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>        subroutine plopen(plid,nm,err)
  IN	: pl_id,nm
  OUT	: err
 
  generic plotter library
 
  opens the file called nm, and conects it to the plotter d 'pl_id'
  
 </PRE>
<A NAME="plot1d">
 <H3>plot1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plot1d.for"> /usr/local/gifa/source/plot1d.for </A> 
 <PRE>       subroutine plot1d(pl_id,size,spectrum,max0,scaling,mode,cx,cy,vh)
  IN	: pl_id,size,spectrum,scaling,mode,cx,cy,vh
  INOUT	: max0
 
  display array spectrum(size) on plotter pl_id, with scaling
  with length cx and heigth cy
  if mode.eq.0 display everything, if mode.eq.1 only one over two  (real/complex)
  vh is the location of the zero level in the window
 
 </PRE>
<A NAME="plot2d">
 <H3>plot2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plot2d.for"> /usr/local/gifa/source/plot2d.for </A> 
 <PRE>       subroutine plot2d(pl_id,vd_id,si1,si2,matrix,
      *        maxi,scaling,mode,dx,dy,levels,sign2,loga,col,
      *        zoom,zolf1,zolf2,zour1,zour2,clear)
  IN	: all parameters, but
  INOUT	: maxi
   Plots a contour-plot of array matrix(si1,si2)
   levels =  number of levels
   scaling = scaling factor
   loga = 1.0 means equidistant levels,
       .gt.1.0 means each level is *loga above the previous
   drawing size =  dx x dy (in cm.)
   mode = 0         -> plots everything
   mode = 1         -> one over two in dim 2
   mode = 2         -> one over two in dim 1
   mode = 3         -> one over two in both dim
 
   sign =  1        -> plot only positive levels
   sign = -1        -> plot only negative levels
   sign = 0         -> plot both levels
 
   col  = 1         -> levels are drawn in color
 
   if pl_id <> 99  -> plot on graphics screen
                       vd_id = visual display id
                       The window must have been
                       opened with 0-1 world coords.
  zoom,zolf1,zolf2,zour1,zour2 describe the zoom state
 
  clear = 1    -> clear screen before displaying
 
   Some bugs have been reported
    -drawing extra lines
    -division by 0 if 2 connected points are exactly at the same level,
       and that level being the one currently plot.
 
   This program tries to avoid level crossing
 
 ---------------------------------------------------------------------
 
 </PRE>
<A NAME="plot2dj">
 <H3>plot2dj</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plot2dj.for"> /usr/local/gifa/source/plot2dj.for </A> 
 <PRE>       subroutine plot2dj(vd_id,id,
      *        scaling,levels,sign2,loga,col,
      *        zolf1,zolf2,zour1,zour2,clear)
  IN	: all parameters
 
   Plots a contour-plot of array a joined file, with `id'
   levels =  number of levels
   scaling = scaling factor
   loga = 1.0 means equidistant levels,
       .gt.1.0 means each level is *loga above the previous
 
   sign =  1        -> plot only positive levels
   sign = -1        -> plot only negative levels
   sign = 0         -> plot both levels
 
   col  = 1         -> levels are drawn in color
 
   vd_id = visual display id
                       The window must have been
                       opened with 0-1 world coords.
  zolf1,zolf2,zour1,zour2 describe the zoom state (in ppm ! not indexes)
 
  clear = 1    -> clear screen before displaying
 
 ---------------------------------------------------------------------
 
 </PRE>
<A NAME="plot3d">
 <H3>plot3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plot3d.for"> /usr/local/gifa/source/plot3d.for </A> 
 <PRE>       subroutine plot3d(pl_id,vd_id,si1,si2,si3,cube,
      *  maxi,scaling,mode2,direcd,dx3d,dy3d,dz3d,levels,sign2,loga,col,
      *  zoom,zl1,zl2,zl3,zu1,zu2,zu3,clear)
  IN	: all parameters, but
  INOUT	: maxi
 
   Plots a 3D contour-plot of cube matrix(si1,si2,si3)
   levels =  number of levels
   scaling = scaling factor (0 means just the cube)
   loga = 1.0 means equidistant levels,
       .gt.1.0 means each level is *loga above the previous
   drawing size =  dx x dy x dz (in cm.)
   mode = 0         -> plots everything
   mode = 1         -> one over two in dim 3
   mode = 2         -> one over two in dim 2
   mode = 3         -> one over two in dim 3 and 2
   mode = 4         -> one over two in dim 1
   mode = 5         -> one over two in dim 1 and 3
   mode = 6         -> one over two in dim 1 and 2
   mode = 7         -> one over two in dim 1 and 2 and 3
 
   if direc = 1     -> contour on planes 1
   if direc = 2     -> contour on planes 2
   if direc = 4     -> contour on planes 3
   etc...
 
   sign =  1        -> plot only positive levels
   sign = -1        -> plot only negative levels
   sign = 0         -> plot both levels
 
   col  = 1         -> levels are drawn in color
 
  clear = 1    -> clear screen before displaying
 
   if pl_id <> 99  -> plot on graphics screen
                       vd_id = visual display id
                       the window must have been opened with win3d_open
 
   In any case the 3D space must have been set with :
  		g3d_init			initialize
  		g3d_setalpha g3d_setbeta g3d_setgama	set viewing angles
  		g3d_setscale		set global scale
 		g3d_setznot			set 1/distance from object
 		g3d_setoff			set offset from center
 
   Some bugs have been reported
    -drawing extra lines
    -division by 0 if 2 connected points are exactly at the same level,
       and that level being the one currently plot.
 ---------------------------------------------------------------------
 
 </PRE>
<A NAME="plotaxis">
 <H3>plotaxis</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotaxis.for"> /usr/local/gifa/source/plotaxis.for </A> 
 <PRE>       subroutine plotaxis(plid,cx,cy,offsetx,offsety,
      *                    direc,cunit,sepax,sepay,grid)
  IN: all parameters
    This subroutine plots axes around a square of cx by cy cm. on the 
    current plotter.                                           
 
  if Direc is 2    plots x axis only
  if Direc is 1    plots y axis only
  if Direc is 3    plots both axes
 
  offsetx is the distance of x axis to the x=0 level (usually neg)
  offsety is the distance of y axis to the y=0 level (usually neg)
 
  grid 0 is axis drawing
  grid 1 , a grid is to drawn along with axis
 
  sw and off are spectral width and spectral offset (of the upper right 
   point) of the spectrum to plot.
 
  1 refers to y coordinates or values and 2 to x coordinates
    and values.           
 </PRE>
<A NAME="plotcross2">
 <H3>plotcross2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>       subroutine plotcross2(pl_id,x,y,size,i)
  IN	: pl_id,x,y,size,i
 
  draw on plot file "pl_id" a cross at location "x" "y" (in cm) and of size "size"
  and writes number "i"
 
 </PRE>
<A NAME="pltexset">
 <H3>pltexset</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine pltexset(pl_id,size,angl)
  IN	: pl_id,size,angl
  generic plotter library
  pltexset sets the values of the size of character strings to be
  written on the plotter
 </PRE>
<A NAME="pltexset_hp">
 <H3>pltexset_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pltexset_hp(pl_id,size,angl)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pltexset_ps">
 <H3>pltexset_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pltexset_ps(pl_id,size,angl)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="pltext">
 <H3>pltext</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine pltext(pl_id,tex,lentext,xtext,ytext)
  IN	: pl_id,tex,lentext,xtext,ytext
  generic plotter library
  pltext writes the character string 'tex' of length 'lentext' at the
  position defined by 'xtext' and 'ytext' with current values for size
  and slope of characters
 </PRE>
<A NAME="pltext_hp">
 <H3>pltext_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pltext_hp(pl_id,tex,lentext,xtext,ytext)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pltext_ps">
 <H3>pltext_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pltext_ps(pl_id,tex,lentext,xtext,ytext)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="pltextdir">
 <H3>pltextdir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlib.for"> /usr/local/gifa/source/plotlib.for </A> 
 <PRE>       subroutine pltextdir(pl_id,angle)
  IN	: pl_id,angle
  generic plotter library
  pltextdir sets the values of the angle.. strings to be
  written on the plotter
 </PRE>
<A NAME="pltextdir_hp">
 <H3>pltextdir_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine pltextdir_hp(pl_id,text_angle)
  HPGL version of the generic plotter call
 </PRE>
<A NAME="pltextdir_ps">
 <H3>pltextdir_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine pltextdir_ps(pl_id,angle)
  Postscript version of the generic plotter call
 </PRE>
<A NAME="polyarb">
 <H3>polyarb</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/polyarb.for"> /usr/local/gifa/source/polyarb.for </A> 
 <PRE>       subroutine polyarb (svd,nsignals,data,sizdat,ab,order,
      &	nd1,u,v,wk,a,b)
  IN	: svd,nsignals,data,sizdat,,order,nd1,u,v
  OUT	: ab
  WORK	: wk,a,b
  Calculate the coefficient of backward prediction error polynomial
  complex*16 svd(nsignals) singular values
  complex*16 u(nd1,nd1) v(order,order) transformation matrices
  complex data(sizdat)
  complex*16 a(sizdat),b(sizdat),wk(sizdat) working area
  ab(order) coefficient of backward prediction error polynome
 
 </PRE>
<A NAME="polyarf">
 <H3>polyarf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/polyarf.for"> /usr/local/gifa/source/polyarf.for </A> 
 <PRE>       subroutine polyarf (svd,nsignals,data,sizdat,af,order,
      &		nd1,u,v,wk,b,a)
  IN	: svd,nsignals,data,sizdat,order,nd1,u,v
  OUT	: af
  WORK	: wk,b,a
  Calculate the forward prediction error polynome from the svd and u,v
  complex*16 svd(nsignals),u(nd1,nd1),v(order,order) singular values
  and transformation matrices
  complex data(sizdat)
  complex*16 af(order) polynomial coefficients
  complex*16 wk(sizdat),b(sizdat) working areas
 
 </PRE>
<A NAME="polynom">
 <H3>polynom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/polynom.for"> /usr/local/gifa/source/polynom.for </A> 
 <PRE>       subroutine polynom (root,coeff,order,ar)
  IN	: root,order,ar
  OUT	: coeff
 
  Caculate the coefficients of polynome knowing the roots
  coeff(0:order) : complex*16 PE coefficients
  ar(1:order) : complex*16 AR coefficients
  root(1:order) : complex*16 roots
  order : degree of polynome
 
 </PRE>
<A NAME="popval">
 <H3>popval</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine popval(val,err)
  OUT	: val,err
  SIDE	: val stack
 
  pop from value stack the value "val"
 
 </PRE>
<A NAME="postprm1d">
 <H3>postprm1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine postprm1d(chi2,nbpt,cnt,cov,tdx,ajus,verbose)
  IN	: cnt,verbose,cov,tdx,ajus,chi2,nbpt
  SIDE	: 1d peak table
  this subroutine copies the working buffer of line fitting
  back to the 1d peak table
 
  as well as extracts the errors from the covariance matrix
  computed at the end of the line fitting
 
 
 
 </PRE>
<A NAME="postprm2d">
 <H3>postprm2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine postprm2d(chi2,nbpt,cnt,cov,tdx,ajus,verbose)
  IN	: cnt,verbose,chi2,nbpt,...
  SIDE	: 1d peak table
  this subroutine copies the working buffer of line fitting
  back to the 2d peak table
  called at the end of the line fitting
 
 
 
 </PRE>
<A NAME="powell">
 <H3>powell</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/powell.for"> /usr/local/gifa/source/powell.for </A> 
 <PRE>       subroutine powell(func,func1d,size,p,iter,miter,
      *                    tol,fmini,verb,err)
  IN	: func,func1d,size,iter,miter,tol,verb
  OUT	: fmini
  INOUT	: p,err
 
   Computes the minimum of the real function func, using the conjugate gradient
  method. func(x,size) where x is a vector size-dimentionnal vector
  - func(x(size),size) : function to minimize
  - func1d(y) : real version of func
      No need of a derivative !
 
  - size : size of the vectors
  - p(size) : initial value, returns the minimum found in p
  - fmini : on output  minimum found
  - iter : number max of iterations
  - miter : number max of iterations for line minisation
            if 0.0 do standard steps, fmini is then used on input as initial
            step
  - tol : epsilon of the minimization.
  - err : set to 1 if error
  - verb : if 1, verbose output
  
  Adapted from Numerical Recipes
 
 </PRE>
<A NAME="powtwo">
 <H3>powtwo</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine powtwo(n,m)
  IN	: n
  OUT	: m
 
     Verify that n is power of two
      m is the difference between n and next power of two
  i.e.  n=2**P+m with   0 <= m   and m minimum
 
 </PRE>
<A NAME="prcvect">
 <H3>prcvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  prcvect(a,l,size)
  IN	: l,size
  OUT	: a
 
  PRCVECT(A,L,N) propagates scalar L (complex) into vector A (complex)
  
 </PRE>
<A NAME="prdvect">
 <H3>prdvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  prdvect(a,l,size)
  IN	: l,size
  OUT	: a
 
  PRDVECT(A,L,N) propagates scalar L (real*8) into vector A (real*8)
  
 </PRE>
<A NAME="pre_execute">
 <H3>pre_execute</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void pre_execute(command)
 String command;
 </PRE>
<A NAME="predloc">
 <H3>predloc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE> 	subroutine predloc(rdata,order,szdata,szfin,verbose,error)
  IN	: order,szdata,szfin,verbose,error
  OUT	: rdata
 
  Predict the following points of the FID from LP parameters
  without using any working space
 
 </PRE>
<A NAME="prepprm1d">
 <H3>prepprm1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine prepprm1d(tofit,nbp,tdx,start,end,verbose,actif,err)
  IN	: tofit,start,end,verbose
  OUT	: tdx,actif
  INOUT	: nbp,err
 
  Select pics which are chosed, as found in peak()
  Select parameters,between start and end,which will be fitted
  Number of peaks found is nbp
 
 
 
 </PRE>
<A NAME="prepprm2d">
 <H3>prepprm2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine prepprm2d(tofit,nbp,tdx,start2,start1,end2,end1,
      *           verbose,actif,err)
  IN	: tofit,start2,start1,end2,end1,verbose
  OUT	: tdx,actif
  INOUT	: nbp,err
 
  Select pics which are chosed, as found in peak()
  Select parameters,between start2,start1,end2,end1 which will be fitted
  Number of peaks found is nbp
  as found in peak()
 
 
 </PRE>
<A NAME="prfacti3e">
 <H3>prfacti3e</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/facti3e.for"> /usr/local/gifa/source/facti3e.for </A> 
 <PRE> 	subroutine prfacti3e (ar,szar,zn,coeff,rootr,rooti)
  IN	: ar,szar,zn,coeff
  OUT	: rootr,rooti
 
  Prepare the input for subroutine specc, from the AR coefficients
  complex*16 ar(szar): AR coefficients
  conplex*16 zn(szar): roots
 
 </PRE>
<A NAME="printdt">
 <H3>printdt</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/cache_mad.c"> /usr/local/gifa/source/cache_mad.c </A> 
 <PRE> void printdt(DATASET *dt)
 /*
 	used for debugging
 */
 </PRE>
<A NAME="printit">
 <H3>printit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine printit(file_name)
  IN	: file_name
 
  send the file file_name to the printer through the shell script
  gifaprint
 
 </PRE>
<A NAME="printstack">
 <H3>printstack</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine printstack(current)
  IN	: current
  
  prints out the content of the stacks, used for debugging
 
 </PRE>
<A NAME="prodmat">
 <H3>prodmat</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine prodmat (diag,arrayin,arrayout,size,sized,sizdat)
  IN	: diag,arrayin,size,sized,sizdat
  OUT	: arrayout
 
  PRODMAT(D,A,B,N,M,P) Calculate the product of matrix A(M,N) (leading dimension P)
  with diagonal matrix D(M) and put the result into B(M,N) (leading dimension P)
 
 
 </PRE>
<A NAME="proj3dadd">
 <H3>proj3dadd</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine proj3dadd(proj,smx,si1,si2,si3,axis,from,to)
  IN	: smx,si1,si2,si3,axis,from,to
  OUT	: proj
  performs a 3D additive projection along axis (1,2,3)
 </PRE>
<A NAME="proj3dmax">
 <H3>proj3dmax</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine proj3dmax(proj,smx,si1,si2,si3,axis,from,to)
  IN	: smx,si1,si2,si3,axis,from,to
  OUT	: proj
  performs a 3D skyline projection along axis (1,2,3)
 </PRE>
<A NAME="projadd">
 <H3>projadd</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine projadd(vect,image,si1,si2,axis,from,to)
  IN	: image,si1,si2,axis,from,to
  OUT	: vect
 
  performs the additive projection of the 2D image, along axis (1=si1, 
  2 = si2), for the subsection from-to, and put the result in vect.
 
 </PRE>
<A NAME="projmax">
 <H3>projmax</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine projmax(vect,image,si1,si2,axis,from,to)
  IN	: image,si1,si2,axis,from,to
  OUT	: vect
 
  performs the skyline projection of the 2D image, along axis (1=si1, 
  2 = si2), for the subsection from-to, and put the result in vect.
 </PRE>
<A NAME="prolonge">
 <H3>prolonge</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/approx.for"> /usr/local/gifa/source/approx.for </A> 
 <PRE>       subroutine prolonge(trace,size,i1,y10,y11,i2,y20,y21,y2) 
 
  IN	: trace,size (??)
  OUT	: y10,y11,i2,y20,y21,y2 (??)
  computes the best polynomial approximation (??)
 
 </PRE>
<A NAME="prpvect">
 <H3>prpvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  prpvect(a,l,size)
  IN	: l,size
  OUT	: a
 
  PRPVECT(A,L,N) propagates the value of the scalar L into vector A
  
 </PRE>
<A NAME="ptoi">
 <H3>ptoi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ptoi(ppm,size,specw,off,freq)
  integer version of ptoir (i.e. index is integer)
 </PRE>
<A NAME="ptoir">
 <H3>ptoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ptoir(ppm,size,specw,off,freq)
  IN	: ppm,size,specw,off,freq
 
  returns index from ppm value
 
 </PRE>
<A NAME="ptoview">
 <H3>ptoview</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> float ptoview(vd_id, axe, ppm)
 int	vd_id;
 int	axe;   /* 1 (F1) or 2 (F2) */
 float   ppm;
 
 /* computes window (0..1) coordinates from ppm value 
    for the view vd_id, using stored internal parameters*/
 </PRE>
<A NAME="pushval">
 <H3>pushval</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine pushval(val,err)
  IN	: val
  OUT	: err
  SIDE	: val stack
 
  push on value stack the value "val"
 
 </PRE>
<A NAME="putbit">
 <H3>putbit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine putbit(a,bit)
  IN	: a,bit
  SIDE	: offset, buffer
 
  put the the word "a" of length "bit" bits using variables offset and buffer
  in common
 </PRE>
<A NAME="putcol">
 <H3>putcol</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools2d.for"> /usr/local/gifa/source/tools2d.for </A> 
 <PRE>        subroutine putcol(col,mat,number,size1,size2)
  IN	: col,number,size1,size2
  INOUT	: mat
 
   put back "co"l, as a column into matrix "mat" at index "number"
 
 </PRE>
<A NAME="putplane">
 <H3>putplane</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/putplane.for"> /usr/local/gifa/source/putplane.for </A> 
 <PRE>        subroutine putplane(plane,cube,
      *                     size1,size2,size3,index) 
  IN	: plane,size1,size2,size3,index
  INOUT	: cube
 
  puts a plane F1 (F2-F3) at "index" into a cube(size1,size2,size3)
 
 </PRE>
<A NAME="putplane2">
 <H3>putplane2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/putplane.for"> /usr/local/gifa/source/putplane.for </A> 
 <PRE>        subroutine putplane2(plane,cube,
      *                     size1,size2,size3,index) 
  IN	: plane,size1,size2,size3,index
  INOUT	: cube
 
  puts a plane F2 (F1-F3) at "index" into a cube(size1,size2,size3)
 
 
 </PRE>
<A NAME="putplane3">
 <H3>putplane3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/putplane.for"> /usr/local/gifa/source/putplane.for </A> 
 <PRE>        subroutine putplane3(plane,cube,
      *                     size1,size2,size3,index) 
  IN	: plane,size1,size2,size3,index
  INOUT	: cube
 
  puts a plane F3 (F1-F2) at "index" into a cube(size1,size2,size3)
 
 
 </PRE>
<A NAME="qaddvect">
 <H3>qaddvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  qaddvect(arrayout,B,C,l,size)
  IN	: B,C,l,size
  OUT	: arrayout
 
  QADDVECT(A,B,C,L,N) put in A the vector (1-L)*B + L*C
  negative values in are forbidden by exponential smoothing for L > 1
 
  Arrayout, B and C may be the same vector
 
 </PRE>
<A NAME="qfunc">
 <H3>qfunc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/itergull.for"> /usr/local/gifa/source/itergull.for </A> 
 <PRE>       function qfunc(x)
  IN	: x
 
  returns the value of the Q MaxEnt function for an offset x
  from current position along the gradient
 
 </PRE>
<A NAME="randomd">
 <H3>randomd</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/random.for"> /usr/local/gifa/source/random.for </A> 
 <PRE>       function randomd(idum)
  INOUT	: idum
 
  return a uniform random deviate between 0 and 1
  form Num. Recipes p197
  reinitialized if idum<0
 
 
 </PRE>
<A NAME="rcopvect">
 <H3>rcopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  rcopvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  RCOPVECT(A,B,N) copy the real vector B, of size N into vector A 
  of size N. The copy is done by starting at the end of the vector A
 
 </PRE>
<A NAME="rcryst">
 <H3>rcryst</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/redfield.for"> /usr/local/gifa/source/redfield.for </A> 
 <PRE>       subroutine rcryst (data,sizdat,specw,offset,phas,width,amp,
      &		freq,order,ki2,rfactor)
  IN	: data,sizdat,specw,offset,phas,width,amp,freq,order,ki2
  OUT	: rfactor
  part of the build-up curve analysis
 
  Calculate a "R factor" to check the quality of multi-exponentials
  analysis.
  real data(sizdat) build-up curve's data
  real width(order),amp(order),phas(order),freq(order) : signal parameters 
  obtained by data-processing.
  integer order : number of exponentials detected.
  integer sizdat : considered size of data, can be lesser then the total size
  real specw : spectral width, should be the same that the used one in
  linear prediction processing
  real rfactor : "R factor" between real part of experimental and 
  calculated data.
  real ki2 : ki2 function between real part of experimental and calculated data.
 
 </PRE>
<A NAME="readc">
 <H3>readc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readc.for"> /usr/local/gifa/source/readc.for </A> 
 <PRE>        subroutine readc (name,spec,size1,size2,specw1,
      &		specw2,off1,off2,itype) 
  IN	: name
  OUT	: spec,size1,size2,specw1,specw2,off1,off2,itype
 
  reads-in a file in LPC compressed format
 
 </PRE>
<A NAME="readdata">
 <H3>readdata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/t1fit.for"> /usr/local/gifa/source/t1fit.for </A> 
 <PRE>       subroutine readdata()
 </PRE>
<A NAME="readmask">
 <H3>readmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine readmask(name,tab,taille1,taille2,error)
 
  read all the peak amoeba from a file
 
  IN	: amoeba
  OUT   : error
 
 </PRE>
<A NAME="readnew">
 <H3>readnew</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readnew.for"> /usr/local/gifa/source/readnew.for </A> 
 <PRE>        subroutine readnew(spec,name,error)
 
 </PRE>
<A NAME="readparam1d">
 <H3>readparam1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readparam.for"> /usr/local/gifa/source/readparam.for </A> 
 <PRE>        subroutine readparam1d(file)
  this subroutine reads-in paramater block of the file, (if any)
 
 </PRE>
<A NAME="readparam2d">
 <H3>readparam2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readparam.for"> /usr/local/gifa/source/readparam.for </A> 
 <PRE>        subroutine readparam2d(file)
  this subroutine reads-in paramater block of the file, (if any)
 
 </PRE>
<A NAME="readparam3d">
 <H3>readparam3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readparam3d.for"> /usr/local/gifa/source/readparam3d.for </A> 
 <PRE>        subroutine readparam3d(file)
  this subroutine reads-in paramater block of the file, (if any)
 
 </PRE>
<A NAME="readscdata">
 <H3>readscdata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readtc3d.for"> /usr/local/gifa/source/readtc3d.for </A> 
 <PRE>        subroutine readscdata(spec,size1,size2,size3,
      *                const,error)
 
  this subroutine reads the data which are characters (reals 
  writen in base 64) and return the correspondant 
  reals.
 
 </PRE>
<A NAME="readsdata">
 <H3>readsdata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readt3d.for"> /usr/local/gifa/source/readt3d.for </A> 
 <PRE>        subroutine readsdata(spec,si1,si2,si3,error)
  IN	: si1,si2,si3
  OUT	: spec,error
 
  reads in a text format file
  used by readt3d
 
 </PRE>
<A NAME="readt3d">
 <H3>readt3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readt3d.for"> /usr/local/gifa/source/readt3d.for </A> 
 <PRE>        subroutine readt3d(spec,name,error)
  IN	: name
  OUT	: error,spec
  SIDE	: in dataset parameters
 
  reads in a file in text format
 
 </PRE>
<A NAME="readtc3d">
 <H3>readtc3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/readtc3d.for"> /usr/local/gifa/source/readtc3d.for </A> 
 <PRE>        subroutine readtc3d(name,error)
 
 
 </PRE>
<A NAME="readval">
 <H3>readval</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine readval(st,zz,error)
  IN	: st
  OUT	: zz,error
 
  interprets string st as a number, returned in zz
 
 </PRE>
<A NAME="real1d">
 <H3>real1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine real1d(image,size)
  INOUT	: image,size
 
  throw away the imaginaty part of the interleaved complex vector image
 
 </PRE>
<A NAME="real2d">
 <H3>real2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine real2d(image,size1,size2,mode)
  IN	: mode
  INOUT	: image,size1,size2
 
  real2d extract the RR part of the 2D bicomplex array image, and put it
  back in image changed to 2D real, size1 and size2 then refer to real.
 
 
 </PRE>
<A NAME="real3d">
 <H3>real3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/real3d.for"> /usr/local/gifa/source/real3d.for </A> 
 <PRE>       subroutine real3d(image,size1,size2,size3,mode)
  IN	: mode
  INOUT	: image,size1,size2,size3
 
  real3D extract the RRR part of the 3D 3complex array image, and put it
  back in image changed to 3D real, size1 size2 and size3 then refer to real.
 
 
 </PRE>
<A NAME="recalcdat">
 <H3>recalcdat</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/recalcdat.for"> /usr/local/gifa/source/recalcdat.for </A> 
 <PRE>       subroutine recalcdat (svd,nsignals,data,sizdat,order,
      &	nd1,u,v,x)
  IN	: svd,nsignals,data,sizdat,order,nd1,u,v
  OUT	: x
 
  Recalculate the Toeplitz data matrix x from the svd and u,v
  complex*16 svd(nsignals),u(nd1,nd1),v(order,order) singular values
  and transformation matrices
  complex data(sizdat)
 
 </PRE>
<A NAME="recherche_var">
 <H3>recherche_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void recherche_var(varname,value,context)
 char *varname, *value;
 int context;
 /*-------------------------------------------------------------
 *       void recherche_var(varname,value,context)
 *
 *       IN:varname,context
 *       INOUT: value
 *
 *       Recherche de la variable dans le contexte
 *               si elle existe: recuperation de sa valeur
 *               si elle n'existe pas: creation de la variable dans le contexte
 *       var:
 *               char *varname; pt sur la variable
 *               char *value; pt sur la valeur de la variable
 *               int context; id widget = context of variable
 */
 </PRE>
<A NAME="recode">
 <H3>recode</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine recode(st,l)
  INOUT   st
  IN      l
 
  reset   char(127) to blanks in string
 </PRE>
<A NAME="redfield">
 <H3>redfield</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/redfield.for"> /usr/local/gifa/source/redfield.for </A> 
 <PRE>       subroutine redfield (phas,width,amp,order,redf,specw)
  IN	: phas,width,amp,order
 ,specw
  OUT	: redf
 
  part of the build-up curve analysis
  Calculate relaxation rate from the amplitudes and width
  calculated by build-up curves processing. The detected composantes
  should be real.
  real width(order),amp(order),phase(order) : signal parameters calculated
  by linear prediction method.
  real redf : relaxation rate
  integer order : number of exponentials detected.
  real specw : spectral width, should be the same that the used one in
  linear prediction processing
 
 </PRE>
<A NAME="reflect">
 <H3>reflect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/roots.for"> /usr/local/gifa/source/roots.for </A> 
 <PRE>       subroutine reflect (zn,order)
  IN	: order
  INOUT	: zn
 
  part of the LPSVD package
 
  Calculate the inverse conjugates of the roots which are outside 
  of unity circle
 
 </PRE>
<A NAME="refresh_copy">
 <H3>refresh_copy</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void refresh_copy(w, donnees, appel)
 Widget          w;              /*  widget id           */
 donnees_pixmap	*donnees;
 XmDrawingAreaCallbackStruct	*appel;
 </PRE>
<A NAME="refresh_icon">
 <H3>refresh_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void refresh_icon()
 </PRE>
<A NAME="refresh_widg">
 <H3>refresh_widg</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void refresh_widg(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="refresh_widg_1d">
 <H3>refresh_widg_1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void refresh_widg_1d(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer 	call_data;	
 </PRE>
<A NAME="rempixmask">
 <H3>rempixmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine rempixmask(crdx,crdy,nopk,error)
 
  remove the pixel (crdx,crdy) from the amoeba of peak nopk
  Be careful: before using this subroutine, you must check that 
  the pixel belongs to the amoeba 
 
  IN	: crdx,crdy,nopk
  OUT	: amoeba
 
 </PRE>
<A NAME="replam">
 <H3>replam</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/replam.for"> /usr/local/gifa/source/replam.for </A> 
 <PRE>        subroutine replam(masktab,taille1,taille2,
      *    nopkold,nopknew)
 
  makstab(taille1,taille2): amobea array
  nopkold: old peak number
  nopknew: new peak number
  
  IN    : masktab,taille1,taille2,nopkold,nopknew
  OUT   : masktab
 
  replace the amoeba of peak number nopkold by the peak number nopknew
 
 </PRE>
<A NAME="reset_all">
 <H3>reset_all</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine reset_all()
  reset all display parameters, and clear point_stack
 
 </PRE>
<A NAME="resize_copy">
 <H3>resize_copy</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void resize_copy(w, donnees, appel)
 Widget          w;
 caddr_t  donnees;
 XmDrawingAreaCallbackStruct     *appel;
 </PRE>
<A NAME="resize_icon">
 <H3>resize_icon</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void resize_icon(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;
 </PRE>
<A NAME="revvect">
 <H3>revvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  revvect(array,size)
  IN	: size
  INOUT	: array
 
  REVVECT(A,N) reverse the order of the vector A and put the result back
               into A
 
 </PRE>
<A NAME="rlg_execute">
 <H3>rlg_execute</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_main.c"> /usr/local/gifa/source/X_main.c </A> 
 <PRE> void rlg_execute(char *tt)
 </PRE>
<A NAME="rotation">
 <H3>rotation</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rotation.for"> /usr/local/gifa/source/rotation.for </A> 
 <PRE>           subroutine rotation(matrix,si1,si2,iter,miter,tol,verb)
 
  part of diagonalisation package, ROTATION command
 
 </PRE>
<A NAME="rotation_F123CB">
 <H3>rotation_F123CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void rotation_F123CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="rotation_F12CB">
 <H3>rotation_F12CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void rotation_F12CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="rotation_F13CB">
 <H3>rotation_F13CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void rotation_F13CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="rotation_F23CB">
 <H3>rotation_F23CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_env3d.c"> /usr/local/gifa/source/X_env3d.c </A> 
 <PRE> void rotation_F23CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="round">
 <H3>round</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotaxis.for"> /usr/local/gifa/source/plotaxis.for </A> 
 <PRE>       function round(x)
  
 </PRE>
<A NAME="rrrup">
 <H3>rrrup</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine rrrup()
  internal 3D library
 
  updates rotation matrix
 
 </PRE>
<A NAME="rs">
 <H3>rs</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rs_diag.for"> /usr/local/gifa/source/rs_diag.for </A> 
 <PRE>       subroutine rs(nm,n,a,w,matz,z,fv1,fv2,ierr)
 
 
      this subroutine calls the recommended sequence of
      subroutines from the eigensystem subroutine package (eispack)
      to find the eigenvalues and eigenvectors (if desired)
      of a real symmetric matrix.
 
      on input
 
         nm  must be set to the row dimension of the two-dimensional
         array parameters as declared in the calling program
         dimension statement.
 
         n  is the order of the matrix  a.
 
         a  contains the real symmetric matrix.
 
         matz  is an integer variable set equal to zero if
         only eigenvalues are desired.  otherwise it is set to
         any non-zero integer for both eigenvalues and eigenvectors.
 
      on output
 
         w  contains the eigenvalues in ascending order.
 
         z  contains the eigenvectors if matz is not zero.
 
         ierr  is an integer output variable set equal to an error
            completion code described in the documentation for tqlrat
            and tql2.  the normal completion code is zero.
 
         fv1  and  fv2  are temporary storage arrays.
 
      questions and comments should be directed to burton s. garbow,
      mathematics and computer science div, argonne national laboratory
 
      this version dated august 1983.
 
      ------------------------------------------------------------------
 
 </PRE>
<A NAME="rselect">
 <H3>rselect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/roots.for"> /usr/local/gifa/source/roots.for </A> 
 <PRE>       subroutine rselect (zn,index,new,order,szind)
  IN	: index,order
  INOUT	: zn
  OUT	: new
 
  part of the LPSVD package
 
  Keep only the roots whose index are given ; new is new order
 
 </PRE>
<A NAME="rtcvect">
 <H3>rtcvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  rtcvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  RTCVECT(A,B,N) copy the real vector B into the real part of the complex
                 vector A, and put 0 in the imaginary part.
                    A AND B CANNOT BE EQUIVALENCED
 
 </PRE>
<A NAME="rtfreq">
 <H3>rtfreq</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/redfield.for"> /usr/local/gifa/source/redfield.for </A> 
 <PRE>       subroutine rtfreq (zn,order,index,alpha,szind)
  IN	: alpha
  INOUT	: zn,order
  WORK	: index
 
  part of the build-up curve analysis
 
  Keep only the roots whose frequence=0, the others roots are put on the real 
  axis with values zr+zi and zr-zi, where zr and zi are real and imaginary 
  the roots with too big imaginary parts are removed
  parts of zn 
  complex*16 zn(order) : roots 
  complex*16 wk(order) : working array 
  integer index(order) : working array 
  integer order : number of roots
  real  alpha : parameter determining the cone extent where the roots
  are pivoted.
 
 </PRE>
<A NAME="save_matlab">
 <H3>save_matlab</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/matlab.for"> /usr/local/gifa/source/matlab.for </A> 
 <PRE> 	subroutine save_matlab(file_nm, matrix, line, col, error)
  IN	: file_nm, matrix, line, col,
  OUT	: error
 
  write matrix(col, line) as a matlab compatible file
 
 </PRE>
<A NAME="sdcopvect">
 <H3>sdcopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  sdcopvect(arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  SDCOPVECT(A,B,N) copy the real*4 vector B, of size N into real*8 vector A 
  of size N
 
 </PRE>
<A NAME="searchamb">
 <H3>searchamb</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/searchamb.for"> /usr/local/gifa/source/searchamb.for </A> 
 <PRE>        subroutine searchamb(nopk,masktab,taille1,taille2)
  tab(taille1,taille2): 2D experiment array
  makstab(taille1,taille2): amobea array
  
  IN	: tab,masktab,taille1,taille2,nopk
 
  search in masktab, for the pixels located in the amoeba of peak nopk
 </PRE>
<A NAME="segm2_auto">
 <H3>segm2_auto</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segsec.for"> /usr/local/gifa/source/segsec.for </A> 
 <PRE>       subroutine segm2_auto(portion,size,seuil)
  part of BCORR 3
 
 </PRE>
<A NAME="segm2_inter">
 <H3>segm2_inter</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segsec.for"> /usr/local/gifa/source/segsec.for </A> 
 <PRE>       subroutine segm2_inter(size,portion)
  part of BCORR 3
 
 </PRE>
<A NAME="selectprm1d">
 <H3>selectprm1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit1d.for"> /usr/local/gifa/source/fit1d.for </A> 
 <PRE>       subroutine selectprm1d(nbp,tdx,start,end,verbose,actif,err)
  IN	: start,end,verbose
  OUT	: tdx,actif
  INOUT	: nbp,err
 
  Select pics which are chosed, as found in peak()
  Select parameters,between start and end,which will be fitted
  Number of peaks found is nbp
 
 
 
 </PRE>
<A NAME="selectprm2d">
 <H3>selectprm2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/fit2d.for"> /usr/local/gifa/source/fit2d.for </A> 
 <PRE>       subroutine selectprm2d(nbp,tdx,start2,start1,end2,end1,
      *          verbose,actif,err)
  IN	: start2,start1,end2,end1,verbose
  OUT	: tdx,actif
  INOUT	: nbp,err
 
  Select pics which are chosed, as found in peak()
  Select parameters,between start2,start1,end2,end1, which will be fitted
  Number of peaks found is nbp
 
 
 
 </PRE>
<A NAME="set_area_var">
 <H3>set_area_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_area_var()
 </PRE>
<A NAME="set_dim1CB">
 <H3>set_dim1CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_dim1CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="set_dim2CB">
 <H3>set_dim2CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_dim2CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="set_dim3CB">
 <H3>set_dim3CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_dim3CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="set_label_scale">
 <H3>set_label_scale</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_formulaire.c"> /usr/local/gifa/source/X_formulaire.c </A> 
 <PRE> void set_label_scale(str_sc,val)
 ScaleStruct *str_sc;
 int val;
 /*-------------------------------------------------------------
 **     set_label_scale: mise a jour du label (valeur courante)
 **	du scale (CURSOR)
 */
 </PRE>
<A NAME="set_last_butt">
 <H3>set_last_butt</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine set_last_butt(butt)
  set last variable paraneters
 </PRE>
<A NAME="set_phase_var">
 <H3>set_phase_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine set_phase_var(spectrum,x0,wid,pc0,p1,flag)
  set last variable parameters
  flag determines action :
        init = 0
        cancel = 1
        phasing = 2
        Ok = 3
 
 </PRE>
<A NAME="set_pivot_phase">
 <H3>set_pivot_phase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_phase.c"> /usr/local/gifa/source/X_phase.c </A> 
 <PRE> void set_pivot_phase(flag)
 int flag;
 </PRE>
<A NAME="set_point_xy">
 <H3>set_point_xy</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>        subroutine set_point_xy(xmouse,ymouse)
  set point parameters:
 	
 
 </PRE>
<A NAME="set_scale">
 <H3>set_scale</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine set_scale(flag)
 
  IN : flag
 
    code de flag :
                1 -> / 2
                2 -> * 2
                3 -> - 20%
                4 -> + 20 %
 
 </PRE>
<A NAME="set_select_var">
 <H3>set_select_var</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine set_select_var(ll1, ll2, ur1, ur2)
 
  IN : ll1, llf2, ur1, ur2
 
 
 </PRE>
<A NAME="set_var_3d">
 <H3>set_var_3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine set_var_3d(vd_id,setalpha,setbeta,
      *        setgama,setsc3d,setz0,
      *        setox,setoy,setoz,setdx3d,
      *        setdy3d,setdz3d)
 
  set last variable parameters
 </PRE>
<A NAME="set_viewfinder">
 <H3>set_viewfinder</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_viewfinder(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int             *vd_id;                 /*  id struct   */
 XEvent          *evt;
 /*
   sets evry thing up for the viewfinder thru all the active windows.
   Called the first time the user middle-clicks in a given window
 
 */
 </PRE>
<A NAME="set_vwf">
 <H3>set_vwf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void set_vwf(vd_id, x, y)
 int             *vd_id;                 /*  id struct   */
 float             x,y;
 /*
   sets-up view finder for each window.
 */
 </PRE>
<A NAME="set_zoom_coord">
 <H3>set_zoom_coord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine set_zoom_coord(ll1, ll2, ur1, ur2)
 
  IN :  ll1, ll2, ur1, ur2
 	For 2 D Only
 
 </PRE>
<A NAME="set_zoom_param">
 <H3>set_zoom_param</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine set_zoom_param(vd_id, zstat, ll1, ll2, ur1, ur2)
 
  IN : vd_id, zstat, ll1, ll2, ur1, ur2
  SIDE : zoom state
 
     This subroutine allows an interactive display of a spectrum.
 
    spectrum: spectrum to display
    vd_id: window in which the new phased spectra is drawn
    zstat, ul1,ul2,lr1,lr1 describe the zoom state, (in and out)
 
 </PRE>
<A NAME="set_zoom_zero">
 <H3>set_zoom_zero</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine set_zoom_zero()
  reset zoom parameters
 </PRE>
<A NAME="setpixmask">
 <H3>setpixmask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine setpixmask(crdx,crdy,nopk,error)
 
  create the amoeba of peak nopk if it does not exist, and 
  put the pixel (crdx,crdy) into this amoeba.
  IN	: crdx,crdy,nopk
  OUT	: amoeba
 
 </PRE>
<A NAME="setupctrlc">
 <H3>setupctrlc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>       subroutine setupctrlc
  This subroutine is used to initialize the control_c.
  It sets up a signal linked to control_C which executes the controlc subroutine
  which in turns set the control variable to 1.
  SUN has been set here same as SGI, not tested yet !
 </PRE>
<A NAME="setvar">
 <H3>setvar</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>        subroutine setvar(name,context,value,err)
  IN	: name,value,err,context
       set the content of the variable called "name"/"context" to "value"
 </PRE>
<A NAME="setvcontext">
 <H3>setvcontext</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine setvcontext(vcont)
 </PRE>
<A NAME="seuil">
 <H3>seuil</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segpri.for"> /usr/local/gifa/source/segpri.for </A> 
 <PRE>       subroutine seuil(debug,size)
  part of BCORR 3
 
 </PRE>
<A NAME="sexp">
 <H3>sexp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/itergull.for"> /usr/local/gifa/source/itergull.for </A> 
 <PRE>       function sexp(x)
  IN	: x
  this is the Home-made exponential function used to avoid explosive effects
  of the regular exp.
  aa is the point where the exp. is replaced by the tangent line.
 </PRE>
<A NAME="sgedi">
 <H3>sgedi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/sgedi.for"> /usr/local/gifa/source/sgedi.for </A> 
 <PRE>       subroutine sgedi(a,lda,n,ipvt,det,work,job)
 </PRE>
<A NAME="shell">
 <H3>shell</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine shell(params)
  IN	: params
  This subroutine passes the given string (params) to unix to process
   as a shell command.
 </PRE>
<A NAME="shift1">
 <H3>shift1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine shift1(aa,a,b,bb)
  IN	: a,b,bb
  OUT	: aa
  aa is a shifted left by b bits, masked to bb bits wide
  used by putbit
 </PRE>
<A NAME="shift2">
 <H3>shift2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine shift2(aa,a,b,bb)
  IN	: a,b,bb
  OUT	: aa
  aa is a shifted right by b bits, masked to bb bits wide
  and negative values are propagated
  used by getbit
 </PRE>
<A NAME="shift3">
 <H3>shift3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpcio.for"> /usr/local/gifa/source/lpcio.for </A> 
 <PRE> 	subroutine shift3(aa,a,b,bb)
  IN	: a,b,bb
  OUT	: aa
  same as shift2, but negative values are not propagated
  used by getbit
 </PRE>
<A NAME="shift_image">
 <H3>shift_image</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE> 	subroutine shift_image(vd_id, shift)
 
  IN : vd_id, shift
 
    spectrum: 1D spectrum to display
    vd_id: window in which the new image is drawn
    shift orientation :
 		1 -> up	
 		2 -> down
 		3 -> right
 		4 -> left
 
 </PRE>
<A NAME="show_timer">
 <H3>show_timer</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine show_timer
  This subroutine is used to display the elapsed time since the call
   to Init_timer was made.
 </PRE>
<A NAME="showlinetab">
 <H3>showlinetab</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showlinetab.for"> /usr/local/gifa/source/showlinetab.for </A> 
 <PRE>       subroutine showlinetab(vd_id,buffx,buffy,size,
      *       unt,offsetx,offsety)
 
  IN	: vd_id,buffx,buffy,size,unt,offsetx,offsety
 
  displays the content of (buffx,buffy) of length size
  buffx is interpreted in 'unt'
  buffy is interpreted as usual, with max0,scale,etc.. (from common)
 
 </PRE>
<A NAME="showpattern">
 <H3>showpattern</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showpattern.for"> /usr/local/gifa/source/showpattern.for </A> 
 <PRE>       subroutine showpattern(vd_id,x,y,px,py,pat)
  IN : vd_id   the id of the window to use
       x,y     coordinate of the pattern
       px,py   size of the pattern
       pat     type of pattern
 
   dispay a given pattern on screen
   coordinates are 'generalized' 0..1
   px,py are the size in 'generalized'.
   pat is :   x  cross
              +  plus
              *  star
              s  square
              d  diamond
              o  circle  (16 facetted)
              b  box ( + and s )
              
 
 </PRE>
<A NAME="showpeak1d">
 <H3>showpeak1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showpeak.for"> /usr/local/gifa/source/showpeak.for </A> 
 <PRE>       subroutine showpeak1d(zz,vd_id)
  display the peak zz on the 1D display vd_id
 </PRE>
<A NAME="showpeak2d">
 <H3>showpeak2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showpeak.for"> /usr/local/gifa/source/showpeak.for </A> 
 <PRE>       subroutine showpeak2d(zz,vd_id)
  display the peak zz on the 2D display vd_id
 </PRE>
<A NAME="showpeak3d">
 <H3>showpeak3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showpeak.for"> /usr/local/gifa/source/showpeak.for </A> 
 <PRE>       subroutine showpeak3d(zz,vd_id)
  display the peak zz on the 3D display vd_id
 </PRE>
<A NAME="showpeak3d2d">
 <H3>showpeak3d2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/showpeak.for"> /usr/local/gifa/source/showpeak.for </A> 
 <PRE>       subroutine showpeak3d2d(zz,vd_id)
  display the 3D peak zz on the 2D display vd_id
 </PRE>
<A NAME="sicopvect">
 <H3>sicopvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine sicopvect (arrayout,arrayin,size)
  IN	: arrayin,size
  OUT	: arrayout
 
  SICOPVECT(A,B,N) copy the integer vector B, of size N into real vector A 
 
 </PRE>
<A NAME="signtest">
 <H3>signtest</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writetc3d.for"> /usr/local/gifa/source/writetc3d.for </A> 
 <PRE>        subroutine signtest(cspeci2,especi2,csi2)
  
 </PRE>
<A NAME="simu2d">
 <H3>simu2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/simu2d.for"> /usr/local/gifa/source/simu2d.for </A> 
 <PRE>       subroutine simu2d(tdata,size1,size2,noise,it)
  OUT	: tdata,size1,size2,noise,it
 
  simulates a 2D FID
 
 </PRE>
<A NAME="simu3d">
 <H3>simu3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/simu3d.for"> /usr/local/gifa/source/simu3d.for </A> 
 <PRE>       subroutine simu3d(tdata,size1,size2,size3,noise,itype,err)
  OUT	: tdata,size1,size2,size3,noise,err
 
  simulates a 3D FID
 
 </PRE>
<A NAME="simunoe">
 <H3>simunoe</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/simunoe.for"> /usr/local/gifa/source/simunoe.for </A> 
 <PRE>         subroutine simunoe (fid,si1,si2,it,offset1
      $  	           ,offset2,sw1,sw2,nerr)
  IN	: si1,si2,it,offset1,offset2,sw1,sw2
  OUT	: fid,nerr
 
      This subroutine calculate the 2D spectrum from the intensities
  furnished by CORMA .
 
 </PRE>
<A NAME="sin2d">
 <H3>sin2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine sin2d(smx,size1,size2,mode,x,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by a sine bell.
  mode = 1 / 2 / 3  for F1, F2 F12 axes
  x ranges from 0.0 (pur cosine) to 0.5 pure sine
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="sin2mul">
 <H3>sin2mul</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/trigmult.for"> /usr/local/gifa/source/trigmult.for </A> 
 <PRE>       subroutine sin2mul(vect,size,x,itype)
  IN	: size,x,itype
  INOUT	: vect
 
  multply vect by a shifted sine bell squared
  0<= x <= 0.5       x = 0 is pure cosine,
                     x = 0.5 is pure sine
  itype = 1 means complex.
 
 </PRE>
<A NAME="sin3d">
 <H3>sin3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine sin3d(smx,si1,si2,si3,mode,x,it3d)
  IN	: si1,si2,si3,mode,x,it3d
  INOUT	: smx
 
  3D sine bell apodisation
  mode = 1 for si1
  mode = 2 for si2
  mode = 4 for si3
  and corresponding sums
 
 </PRE>
<A NAME="sinmul">
 <H3>sinmul</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/trigmult.for"> /usr/local/gifa/source/trigmult.for </A> 
 <PRE>       subroutine sinmul(vect,size,x,itype)
  IN	: size,x,itype
  INOUT	: vect
 
  multply vect by a shifted sine bell
  0<= x <= 0.5       x = 0 is pure cosine,
                     x = 0.5 is pure sine
  itype = 1 means complex.
 
 </PRE>
<A NAME="sinsq2d">
 <H3>sinsq2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine sinsq2d(smx,size1,size2,mode,x,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by a squared sine bell.
  mode = 1 / 2 / 3  for F1, F2 F12 axes
  x ranges from 0.0 (pur cosine) to 0.5 pure sine
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="sinsq3d">
 <H3>sinsq3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine sinsq3d(smx,si1,si2,si3,mode,x,it3d)
  IN	: si1,si2,si3,mode,x,it3d
  INOUT	: smx
 
  3D squared sine bell apodisation
  mode = 1 for si1
  mode = 2 for si2
  mode = 4 for si3
  and corresponding sums
 
 </PRE>
<A NAME="sizecompact">
 <H3>sizecompact</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lpbasic.for"> /usr/local/gifa/source/lpbasic.for </A> 
 <PRE>       subroutine sizecompact (rec,szar,szdata,code)
  IN	: rec,szar,szdata,code
 
  calculate size of compacted data
 
  szar : 2*order of burg
  rec(szdata) data compacted : first exp.data (szar), and deltas (rec(i+szar))
  between exp. data and calculated data with ar(szar)
 
 </PRE>
<A NAME="smavect">
 <H3>smavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine smavect(sum,array,size)
  IN	: array,size
  OUT	: sum
 
  SMAVECT(S,A,N) S is the sum of absolute value of element of vector A
 
 </PRE>
<A NAME="smooth1d">
 <H3>smooth1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/smooth.for"> /usr/local/gifa/source/smooth.for </A> 
 <PRE>       subroutine smooth1d(fdata,size,nsm)
  IN	: size,nsm
  INOUT	: fdata
 
     This subr. performs a Moving Average smoothing of the data, fdata(size)
  length of M.A. is nsm,
 
 </PRE>
<A NAME="smooth2d">
 <H3>smooth2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/smooth.for"> /usr/local/gifa/source/smooth.for </A> 
 <PRE>       subroutine smooth2d(fdata,size1,size2,nsm1,nsm2)
  IN	: size1,size2,nsm1,nsm2
  INOUT	: fdata
 
     This subr. performs a Moving Average smoothing of the data, 
  fdata(size2,size1) is real
  length of M.A. is nsm1 in dim 1 (vertical) and nsm2 in dim 2
  pad with zero lost points.
 </PRE>
<A NAME="smooth3d">
 <H3>smooth3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/smooth.for"> /usr/local/gifa/source/smooth.for </A> 
 <PRE>       subroutine smooth3d(fdata,size1,size2,size3,nsm1,nsm2,nsm3)
  IN	: size1,size2,size3,nsm1,nsm2,nsm3
  INOUT	: fdata
 
     This subr. performs a Moving Average smoothing of the data, 
  fdata(size3,size2,size1) is real
  length of M.A. is nsm1 in dim 1 (vertical), nsm2 in dim 2 and
  nsm3 in dim 3
  pad with zero lost points.
 </PRE>
<A NAME="specc">
 <H3>specc</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/facti3e.for"> /usr/local/gifa/source/facti3e.for </A> 
 <PRE> 	subroutine	specc(coef,rootr,rooti,ncoef)
 	Specc.for		Version 1 26/4/1990	Patrice Koehl
 
 	This subroutine evaluates the roots of a polynomial with complex
 	coefficient, using the method described by Svejgaard, in Bit 7 (1967)
 	p240-246
 
 
 	Input :		- COEF	complex coefficient of the polynomial
 			  coef(1) is the coefficient of x**0, and coef(ncoef)
 			  is the coefficient of x**(ncoef-1)
 			- NCOEF	number of coefficient ( i.e. the order of the
 			  	polynomial is NCOEF-1)
 	Output :	- ROOTR	is the real part of the solution
 			- ROOTI is the complex part of the solution
 
 	Beware :
 		1) on output, roots are stored in positions 2 to NCOEF of
 		arrays rootr and rooti
 		2) works in double precision (real*8 and complex*16)
 
 </PRE>
<A NAME="spline">
 <H3>spline</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/linecorr.for"> /usr/local/gifa/source/linecorr.for </A> 
 <PRE>       subroutine spline(tb,size,parm)
  IN	: tb,size
  OUT	: parm
 
  given the function tabulated in tb(2,size), this subroutine computes
  the parameters for the spline interpolation of this function.
  tb is such that: f(tb(1,i)) = tb(2,i).
  parameters are returned in parm(sztb)
  supposes that "tb" is ordered in ascending order for "tb(1,i)"
 
 </PRE>
<A NAME="sswapbyte">
 <H3>sswapbyte</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/reversebyte.c"> /usr/local/gifa/source/reversebyte.c </A> 
 <PRE> void sswapbyte(char *buffer, int size)
 /* single swap byte for big_endian machines */
 
 </PRE>
<A NAME="stackop">
 <H3>stackop</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine stackop(code,codeprio,length)
  IN	: code,codeprio,length
  SIDE	: he, oper stack
 
  push on operator stack the operator "code" with priority "prio", and
  increment the he pointer by length
 
 </PRE>
<A NAME="stddev">
 <H3>stddev</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/segpri.for"> /usr/local/gifa/source/segpri.for </A> 
 <PRE>       subroutine stddev(debug,size)
  part of BCORR 3
 </PRE>
<A NAME="stock_mouse_coord">
 <H3>stock_mouse_coord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void stock_mouse_coord(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int             *vd_id;
 XEvent          *evt;      /*  data from widget class  */
 
 /*
 	stocke les coordonnees x et y de la souris
 */
 </PRE>
<A NAME="stockpic">
 <H3>stockpic</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/stockpic.for"> /usr/local/gifa/source/stockpic.for </A> 
 <PRE>       subroutine stockpic(tablo,si1,si2,min,max,nombre,signpic,zq,
      *                    zoom,zolf1,zolf2,zour1,zour2)
 
 </PRE>
<A NAME="stockpoint">
 <H3>stockpoint</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/stockpoint.for"> /usr/local/gifa/source/stockpoint.for </A> 
 <PRE>       subroutine stockpoint(tablo,si,min,max,nombre,signpic
      *                      ,zoom,zol,zou)
 
 </PRE>
<A NAME="stoi">
 <H3>stoi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function stoi(second,specw)
  integer version of stoir (i.e. index is integer)
 </PRE>
<A NAME="stoir">
 <H3>stoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function stoir(second,specw)
  IN	: second,specw
 
  returns index from second value
 
 </PRE>
<A NAME="stop_processCB">
 <H3>stop_processCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_util.c"> /usr/local/gifa/source/X_util.c </A> 
 <PRE> void stop_processCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="stop_viewfinder">
 <H3>stop_viewfinder</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void stop_viewfinder(w, vd_id, evt)
      /* called when the viewfinder is stopped */
 Widget          w;              /*  widget id           */
 int             *vd_id;
 XEvent          *evt;
 </PRE>
<A NAME="stop_vwf">
 <H3>stop_vwf</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void stop_vwf(vd_id, x, y)
 int             *vd_id;
 float           x,y;
 </PRE>
<A NAME="storemask">
 <H3>storemask</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/amoeba.for"> /usr/local/gifa/source/amoeba.for </A> 
 <PRE>       subroutine storemask(name,error)
 
  store all the peak amoeba to a file
 
  IN	: amoeba
  OUT   : error
 
 </PRE>
<A NAME="stplot">
 <H3>stplot</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/stplot.for"> /usr/local/gifa/source/stplot.for </A> 
 <PRE>       subroutine stplot(pl_id,matrix,si1,si2,itype,
      *              scale,skip,shf,skew,cx,cy,dy)
  IN	: pl_id,matrix,si1,si2,itype,scale,skip,shf,skew,cx,cy,dy
 
      This subr. plots a stacked plot of the matrix matrix(si2,si1).
  All measures are in cm
  The length of a single line is cx.
  if scale.eq.1 then the larger line of the 2D is cy high
  lines are clipped at cy before plotting.
  each line is shifted by shf point before plotting (might be fractional)
  and incremented in y by dy cm.
  The horizontal line may be skewed left or right with the skew param.
  the number of plotted lines is n, which depends on itype and skip,
  so that every skip lines is plotted.
  if pl_id .ne. 99  -> plot on graphic screen
  uses work1d(sizemax) found in sizeparam.inc as the skyline buffer
 
 </PRE>
<A NAME="sumvect">
 <H3>sumvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine sumvect(sum,array,size)
  IN	: array,size
  OUT	: sum
 
  SUMVECT(S,A,N) S is the sum of all elements of vector A
 
 
 </PRE>
<A NAME="superp">
 <H3>superp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/superp.for"> /usr/local/gifa/source/superp.for </A> 
 <PRE>        subroutine superp(plane2d,data)
 
  oldtab(taille1,taille2): old data array
  newtab(taille1,taille2): new data array
  nopkold: old peak number
  nopknew: new peak number
  
  IN    : oldtab
  OUT   : newtab
 
  create the newtab array in the data workspace, corresponding to the
  spectral widthes,sizes, frequencies and offsets of the data array,
  from the plane2d array, and its parameters (specw, freq, offset, size).
 
 </PRE>
<A NAME="swapbyte">
 <H3>swapbyte</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/reversebyte.c"> /usr/local/gifa/source/reversebyte.c </A> 
 <PRE> void swapbyte(char *buffer, int size)
 /* double swap byte for big_endian machines */
 
 </PRE>
<A NAME="swavect">
 <H3>swavect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  swavect(array,size)
  IN	: size
  INOUT	: array
 
  SWAVECT(A,N)   A is a real vector of length N, A is changed to a complex
                 vector of length N/2, when entering the first half of A holds
                 the real part of the complex vector, and the second part holds
                 the imaginary part. N must be power of two!!
 
 </PRE>
<A NAME="symetrize">
 <H3>symetrize</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine symetrize(matrix,size,algo)
  IN	: size,algo
  INOUT	: matrix
 
  symetrize a sizexsize matrix
  depending on algo, symetrization will be :
  algo = 1 : mean value
  algo = 2 : smallest (mean if not the same sign)
  algo = 3 : hugues' special
 
 </PRE>
<A NAME="t1fit">
 <H3>t1fit</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/t1fit.for"> /usr/local/gifa/source/t1fit.for </A> 
 <PRE>       program t1fit
 
 </PRE>
<A NAME="t1func">
 <H3>t1func</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/t1fit.for"> /usr/local/gifa/source/t1fit.for </A> 
 <PRE>       function t1func(param)
 </PRE>
<A NAME="t1func1d">
 <H3>t1func1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/t1fit.for"> /usr/local/gifa/source/t1fit.for </A> 
 <PRE>       function t1func1d(x)
 </PRE>
<A NAME="t2dto1d">
 <H3>t2dto1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine t2dto1d(axis)
  IN	: axis
 
  transfers the descriptors (held into paramfilev) from 2D
  data to 1D data, depending on axis (1, or 2)
 
 </PRE>
<A NAME="t3dto1d">
 <H3>t3dto1d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine t3dto1d(axis)
  IN	: axis
 
  transfers the descriptors (held into paramfilev) from 3D
  data to 1D data, depending on axis (1, 2 or 3)
 
 </PRE>
<A NAME="t3dto2d">
 <H3>t3dto2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine t3dto2d(axis)
  IN	: axis
 
  transfers the descriptors (held into paramfilev) from 3D
  data to 2D data, depending on axis (1, 2 or 3)
 
 
 </PRE>
<A NAME="table">
 <H3>table</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/variable.for"> /usr/local/gifa/source/variable.for </A> 
 <PRE>       function table(var,name,ind)
  IN	: var,name
  OUT	: ind
  
  true if "var" is an entry into the table "name",
    i.e. of the form name[index]
    with ind a generic string (associative arrays)
  used by getvar to extract base name and ind from index entries
  ind is set to the index as a side effect
 </PRE>
<A NAME="tdftcpx">
 <H3>tdftcpx</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tdftcpx.for"> /usr/local/gifa/source/tdftcpx.for </A> 
 <PRE>       subroutine tdftcpx(matrix,si1sp,si2sp,sign,mode)
  IN	: si1sp,si2sp,sign,mode
  INOUT	: matrix
 
       calcule la tf complexe d'un vecteur.selon la valeur de mode,
       on fait xf1,xf2,xfb ou rien.le chargement d'une ligne est
       immediat,et dans le cas d'une colonne on va chercher et 
       redeposer les points un a un.      
    
 </PRE>
<A NAME="tdftreal">
 <H3>tdftreal</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tdftreal.for"> /usr/local/gifa/source/tdftreal.for </A> 
 <PRE>       subroutine tdftreal(matrix,si1sp,si2sp,sign,direc,mode)
  IN	: si1sp,si2sp,sign,direc,mode
  INOUT	: matrix
 
       calcul la tf reelle d'un vecteur.selon la valeur de mode,
       on fait xf1,xf2,xfb ou rien.le chargement d'une ligne est
       immediat,et dans le cas d'une colonne on va chercher et 
       redeposer les points un a un.      
   si sign=1 on fait ft, si sign=-1 on fait ift
   si direc=1 reel vers complexe, si direc=-1 complexe vers reel   
 
 </PRE>
<A NAME="tfromdata">
 <H3>tfromdata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine tfromdata(dimd)
  IN	: dimd
  SIDE  : on data parameters
 
  transfers the descriptors (held into paramfilev) from the spectral
  data (described by dimd) to the data buffer
 
 </PRE>
<A NAME="tlaplace">
 <H3>tlaplace</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine tlaplace(A,n,B,p,KK1,KK2,samp)
  performs the Laplace transform between dampings KK1 and KK2
  i.e. given a series of damping amplitudes,
       exponentially spaced between KK1 and KK2
       the time response F(t(i)) is computed
           over tabulated sample point t(i)
 
      A(N) : the array of damping amplitudes
      B(P) : the computed time response
 
  IN :  N, P, A(N), KK1, KK2, Tmax
  OUT : B(P)
 
  mad 1999 first version
  MAD + TG   added extension over limits      mar 2002
 
 </PRE>
<A NAME="topcross">
 <H3>topcross</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>             subroutine topcross(vd_id,x,y,size)
  IN	: vd_id,x,y,size
 
  display on window "vd_id" a cross at location "x" "y" and of size "size"
 
 </PRE>
<A NAME="topcross2">
 <H3>topcross2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>             subroutine topcross2(vd_id,x,y,size,i)
  IN	: vd_id,x,y,size,i
 
  display on window "vd_id" a cross at location "x" "y" and of size "size"
  and writes number "i"
 
 </PRE>
<A NAME="topcross3">
 <H3>topcross3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>             subroutine topcross3(vd_id,x,y,size,st)
  IN	: vd_id,x,y,size,i
 
  display on window "vd_id" a cross at location "x" "y" and of size "size"
  and writes string st
 </PRE>
<A NAME="topcross3d">
 <H3>topcross3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>             subroutine topcross3d(vd_id,x,y,z,size,i)
  IN	: vd_id,x,y,z,size,i
 
  display on 3D window "vd_id" a 3D cross at location "x" "y" "z"
  and of size "size" and writes number "i"
 
 </PRE>
<A NAME="topcross3d3">
 <H3>topcross3d3</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/topcross.for"> /usr/local/gifa/source/topcross.for </A> 
 <PRE>             subroutine topcross3d3(vd_id,x,y,z,size,st)
  IN	: vd_id,x,y,z,size,st
 
  display on 3D window "vd_id" a 3D cross at location "x" "y" "z"
  and of size "size" and writes string st
 
 </PRE>
<A NAME="tql1">
 <H3>tql1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rs_diag.for"> /usr/local/gifa/source/rs_diag.for </A> 
 <PRE>       subroutine tql1(n,d,e,ierr)
 
      this subroutine is a translation of the algol procedure tql1,
      num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
      wilkinson.
      handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
 
      this subroutine finds the eigenvalues of a symmetric
      tridiagonal matrix by the ql method.
 
      on input
 
         n is the order of the matrix.
 
         d contains the diagonal elements of the input matrix.
 
         e contains the subdiagonal elements of the input matrix
           in its last n-1 positions.  e(1) is arbitrary.
 
       on output
 
         d contains the eigenvalues in ascending order.  if an
           error exit is made, the eigenvalues are correct and
           ordered for indices 1,2,...ierr-1, but may not be
           the smallest eigenvalues.
 
         e has been destroyed.
 
         ierr is set to
           zero       for normal return,
           j          if the j-th eigenvalue has not been
                      determined after 30 iterations.
 
      calls pythag for  dsqrt(a*a + b*b) .
 
      questions and comments should be directed to burton s. garbow,
      mathematics and computer science div, argonne national laboratory
 
      this version dated august 1983.
 
      ------------------------------------------------------------------
 
 </PRE>
<A NAME="tql2">
 <H3>tql2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rs_diag.for"> /usr/local/gifa/source/rs_diag.for </A> 
 <PRE>       subroutine tql2(nm,n,d,e,z,ierr)
 
      this subroutine is a translation of the algol procedure tql2,
      num. math. 11, 293-306(1968) by bowdler, martin, reinsch, and
      wilkinson.
      handbook for auto. comp., vol.ii-linear algebra, 227-240(1971).
 
      this subroutine finds the eigenvalues and eigenvectors
      of a symmetric tridiagonal matrix by the ql method.
      the eigenvectors of a full symmetric matrix can also
      be found if  tred2  has been used to reduce this
      full matrix to tridiagonal form.
 
      on input
 
         nm must be set to the row dimension of two-dimensional
           array parameters as declared in the calling program
           dimension statement.
 
         n is the order of the matrix.
 
         d contains the diagonal elements of the input matrix.
 
         e contains the subdiagonal elements of the input matrix
           in its last n-1 positions.  e(1) is arbitrary.
 
         z contains the transformation matrix produced in the
           reduction by  tred2, if performed.  if the eigenvectors
           of the tridiagonal matrix are desired, z must contain
           the identity matrix.
 
       on output
 
         d contains the eigenvalues in ascending order.  if an
           error exit is made, the eigenvalues are correct but
           unordered for indices 1,2,...,ierr-1.
 
         e has been destroyed.
 
         z contains orthonormal eigenvectors of the symmetric
           tridiagonal (or full) matrix.  if an error exit is made,
           z contains the eigenvectors associated with the stored
           eigenvalues.
 
         ierr is set to
           zero       for normal return,
           j          if the j-th eigenvalue has not been
                      determined after 30 iterations.
 
      calls pythag for  dsqrt(a*a + b*b) .
 
      questions and comments should be directed to burton s. garbow,
      mathematics and computer science div, argonne national laboratory
 
      this version dated august 1983.
 
      ------------------------------------------------------------------
 
 </PRE>
<A NAME="trace_cadre_zoom">
 <H3>trace_cadre_zoom</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void trace_cadre_zoom(w, vd_id, evt)
 Widget          w;              /*  widget id           */
 int             *vd_id;   
 XEvent          *evt;
 /* 
 	trace le cadre du zoom en fonction 
 	des coordonnees initiales et courantes
 	de la souris
 */
 </PRE>
<A NAME="trailing">
 <H3>trailing</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine trailing(st,l)
  INOUT	: l
  IN   	: st
 
   Removes trailing blanks at the end of string st of length l
 
 </PRE>
<A NAME="trailzero">
 <H3>trailzero</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine trailzero(st)
  INOUT	: st
 
  removes the trailing zeros of a numeric string.
  removes also the leading blanks
  eg : "  1.10000" is returned as "1.1      :
     
 </PRE>
<A NAME="trans1">
 <H3>trans1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft1d.for"> /usr/local/gifa/source/tft1d.for </A> 
 <PRE>       subroutine trans1(tdata,timage)
  IN	: timage
  OUT	: tdata
 
  the MaxEnt transform in 1D
 
 </PRE>
<A NAME="trans2">
 <H3>trans2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft2d.for"> /usr/local/gifa/source/tft2d.for </A> 
 <PRE>       subroutine trans2(ser,smx)
  IN	: timage
  OUT	: tdata
 
  the MaxEnt transform in 2D
 
   
 </PRE>
<A NAME="transf3d">
 <H3>transf3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine transf3d(x2,y2,x3,y3,z3)
  IN	: x3,y3,z3
  OUT	: x2,y2
  internal 3D library
 
  This one will perform the 3D xyz to 2D x,y transform (both in 0..1 coord)
  works in homogenous coordinates.
  (ie its a mult of rrr with x3,y3,z3,t3 (t3 = 1))
  (11 mult & div) (9 plusses) ==> 20 Flop per point
 </PRE>
<A NAME="transform">
 <H3>transform</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft.for"> /usr/local/gifa/source/tft.for </A> 
 <PRE>       subroutine transform(tdata,timage,dim,mode)
  IN	: timage,dim.mode
  OUT	: tdata
 
  implements the transform procedure for maxent
  if mode = 1 -> FT
     mode = 2 -> laplace over regular values
     mode = 3 -> laplace over tabulated values
   dim=1 if 1d nmr spectrum,dim=2 if 2d nmr specrum
 
 </PRE>
<A NAME="translap">
 <H3>translap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine translap(tdata,timage)
 
      IN :timage
      OUT:tdata
 
  implements the elementary transform step for MaxEnt inverse Laplace transform
 
    Bi = sum(j=1..n) [ Aj Lij ]
    B == tdata  /  A == timage
 
 </PRE>
<A NAME="transpose">
 <H3>transpose</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/transpose.for"> /usr/local/gifa/source/transpose.for </A> 
 <PRE>       subroutine transpose(array,size1,size2,size3,zz)
  IN	: size1,size2,size3,zz
  INOUT	: array
 
  TRANSPOSE(A,L,M,N,I)
     Transposes the 3D matrix A of size LxMxN. 
                       If I = 23 transposition of the second
                       and third dimensions,
                       If I = 13 transposition of the first
                       and third dimensions,
                       If I = 12 transposition of the first
                       and second dimensions.
    Can also be used to transpose a 2d matrix
                       A of size MxN by calling
                       transpose(A,1,M,N,23)
 
 </PRE>
<A NAME="transtlap">
 <H3>transtlap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine transtlap(tdata,timage)
 
      IN :timage
      OUT:tdata
 
  implements the elementary transform step for MaxEnt inverse Laplace transform
    for tabulated sampling value
 
 </PRE>
<A NAME="trap2d">
 <H3>trap2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math2d.for"> /usr/local/gifa/source/math2d.for </A> 
 <PRE>       subroutine trap2d(smx,size1,size2,mode,tm1,tm2,itype)
  IN	: size1,size2,mode,x,itype
  INOUT	: smx
 
  multiplies the matrix "smx" by an trapezoid function.
  goes from 0 to 1 for point 1 to tm1,
  goes from 1 to 0 for point tm2 to siz
  mode = 1 / 2 / 3  for F1, F2 F12 axes
  itype = 0 / 1 / 2 / 3  for complex type
 
 </PRE>
<A NAME="trap3d">
 <H3>trap3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/math3d.for"> /usr/local/gifa/source/math3d.for </A> 
 <PRE>       subroutine trap3d(smx,si1,si2,si3,mode,tm1,tm2,it3d)
  IN	: si1,si2,si3,mode,tm1,tm2,it3d
  INOUT	: smx
 
  3D trapezoid apodisation
 
 </PRE>
<A NAME="trapeze">
 <H3>trapeze</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/trigmult.for"> /usr/local/gifa/source/trigmult.for </A> 
 <PRE>       subroutine trapeze(vect,size,tm1,tm2,itype)
  IN	: size,tm1,tm2,itype
  INOUT	: vect
 
  multiply vect by a trapezoid function
         1.0 ... 1.0
  0 ...             ... 0
  1 ... tm1 ... tm2 ... size
  itype = 1 means complex.
 
 </PRE>
<A NAME="tred1">
 <H3>tred1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rs_diag.for"> /usr/local/gifa/source/rs_diag.for </A> 
 <PRE>       subroutine tred1(nm,n,a,d,e,e2)
 
 
      this subroutine is a translation of the algol procedure tred1,
      num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
      handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
 
      this subroutine reduces a real symmetric matrix
      to a symmetric tridiagonal matrix using
      orthogonal similarity transformations.
 
      on input
 
         nm must be set to the row dimension of two-dimensional
           array parameters as declared in the calling program
           dimension statement.
 
         n is the order of the matrix.
 
         a contains the real symmetric input matrix.  only the
           lower triangle of the matrix need be supplied.
 
      on output
 
         a contains information about the orthogonal trans-
           formations used in the reduction in its strict lower
           triangle.  the full upper triangle of a is unaltered.
 
         d contains the diagonal elements of the tridiagonal matrix.
 
         e contains the subdiagonal elements of the tridiagonal
           matrix in its last n-1 positions.  e(1) is set to zero.
 
         e2 contains the squares of the corresponding elements of e.
           e2 may coincide with e if the squares are not needed.
 
      questions and comments should be directed to burton s. garbow,
      mathematics and computer science div, argonne national laboratory
 
      this version dated august 1983.
 
      ------------------------------------------------------------------
 
 </PRE>
<A NAME="tred2">
 <H3>tred2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/rs_diag.for"> /usr/local/gifa/source/rs_diag.for </A> 
 <PRE>       subroutine tred2(nm,n,a,d,e,z)
 
      this subroutine is a translation of the algol procedure tred2,
      num. math. 11, 181-195(1968) by martin, reinsch, and wilkinson.
      handbook for auto. comp., vol.ii-linear algebra, 212-226(1971).
 
      this subroutine reduces a real symmetric matrix to a
      symmetric tridiagonal matrix using and accumulating
      orthogonal similarity transformations.
 
      on input
 
         nm must be set to the row dimension of two-dimensional
           array parameters as declared in the calling program
           dimension statement.
 
         n is the order of the matrix.
 
         a contains the real symmetric input matrix.  only the
           lower triangle of the matrix need be supplied.
 
      on output
 
         d contains the diagonal elements of the tridiagonal matrix.
 
         e contains the subdiagonal elements of the tridiagonal
           matrix in its last n-1 positions.  e(1) is set to zero.
 
         z contains the orthogonal transformation matrix
           produced in the reduction.
 
         a and z may coincide.  if distinct, a is unaltered.
 
      questions and comments should be directed to burton s. garbow,
      mathematics and computer science div, argonne national laboratory
 
      this version dated august 1983.
 
      ------------------------------------------------------------------
 
 </PRE>
<A NAME="ttodata">
 <H3>ttodata</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine ttodata(dimd)
  IN	: dimd
  SIDE  : on data parameters
 
  transfers the descriptors (held into paramfilev) from the spectral
  data (described by dimd) to the data buffer
 
 </PRE>
<A NAME="ttoi">
 <H3>ttoi</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ttoi(val,tab,sztab)
  integer version of ttoir
 </PRE>
<A NAME="ttoir">
 <H3>ttoir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       function ttoir(val,tab,sztab)
  IN	: val,tab,sztab
 
  returns index from linear interpolation of tabulated values.
 
  ASSUMES regularly spaced tabulated values
 
 </PRE>
<A NAME="ttrans1">
 <H3>ttrans1</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft1d.for"> /usr/local/gifa/source/tft1d.for </A> 
 <PRE>       subroutine ttrans1(timage,tdata)
  IN	: tdata 
  OUT	: timage
 
  the MaxEnt transform in 1D
 
 
 </PRE>
<A NAME="ttrans2">
 <H3>ttrans2</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft2d.for"> /usr/local/gifa/source/tft2d.for </A> 
 <PRE>       subroutine ttrans2(smx,ser)
  IN	: tdata 
  OUT	: timage
 
  the MaxEnt transform in 2D
 
 
 </PRE>
<A NAME="ttransform">
 <H3>ttransform</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tft.for"> /usr/local/gifa/source/tft.for </A> 
 <PRE>       subroutine ttransform(timage,tdata,dim,mode)
  IN	: tdata,dim.mode
  OUT	: timage 
 
  implements the ttransform procedure for maxent
   dim=1 if 1d nmr spectrum,dim=2 if 2d nmr specrum
 
 
 </PRE>
<A NAME="ttranslap">
 <H3>ttranslap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine ttranslap(timage,tdata)
 
      IN :tdata
      OUT:timage
 
  implements the elementary transpose transform step
      for MaxEnt inverse Laplace transform
 
    Aj = sum(i=1..p) [ Bi Lij ]
    avec Lij = exp( (i-1)/(p-1) Tmax Kj)
 
    B == tdata  /  A == timage
 
 </PRE>
<A NAME="ttranstlap">
 <H3>ttranstlap</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/laplib_new.for"> /usr/local/gifa/source/laplib_new.for </A> 
 <PRE>       subroutine ttranstlap(timage,tdata)
 
      IN :tdata
      OUT:timage
 
  implements the elementary transpose transform step
      for MaxEnt inverse Laplace transform
 
 </PRE>
<A NAME="ttshowprompt">
 <H3>ttshowprompt</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine ttshowprompt(ppt)
  IN	: ppt
  show the prompt
 
  ppt == 0 show prompt
  ppt == 1 prompt with continuation line
  ppt == 2 no prompt
 
  NOT USED !, use showprompt instead
 
 </PRE>
<A NAME="uncode">
 <H3>uncode</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/eval.for"> /usr/local/gifa/source/eval.for </A> 
 <PRE>       subroutine uncode(st,l)
  INOUT   st
  OUT     l
 
  reset char(127) to blanks in string, and return length
 </PRE>
<A NAME="unit2ir">
 <H3>unit2ir</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine unit2ir(val,x,dd)
  IN    : x,dd
  OUT   : val
  
     current => index
 
  return the x position (in current unit) expressed in index
  based on current file parameters
  dd is the axis when in nD (1, 2, (3) )
 
 </PRE>
<A NAME="unit_2_wincoord">
 <H3>unit_2_wincoord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine unit_2_wincoord(currval,retval,axe)
 
  IN :  currval (current unit), axe (1:f1, 2:f2)
  OUT:  retval	(window unit 0-1)
 
      current => window 
 
 </PRE>
<A NAME="update_mouse_coord">
 <H3>update_mouse_coord</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void update_mouse_coord(vd_id)
 int             *vd_id;
 /*
         met a jour les coord de la souris dans les label
         de la boite de zoom
 */
 </PRE>
<A NAME="uppercase">
 <H3>uppercase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools.for"> /usr/local/gifa/source/tools.for </A> 
 <PRE>       subroutine uppercase(s,n)
  IN	: n
  INOUT	: s
     put the string of char "s(n)" in uppercase
 
 </PRE>
<A NAME="uswvect">
 <H3>uswvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  uswvect(array,size)
  IN	: size
  INOUT	: array
 
  USWVECT(A,N)   A is a complex vector of length N/2, A is changed to a real
                 vector of length N where the first half holds the real
                 part of the complex vector, and the second part holds the
                 imaginary part. N must be power of two!!
 
 
 </PRE>
<A NAME="viewtop">
 <H3>viewtop</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> float viewtop(vd_id, axe, win)
 int	vd_id;
 int	axe;   /* 1 (F1) or 2 (F2) */
 float   win;
 
 /* computes ppm value from window (0..1) coordinates  
    for the view vd_id, using stored internal parameters*/
 </PRE>
<A NAME="waitasec">
 <H3>waitasec</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unix_lib.for"> /usr/local/gifa/source/unix_lib.for </A> 
 <PRE>        subroutine waitasec(second)
  IN 	: second
 
  This subroutine is used to set the process to wait for a given number
  of seconds. (may be smaller than  1.0 !!)
 
  only defined for :   sgi - hp - f2c
 </PRE>
<A NAME="whare">
 <H3>whare</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writehare.for"> /usr/local/gifa/source/writehare.for </A> 
 <PRE>        subroutine whare(spec,sizes,name)
 
 </PRE>
<A NAME="whare2d">
 <H3>whare2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/whare2d.for"> /usr/local/gifa/source/whare2d.for </A> 
 <PRE>        subroutine whare2d(spec,size1,size2,name)
  IN	: spec,size1,size2,name
 
  writes the 2D NMR data-set spec(size2,size1) as a FT-NMR compatible file
  of name "name"
  If name.eq.' '  then will prompt for a file-name
 
 </PRE>
<A NAME="whare3d">
 <H3>whare3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/whare3d.for"> /usr/local/gifa/source/whare3d.for </A> 
 <PRE>        subroutine whare3d(spec,size1,size2,size3,name)
  IN	: spec,size1,size2,size3, name
 
  writes the 3D NMR data-set spec(size3,size2,size1) as a FT-NMR compatible 2D file
  of name "name"
  If name.eq.' '  then will prompt for a file-name
 
 </PRE>
<A NAME="which_dim">
 <H3>which_dim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine which_dim(dimback)
  returns current dim
 </PRE>
<A NAME="which_int">
 <H3>which_int</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine which_int(inten, ldim, f1, f2, f3)
  returns the intensity of the point in buffer dim, at
  coordinates f1, f2, f3 (index)
 </PRE>
<A NAME="which_prompt">
 <H3>which_prompt</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE> 	subroutine which_prompt(cprompt)
  returns current prompt
 </PRE>
<A NAME="which_view">
 <H3>which_view</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>       subroutine which_view(id,st,st_l)
 
  IN : id
  OUT : st,st_l
 
  returns the view name from its id (found in variable table)
 
 </PRE>
<A NAME="which_window">
 <H3>which_window</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> void which_window(win)
 /* return the id of the current window */
 int *win;
 </PRE>
<A NAME="win2indexr">
 <H3>win2indexr</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/unit.for"> /usr/local/gifa/source/unit.for </A> 
 <PRE>       subroutine win2indexr(retval,winarg,dime,axe)
  IN  : win,dime,axe
  OUT : retval
 
      window (0..1) => index
 
  recuperation des coordonnees dans l'unite index
 
  modif MAD 5 sep 1997
  modif MAD jul `99 (recreated form recup_unit and added dime)
 
  bug : not available in 3D yet
 
 </PRE>
<A NAME="win3d_close">
 <H3>win3d_close</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_close(vd_id)
  IN	: vd_id
 
  for 3D graphic display
  close a 3D view port
 </PRE>
<A NAME="win3d_erase">
 <H3>win3d_erase</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine  win3d_erase(vd_id)
  IN	: vd_id
 
  for 3D graphic display
  erase the content of the window
 </PRE>
<A NAME="win3d_open">
 <H3>win3d_open</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_open(vd_id, cx, cy,title,length)
  IN	: cx, cy,title,length
  OUT	: vd_id
 
  for 3D graphic display
  opens a 3D view port, size is "cx" by "cy" (in cm), name is 
  "title(length)"
  returns id of window, 0 if failed
 </PRE>
<A NAME="win3d_plot_array">
 <H3>win3d_plot_array</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_plot_array(vd_id,count,xv,yv,zv)
  IN	: vd_id,count,xv,yv,zv
 
  for 3D graphic display
  draws a polyline at locations "xv(count)" "yv(count)" "zv(count)"
 </PRE>
<A NAME="win3d_plot_line">
 <H3>win3d_plot_line</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_plot_line(vd_id, x1, y1, z1, x2,	y2, z2)
  IN	: vd_id,x1,y1,z1,x2,y2,z2
 
  for 3D graphic display
  draws a line from x1,y1,z1 to x2,	y2, z2
 </PRE>
<A NAME="win3d_point">
 <H3>win3d_point</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine  win3d_point(vd_id, x1, y1, z1)
  IN	: vd_id,x1,y1,z1
 
  for 3D graphic display
  draws a point at location x1,y1,z1
 </PRE>
<A NAME="win3d_update">
 <H3>win3d_update</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_update(vd_id)
  IN	: vd_id
 
  for 3D graphic display
  realizes contens of window
 </PRE>
<A NAME="win3d_write">
 <H3>win3d_write</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/lib3d.for"> /usr/local/gifa/source/lib3d.for </A> 
 <PRE>       subroutine win3d_write(vd_id,x,y,z,text,length)
  IN	: vd_id,x,y,z,text,length
 
  for 3D graphic display
  draws text at location x,y,z
 
 </PRE>
<A NAME="win_init">
 <H3>win_init</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int win_init()
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     Subroutine to initialize X Windows.                                C
 C                                                                        C
 C     int win_init()                                                     C
 C                                                                        C
 C     returns 0 if Ok, -1 if not succeed                                 C
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="win_nextid">
 <H3>win_nextid</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int win_nextid(dimension)
 int   dimension; /*   Should be 1 or 2, depends on routine. */
 /*
 CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 C     function 2 win_nextid(dimension)                                    C
 C     Function to get a unique window_id.                                 C
 C                                                                         C
 C     dimension = the dimension of window to be flagged.                  C
 C                                                                         C
 C CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
 */
 </PRE>
<A NAME="window_dim">
 <H3>window_dim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_windows.c"> /usr/local/gifa/source/X_windows.c </A> 
 <PRE> int window_dim(int vd_id)
      /* returns the window dim from the coding in windowd */
 </PRE>
<A NAME="writec">
 <H3>writec</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writec.for"> /usr/local/gifa/source/writec.for </A> 
 <PRE>        subroutine writec (name,spec,size1,size2,specw1,
      &		specw2,off1,off2,itype,rate,sar) 
 
  IN	: name,spec,size1,size2,specw1,specw2,off1,off2,itype,rate,sar
 
  writes the 
 </PRE>
<A NAME="writedim">
 <H3>writedim</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/paramio.for"> /usr/local/gifa/source/paramio.for </A> 
 <PRE>       subroutine writedim(st,dim)
  IN	: dim
  0UT	: st
 
  converts dim (numeric) to string (F1, F2 ...)
 
 </PRE>
<A NAME="writenew">
 <H3>writenew</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writenew.for"> /usr/local/gifa/source/writenew.for </A> 
 <PRE>        subroutine writenew(spec,size1,size2,size3,name)
 
 </PRE>
<A NAME="writeparam">
 <H3>writeparam</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writeparam.for"> /usr/local/gifa/source/writeparam.for </A> 
 <PRE>        subroutine writeparam(file)
  this subroutine write paramater block of the file
 
 </PRE>
<A NAME="writeparam2d">
 <H3>writeparam2d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writeparam.for"> /usr/local/gifa/source/writeparam.for </A> 
 <PRE>        subroutine writeparam2d(file)
  this subroutine write paramater block of the file
 
 </PRE>
<A NAME="writeparam3d">
 <H3>writeparam3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writeparam3d.for"> /usr/local/gifa/source/writeparam3d.for </A> 
 <PRE>        subroutine writeparam3d(file)
  this subroutine write paramater block of the file
 
 </PRE>
<A NAME="writet3d">
 <H3>writet3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writet3d.for"> /usr/local/gifa/source/writet3d.for </A> 
 <PRE>        subroutine writet3d(spec,size1,size2,size3,name)
 
 </PRE>
<A NAME="writetc3d">
 <H3>writetc3d</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/writetc3d.for"> /usr/local/gifa/source/writetc3d.for </A> 
 <PRE>        subroutine writetc3d(spec,size1,size2,size3,name)
  IN	: spec,size1,size2,size3
  INOUT	: spec,size1,size2,size3,name
 
  this subroutine writes gifa data in compacted (base 64)
  text format.
      
 </PRE>
<A NAME="wtshort_hp">
 <H3>wtshort_hp</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibhpgl.for"> /usr/local/gifa/source/plotlibhpgl.for </A> 
 <PRE>       subroutine wtshort_hp(num,st,len)
  IN	: num
  OUT	: st,len
 
  wtshort_hp is used by the HPGL plot driver, removes leading blanks
  for numeric outputs.
  num is the number, return value is st, length of return value is len.
 </PRE>
<A NAME="wtshort_ps">
 <H3>wtshort_ps</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/plotlibpost.for"> /usr/local/gifa/source/plotlibpost.for </A> 
 <PRE>       subroutine wtshort_ps(num,st,len)
  IN	: num
  OUT	: st,len
 
  wtshort_ps is used by the postscript plot driver, removes leading blanks
  for numeric outputs.
  num is the number, return value is st, length of return value is len.
 </PRE>
<A NAME="x_initprogress">
 <H3>x_initprogress</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_util.c"> /usr/local/gifa/source/X_util.c </A> 
 <PRE> void x_initprogress(size)
 int *size;
 </PRE>
<A NAME="x_progress">
 <H3>x_progress</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_util.c"> /usr/local/gifa/source/X_util.c </A> 
 <PRE> void x_progress(count)
 int *count;
 </PRE>
<A NAME="zerofill">
 <H3>zerofill</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/tools2d.for"> /usr/local/gifa/source/tools2d.for </A> 
 <PRE>       subroutine zerofill(tablo,fill01,fill02,init1,init2)
  IN	: fill01,fill02,init1,init2
  INOUT	: tablo
 
      permit to change the dimensions of a 2D matrix. init1 and init2
      are numbers of real points before change, fill01 and 
      fill02 are numbers of real points after change
  If size is increasing, zeros are added
 
 </PRE>
<A NAME="zhermvect">
 <H3>zhermvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  zhermvect (d,a,b,size)
  IN	: a,b,size
  OUT	: d
 
  ZHERMVECT(D,A,B,N) performs the hermitian dot product of vectors 
  	A (complex*16) and B (complex*16) and put the result into D (complex*16)
 
  i.e 		d =sum(a(i) . b(i)* )
 
 </PRE>
<A NAME="zoom_arrow_downCB">
 <H3>zoom_arrow_downCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_downCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_leftCB">
 <H3>zoom_arrow_leftCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_leftCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_llowCB">
 <H3>zoom_arrow_llowCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_llowCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_lupCB">
 <H3>zoom_arrow_lupCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_lupCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_rightCB">
 <H3>zoom_arrow_rightCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_rightCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 
 </PRE>
<A NAME="zoom_arrow_rlowCB">
 <H3>zoom_arrow_rlowCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_rlowCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_rupCB">
 <H3>zoom_arrow_rupCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_rupCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_arrow_upCB">
 <H3>zoom_arrow_upCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_arrow_upCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_closeCB">
 <H3>zoom_closeCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_closeCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_param_return">
 <H3>zoom_param_return</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_interface.for"> /usr/local/gifa/source/X_interface.for </A> 
 <PRE>         subroutine zoom_param_return()
  zoom out
 
 </PRE>
<A NAME="zoom_reset">
 <H3>zoom_reset</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_reset(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 /*
 	remet zoom a zero
 */
 </PRE>
<A NAME="zoom_scale_div2CB">
 <H3>zoom_scale_div2CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_scale_div2CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_scale_moins20CB">
 <H3>zoom_scale_moins20CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_scale_moins20CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_scale_mul2CB">
 <H3>zoom_scale_mul2CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_scale_mul2CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_scale_plus20CB">
 <H3>zoom_scale_plus20CB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_scale_plus20CB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_scale_resetCB">
 <H3>zoom_scale_resetCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_scale_resetCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_zoominCB">
 <H3>zoom_zoominCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_zoominCB(w,client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zoom_zoomoutCB">
 <H3>zoom_zoomoutCB</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/X_zoom.c"> /usr/local/gifa/source/X_zoom.c </A> 
 <PRE> void zoom_zoomoutCB(w, client_data, call_data)
 Widget          w;              /*  widget id           */
 XtPointer       client_data;    /*  data from application   */
 XtPointer       call_data;      /*  data from widget class  */
 </PRE>
<A NAME="zrevvect">
 <H3>zrevvect</H3>
 in <A HREF="programer_dico.html#/usr/local/gifa/source/vect.for"> /usr/local/gifa/source/vect.for </A> 
 <PRE>       subroutine  zrevvect(array,size)
  IN	: size
  INOUT	: array
 
  ZREVVECT(A,N) reverse the order of the vector A(complex*16) and put the 
  result back into A (complex*16)
 
 </PRE>
</body></html>
